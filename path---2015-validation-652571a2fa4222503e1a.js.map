{"version":3,"sources":["webpack:///path---2015-validation-652571a2fa4222503e1a.js","webpack:///./.cache/json/2015-validation.json"],"names":["webpackJsonp","488","module","exports","data","site","siteMetadata","title","subtitle","copyright","author","name","rss","email","github","markdownRemark","id","html","excerpt","fields","tagSlugs","frontmatter","tags","date","description","pathContext","slug"],"mappings":"AAAAA,cAAc,gBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,YAAAC,SAAA,YAAAC,UAAA,yBAAAC,QAA0FC,KAAA,KAAAC,IAAA,IAAAC,MAAA,oBAAAC,OAAA,gBAA0EC,gBAAmBC,GAAA,yGAAAC,KAAA,qnrBAAqvqBC,QAAA,IAAAC,QAA6gBC,UAAA,gFAA2FC,aAAgBd,MAAA,mBAAAe,MAAA,4CAAAC,KAAA,2BAAAC,YAAA,QAAsIC,aAAgBC,KAAA","file":"path---2015-validation-652571a2fa4222503e1a.js","sourcesContent":["webpackJsonp([9671605651797],{\n\n/***/ 488:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Step Over\",\"subtitle\":\"有趣的灵魂终会相遇\",\"copyright\":\"© All rights reserved.\",\"author\":{\"name\":\"周骅\",\"rss\":\"#\",\"email\":\"zhou--hua@163.com\",\"github\":\"zhouhua-js\"}}},\"markdownRemark\":{\"id\":\"/work/playground/zhouhua.site/src/pages/articles/2015/validation.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>表单验证的需求简直太常见了。“<strong><span style=\\\"color: #ff0000;\\\">所有用户的输入都是不可信的</span></strong>”这个思想指导我们在设计表单的时候，一定要进行用户输入的验证。对于用户体验而言，越早的反馈则越佳，所以表单验证的工作应该尽可能地在前端就进行（当然，前端对于后端而言也是输入端，所以后端仍然需要进行检验）。简单的表单验证完全可以给input绑定几个change事件来进行。但表单一复杂，或者相似验证规则一多，这种编码的方式就很难管理事件了。这时候，我们通常需要使用一些库来帮助我们处理表单验证的工作。前端表单验证的库太多了，随便一搜：<a href=\\\"https://www.baidu.com/s?ie=UTF-8&#x26;wd=%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81\\\">表单验证-百度搜索</a>。</p></p>\\n<p>那……为什么还要自己实现一个呢？因为去年工作中遇到了比较复杂的验证逻辑，选一个别人的库一是要学习api，二是维护起来困难，要符合自己的页面风格也不是那么轻松；再加上表单验证器并不复杂，于是就打算自己写一个。所以这个表单验证器并不算那么地通用，不过我觉得传播思路和方法更重要，要想修修改改变成一个通用的库也很容易，只是没那么重要罢了（其实是懒……）。</p>\\n<h2>依赖</h2>\\n<p>jquery + bootstrap。jquery看来是缺不了，bootstrap没那么重要，对代码稍做修改就可以取消依赖。</p>\\n<h2>能做什么</h2>\\n<p>我期望这个表单验证器直接在html代码中指定好需要采用什么样的规则，不需要用javascript进行多余的配置；允许暂时跳过验证；允许扩展验证规则；提供验证难过、验证失败、警告三种验证结果；允许手动触发验证等等。</p>\\n<p>一个典型的bootstrap风格的表单项应该长这个样子：</p>\\n<pre class=\\\"lang:xhtml mark:5 decode:true\\\">&lt;div class=\\\"form-group\\\"&gt;\\n    &lt;label class=\\\"col-xs-2 control-label\\\"&gt;手机号码\\n        &lt;span class=\\\"request\\\"&gt;*&lt;/span&gt;：&lt;/label&gt;\\n    &lt;div class=\\\"col-xs-6\\\"&gt;\\n        &lt;input class=\\\"form-control\\\" name=\\\"mobile\\\" type=\\\"text\\\" data-validate-disable=\\\"true\\\" data-validate=\\\"request:notrim mobile\\\" /&gt;\\n        &lt;p class=\\\"text-info\\\"&gt;请输入真实手机号码。&lt;/p&gt;\\n    &lt;/div&gt;\\n    &lt;div class=\\\"help-block col-xs-4\\\"&gt;&amp;nbsp;&lt;/div&gt;\\n&lt;/div&gt;</pre>\\n<p> 重点看第5行，对于一个普通的input组件，我加了两个属性，</p>\\n<pre class=\\\"lang:js highlight:0 decode:1 inline:1 \\\" >data-validate-disable</pre>\\n<p> 有值表示表单验证时，会跳过这个input组件；</p>\\n<pre class=\\\"lang:js highlight:0 decode:1 inline:1 \\\" >data-validate</pre>\\n<p> 则存放如果要验证的话，将采用什么样的验证规则。这个例子中表示要验证这个input组件是否为空、是否为手机号码这两个规则。注意，在</p>\\n<pre class=\\\"lang:js highlight:0 decode:1 inline:1 \\\" >request</pre>\\n<p> 的后面我还加了一点内容，这是我想传递给验证规则的参数，比如这里我期望告诉验证器，如果input值只有空格，也认为是有值的。相似的，我们可以定义一个规则</p>\\n<pre class=\\\"lang:js highlight:0 decode:1 inline:1 \\\" >min</pre>\\n<p> 来处理最少几个字符，并在html中把这个设定值传递进来，就像这样：</p>\\n<pre class=\\\"lang:js highlight:0 decode:1 inline:1 \\\" >data-validate=\\\"min:10\\\"</pre>\\n<p> 。我也期望一个验证规则允许多个参数传递，参数与参数之间用逗号隔开。</p>\\n<p>看起来很有意思，那就开始动手吧。</p>\\n<h2>先写个jquery插件吧</h2>\\n<pre class=\\\"lang:js decode:true\\\">(function ($) {\\n    $.fn.validation = function () {\\n        return this.each(function () {\\n            var $this = $(this);\\n            if (!$this.is(':input')) {\\n                $this = $this.find(':input');\\n            }\\n            $this.off('blur.zh select.zh focus.zh')\\n                .on('blur.zh select.zh', validate)\\n                .on('focus.zh', clear);\\n        });\\n    };\\n}(jQuery));</pre>\\n<p> 给jquery对象添加一个</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >validation</pre>\\n<p> 方法，用法很简单：</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >$(Selector).validation()</pre>\\n<p> 。支持链式调用。<em>Selector</em>比较自由，如果是</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >:input</pre>\\n<p> 元素，则直接给这些元素初始化验证器；否则找出它们所有的</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >:input</pre>\\n<p> 子元素，给这些子元素初始化验证器。什么意思呢？就以上面的html片断为例，你可以任性地使用如下任意一种方式初始化验证器：</p>\\n<ul>\\n<li>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >$('[name=mobile]').validation(); // 选择:input</pre> \\n</li>\\n<li>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >$('.form-group').validation(); // 选择普通节点，对所有:input子元素生效</pre> \\n</li>\\n<li>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >$('body').validation(); // 对页面中所有的:input元素生效</pre>\\n</li>\\n</ul>\\n<p>再说说所谓的初始化，其实就是绑定事件。那么要绑定什么事件呢？主观上，对于一个输入框，当我们输入好了，焦点离开时，应该就进行输入内容的验证，并给出验证结果。如果验证失败，会有提示信息，但这些提示信息应该在重新获得焦点时清除，否则当用户在修正输入的时候还一直提示上次的错误信息，会让用户无所适从。那么针对以上的情况，我们需要在失去焦点（<em>blur</em>）和获得焦点（<em>focus</em>）时分别绑定验证的方法（<em>validate</em>）和清除错误信息的方法（<em>clear</em>）。另外针对checkbox、radiobox、select等控件，最好也给select事件绑定验证方法。</p>\\n<blockquote>\\n<p>为什么不使用更通用change事件来绑定验证方法呢？原因有二：</p>\\n<ol>\\n<li>我觉得有些场景需要用javascript载入默认值或历史输入。这些内容应该延后验证（不是不验证），不然刚打开页面就是表单验证错误让人很难受。所以change事件不合适。</li>\\n<li>由于获得焦点会清空错误消息，如果没有修改内容，直接失去焦点，这时不会触发change事件，导致不会再验证，表现为错误信息丢失。</li>\\n</ol>\\n</blockquote>\\n<p>那下面就来具体看看<em>validate</em>和<em>clear</em>两个方法。</p>\\n<h2>清除错误消息及验证状态设置</h2>\\n<pre class=\\\"lang:js decode:true\\\">function clear() {\\n    var $this = $(this);\\n    var $parent = $this.closest('.form-group');\\n    if (!$parent.attr('data-for') || \\n        $parent.attr('data-for') === $this.prop('name')) {\\n        $parent.attr('data-for', null).removeClass('has-error waiting has-warning')\\n            .find('.help-block').text('');\\n    }\\n}\\n\\nfunction successHandler() {\\n    var $parent = this.closest('.form-group');\\n    if (!$parent.is('.has-warning')) {\\n        clear.call(this);\\n    }\\n}\\n\\nfunction failHandler(msg) {\\n    var $parent = this.closest('.form-group');\\n    $parent.removeClass('has-warning waiting').addClass('has-error').\\n        attr('data-for', this.prop('name')).find('.help-block').text(msg);\\n}\\n\\nfunction warningHandler(msg) {\\n    var $parent = this.closest('.form-group');\\n    $parent.removeClass('waiting').addClass('has-warning').\\n        attr('data-for', this.prop('name')).find('.help-block').text(msg);\\n}</pre>\\n<p> 这一段一起说，因为这部分内容是dom操作相关的，与bootstrap强相关，如果你不用bootstrap，那就尽情地替换掉吧（估计改几个类名就行了）。这几个函数的用途从名字上就可以看出。clear上面已经提到过，清空验证信息；另外三个分别处理验证通过、验证失败和警告时的信息展示。简单是简单，但这里有两个问题需要额外考虑一下。</p>\\n<p>第一个是验证信息优先级的问题：</p>\\n<p>一个输入项可能同时有多个验证规则要匹配，可能有些验证规则通过，有些失败，有些警告。在具体处理时，我觉得比较合理的流程是：如果出现验证失败，则立刻停止后续验证，直接提示错误信息；如果警告，则提示警告信息，并继续后续规则验证；如果验证成功，理论上不需要做任何处理，直接进行下一步验证，但谨慎起见，还是做一下清空错误信息的工作，但要注意不可以清空掉警告信息（错误信息不用管，因为一产生错误信息，验证也就停止了，不会再触发验证成功了）。</p>\\n<p>另一个问题是同一个表单单元中有多个输入控件的问题，就像这样：</p>\\n<p><img src=\\\"http://www.zhouhua.info/wp-content/uploads/2015/04/QQ20150415121912.png\\\" alt=\\\"QQ20150415121912\\\"></p>\\n<p>几个控件共用了一个错误信息展示文本，我觉得如果某一个控件输入内容有误，必须再次修改这个控件内容才能清空错误信息，修改别的控件时，这个错误信息应该保留。所以在清除错误信息时，我们额外需要知道这个错误信息是由哪个控件引起的。在上面的示例中，我们在处理验证错误和警告时，把引起问题的控件的<em>name</em>记录到表单单元的<em>data-for</em>属性中了。到需要清空的时候再比对一下<em>data-for</em>和当前控件的<em>name</em>是不是一致，不一致就不清空错误信息。</p>\\n<h2>处理验证流程</h2>\\n<p>我们给输入控件的<em>blur</em>和<em>select</em>事件绑定了<em>validate</em>方法，那么这个validate方法如何实现呢？</p>\\n<pre class=\\\"lang:js mark:3-5,17,20-30 decode:true\\\">function validate() {\\n    var $this = $(this);\\n    var success = new $.Callbacks();\\n    var fail = new $.Callbacks();\\n    var warning = new $.Callbacks();\\n    var $parent = $this.closest('.form-group');\\n    success.add(function (value) {\\n        successHandler.call($this, value);\\n    });\\n    fail.add(function (value) {\\n        failHandler.call($this, value);\\n    });\\n    warning.add(function (value) {\\n        warningHandler.call($this, value);\\n    });\\n    clear.call($this);\\n    if ($this.is(':disabled') || $this.is('[data-validate-disable]')) {\\n        return;\\n    }\\n    if ($this.attr('data-validate')) {\\n        var conditions = ($this.attr('data-validate') || '').split(/\\\\s+/g);\\n        for (var i in\\n            conditions) {\\n            var condition = conditions[i];\\n            $parent.addClass('waiting');\\n            if (!pickStrategy(condition.split(/[:,]/g), $this, success, fail, warning)) {\\n                break;\\n            }\\n        }\\n    }\\n}</pre>\\n<p> 先看这段代码的前一部分，我定义了三个$.Callbacks对象，分别用以处理不同验证结果的响应。从效果上，不用$.Callbacks对象，直接传递函数引用也是可行的，我是想把dom操作和验证逻辑分离开，用类似事件触发的异步形式来处理验证逻辑。</p>\\n<p>再看第17行，它规定了两种情形不执行验证，一种是控件被禁用，另一种是控件中存在<em>data-validate-disable</em>属性。这个不用多解释了。</p>\\n<p>重点看20~30行，这段是关键。第21行中，我们把<em>data-validate</em>中的内容按空白（空格、tab、换行）切割到一个数组<em>conditions</em>中，<em>conditions</em>中的每一项都是一条需要验证的规则。那么很自然地，遍历这个数组。再看第26行，引入了一个新的方法<em>pickStrategy</em>，很明显它是对这条规则进行验证。先别管它的实现，看看它接收的参数。还记得前面我们说要允许用</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >rule:param1,param2</pre>\\n<p> 的形式给验证规则传入参数吗？<em>pickStrategy</em>拿到的第一个参数就是</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >[rule, param1, param2]</pre>\\n<p> ，通过</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >condition.spit(/[:,]/g)</pre>\\n<p> 解析出。第二个参数是当前处理的控件的jquery对象，后面三个分别是验证成功、失败、警告三种情形的回调对象。如果验证失败，<em>pickStrategy</em>应该返回</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >false</pre>\\n<p> ，同时中止验证，否则验证下一条规则。</p>\\n<h2>策略模式</h2>\\n<p>下面就要来说<em>pickStrategy</em>方法了，不过先要补充一点背景知识——策略模式。策略模式是一种设计模式。</p>\\n<p>设计模式是搞软件工程的人常常挂在嘴边的词汇，表示对设计的复用。当然前端开发在工程化的进程上每家公司情况各异，我估计绝大多数公司的前端开发并不考虑工程上的问题，只考虑完成需求。因而对于没有OO编程开发背景的前端开发而言，设计模式可能是陌生的，甚至程序设计（别紧张，没有在说程序编写）本身就是陌生的。由于工程化的忽略和javascript语言本身的优点（很多模式没必要实现）和缺点（很多模式无法实现），前端开发中很少提设计模式。那么前端开发者怎么理解设计模式呢？设计模式就是一系统问题（场景）的通用解决思路。比如有人觉得jquery的链式调用很好用，能很大程度降低工作量，于是在别的地方也用函数</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >return this;</pre>\\n<p> 的方式构造支持链式调用的函数，这就可以认为是一个模式（谈不上设计模式）。</p>\\n<p>那策略模式是为了解决什么问题，或应对什么场景的呢？如果干一件事、完成一个任务可以有不同的策略，不同的算法来完成，这些策略、算法应该具有相同的输入和输出，但可以使用不同的资源（即不care中间实现差异）。具体要采用什么策略和方法则在程序运行时依据条件选择。举个例子？</p>\\n<p><img src=\\\"http://www.zhouhua.info/wp-content/uploads/2015/04/QQ20150415155218.png\\\" alt=\\\"QQ20150415155218\\\"></p>\\n<p> 压缩文件，你可以选择不同的算法，但它们拥有相同的输入和输出。</p>\\n<p>那么我们做表单验证跟策略模式有什么关系呢？我们完全可以把每个验证规则看作是一个策略，我们支持的所有的策略放在一起，取个高大上的名字叫“策略池”。当我们想验证一个规则的时候，只需要去策略池中取出这个策略跑一下，不需要在一个很大的函数里面跑一堆if…else，或者switch…case。另外如果有新的规则加进来，只要把它塞到策略池中，无需更改已有的代码，<strong>实现验证规则和验证流程解耦</strong>。</p>\\n<p>先实现一个策略池吧：</p>\\n<pre class=\\\"lang:js decode:true  \\\">$.validation.strategy = {};</pre>\\n<p> 太棒了，一句代码就完事了，爱死javascript了！</p>\\n<p>再回到<em>pickStrategy</em>方法，看看怎么从这个策略池中拿到我们需要的验证规则：</p>\\n<pre class=\\\"lang:js mark:3,5 decode:true\\\">function pickStrategy(tokens, scope, success, fail, warning) {\\n    var name = tokens.shift();\\n    var strategy = $.validation.strategy[name];\\n    if (strategy) {\\n        return strategy.call(scope, tokens, success, fail, warning);\\n    }\\n    else {\\n        success.fire();\\n        return true;\\n    }\\n}</pre>\\n<p> 先说这个<em>token</em>，还记得它是什么吗？如果要验证的规则是“min:5”，那么<em>token</em>就是</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >['min', '5']</pre>\\n<p> 这个数组。第2行取出这个数组的第一项</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >'min'</pre>\\n<p> ，再从策略池中取出这个验证规则。如果没有这个规则，则跳过这次验证，认为此次通过；如果有这个规则，则执行这个规则（见第5行），需要注意一下第5行的<em>token</em>已经发生变化了，除去规则名称，只剩下参数了，延续前面的例子，这里<em>token</em>应该是</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >['5']</pre>\\n<p> 。</p>\\n<p>现在我们的策略池是空的，那可不行，先试着写一个验证“min”规则的方法吧：</p>\\n<pre class=\\\"lang:js decode:true\\\">$.validation.strategy.min = function (condition, success, fail) {\\n    if (this.val() === '') {\\n        success.fire();\\n        return true;\\n    }\\n    var length = +(condition &amp;&amp; condition[0]);\\n    if (length) {\\n        if (this.val().length &gt;= length) {\\n            success.fire();\\n            return true;\\n        }\\n        else {\\n            fail.fire('请至少输入' + length + '个字！');\\n            return false;\\n        }\\n    }\\n    else {\\n        success.fire();\\n        return true;\\n    }\\n}</pre>\\n<p> 这个方法内，<em>this</em>指向当前验证的控件的jquery对象，第1个参数是额外带给验证规则的参数；第2个参数是验证成功的回调，使用时需要配合</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >return true;</pre>\\n<p> （见9、10行）；第3个参数是验证失败的回调，使用是需要配合</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >return false;</pre>\\n<p> （见13、14行）；第4个参数是警告的回调，需要配合</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >return true;</pre>\\n<p> ，这个验证中没用到。</p>\\n<p>起始的几个验证方法也可以直接写在策略池中，我写了几个，供大家参考（代码比较长，展开需谨慎。不想展开？你可能要错过身份证验证、邮箱验证、url验证等一堆干货了！）：</p>\\n<pre class=\\\"minimize:true lang:js decode:true \\\">$.validation.constants = {\\n    'request': /./,\\n    'trimLeft': /^\\\\s+/,\\n    'trimRight': /\\\\s+$/,\\n    'trim': /(^\\\\s+)|(\\\\s+$)/g,\\n    'number': /^-?\\\\d+(,\\\\d{3,4})*(\\\\.\\\\d+)?$/,\\n    'purenumber': /^\\\\d+$/,\\n    'shenfenzheng': /^\\\\d{17}[\\\\dx]$/i,\\n    'taibaozheng': /^\\\\d{8}(\\\\d{2})?$/,\\n    'zhizhao': /^\\\\d{15}$/,\\n    'mobile': /^1[345789]\\\\d{9}$/,\\n    'telephone': /^\\\\d{7,8}([ +-]\\\\d+)?$/,\\n    'email': /^[a-z0-9.\\\\-_+]+@[a-z0-9\\\\-_]+(.[a-z0-9\\\\-_]+)+$/i,\\n    'url': /^(https?:\\\\/\\\\/)?(([\\\\d]{1,3}\\\\.){3}[\\\\d]{1,3}|([\\\\d\\\\w_!~*\\\\\\\\'()-]+\\\\.)*([\\\\d\\\\w][\\\\d\\\\w-]{0,61})?[\\\\d\\\\w]\\\\.[\\\\w]{2,6})(:[\\\\d]{1,4})?((\\\\/?)|(\\\\/[\\\\d\\\\w_!~*\\\\\\\\'().;?:@&amp;=+$,%#-]+)+\\\\/?)$/\\n};\\n\\n$.validation.strategy = {\\n    'request': function (condition, success, fail) {\\n        if (this.is(\\\"[type=checkbox]\\\") || this.is(\\\"[type=radio]\\\")) {\\n            var name = this.attr(\\\"name\\\");\\n            if (name) {\\n                if ($(\\\"[name=\\\" + name + \\\"]:checked\\\").length) {\\n                    success.fire();\\n                    return true;\\n                }\\n                else {\\n                    fail.fire('不能为空！');\\n                    return false;\\n                }\\n            }\\n            else {\\n                success.fire();\\n                return true;\\n            }\\n        }\\n        else {\\n            if (condition &amp;&amp; condition[0]) {\\n                switch (condition[0].toLowerCase()) {\\n                    case 'notrim':\\n                        break;\\n                    case 'trimleft':\\n                        this.val(this.val().replace($.validation.constants.trimLeft, ''));\\n                        break;\\n                    case 'trimright':\\n                        this.val(this.val().replace($.validation.constants.trimRight, ''));\\n                        break;\\n                    default:\\n                        this.val(this.val().replace($.validation.constants.trim, ''));\\n                        break;\\n                }\\n            }\\n            if ($.validation.constants.request.test(this.val())) {\\n                success.fire();\\n                return true;\\n            }\\n            fail.fire('不能为空！');\\n            return false;\\n        }\\n    },\\n    'min': function (condition, success, fail) {\\n        if (this.val() === '') {\\n            success.fire();\\n            return true;\\n        }\\n        var length = +(condition &amp;&amp; condition[0]);\\n        if (length) {\\n            if (this.val().length &gt;= length) {\\n                success.fire();\\n                return true;\\n            }\\n            else {\\n                fail.fire('请至少输入' + length + '个字！');\\n                return false;\\n            }\\n        }\\n        else {\\n            success.fire();\\n            return true;\\n        }\\n    },\\n    'max': function (condition, success, fail) {\\n        var length = +(condition &amp;&amp; condition[0]);\\n        if (length) {\\n            if (this.val().length &lt;= length) {\\n                success.fire();\\n                return true;\\n            }\\n            else {\\n                fail.fire('不能超过' + length + '个字！');\\n                return false;\\n            }\\n        }\\n        else {\\n            success.fire();\\n            return true;\\n        }\\n    },\\n    'number': function (condition, success, fail) {\\n        var value = this.val();\\n        if (value === '') {\\n            success.fire();\\n            return true;\\n        }\\n        condition = condition || [];\\n        if (!$.validation.constants.number.test(value)) {\\n            fail.fire('请输入数字！');\\n            return false;\\n        }\\n        for (var i in\\n            condition) {\\n            var c = condition[i].toLowerCase();\\n            if (c === 'pure') {\\n                if (!$.validation.constants.purenumber.test(value)) {\\n                    fail.fire('请输入0~9组成的数字！');\\n                    return false;\\n                }\\n            }\\n            else if (/^\\\\d+[~-]\\\\d+$/.test(c)) {\\n                var match = c.match(/\\\\d+/g);\\n                var length = value.length;\\n                if (length &lt; +match[0]) {\\n                    fail.fire('请至少输入' + match[0] + '位数字！');\\n                    return false;\\n                }\\n                if (length &gt; +match[1]) {\\n                    fail.fire('最多只能输入' + match[1] + '位数字！');\\n                    return false;\\n                }\\n            }\\n            else if (/^\\\\d+$/.test(c)) {\\n                if (+c !== value.length) {\\n                    fail.fire('请输入' + c + '位数字！');\\n                    return false;\\n                }\\n            }\\n            success.fire();\\n            return true;\\n        }\\n    },\\n    'mobile': function (condition, success, fail) {\\n        var value = this.val();\\n        if (value === '') {\\n            success.fire();\\n            return true;\\n        }\\n        if (!$.validation.constants.mobile.test(value)) {\\n            fail.fire('手机号码输入有误，请检查后重新输入！');\\n            return false;\\n        }\\n        success.fire();\\n        return true;\\n    },\\n    'url': function (condition, success, fail) {\\n        var value = this.val();\\n        if (value === '') {\\n            success.fire();\\n            return true;\\n        }\\n        if (!$.validation.constants.url.test(value.toLowerCase())) {\\n            fail.fire('请输入正确的网址！如http://www.baidu.com');\\n            return false;\\n        }\\n        success.fire();\\n        return true;\\n    },\\n    'email': function (condition, success, fail) {\\n        var value = this.val();\\n        if (value === '') {\\n            success.fire();\\n            return true;\\n        }\\n        if (!$.validation.constants.email.test(value)) {\\n            fail.fire('电子邮箱格式错误，请检查后重新输入！');\\n            return false;\\n        }\\n        success.fire();\\n        return true;\\n    },\\n    'telephone': function (condition, success, fail) {\\n        var value = this.val();\\n        if (value === '') {\\n            success.fire();\\n            return true;\\n        }\\n        if (!$.validation.constants.telephone.test(value)) {\\n            fail.fire('电话号码输入有误，请检查后重新输入！！');\\n            return false;\\n        }\\n        success.fire();\\n        return true;\\n    },\\n    'shenfenzheng': function (condition, success, fail) {\\n        var value = this.val();\\n        if (value === '') {\\n            success.fire();\\n            return true;\\n        }\\n        value = value.toLowerCase();\\n        if ($.validation.constants.shenfenzheng.test(value)) {\\n            var numbers = value.toLowerCase().split('');\\n            // 验证地区\\n            var aCity = {\\n                11: '北京',\\n                12: '天津',\\n                13: '河北',\\n                14: '山西',\\n                15: '内蒙古',\\n                21: '辽宁',\\n                22: '吉林',\\n                23: '黑龙江',\\n                31: '上海',\\n                32: '江苏',\\n                33: '浙江',\\n                34: '安徽',\\n                35: '福建',\\n                36: '江西',\\n                37: '山东',\\n                41: '河南',\\n                42: '湖北',\\n                43: '湖南',\\n                44: '广东',\\n                45: '广西',\\n                46: '海南',\\n                50: '重庆',\\n                51: '四川',\\n                52: '贵州',\\n                53: '云南',\\n                54: '西藏',\\n                61: '陕西',\\n                62: '甘肃',\\n                63: '青海',\\n                64: '宁夏',\\n                65: '新疆',\\n                71: '台湾',\\n                81: '香港',\\n                82: '澳门',\\n                91: '国外'\\n            };\\n            if (!aCity[numbers[0] + numbers[1]]) {\\n                fail.fire('身份证格式有误，请检查后重新输入！');\\n                return false;\\n            }\\n            var wi = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2];\\n            var check = ['1', '0', 'x', '9', '8', '7', '6', '5', '4', '3', '2'];\\n            var _sum = 0;\\n            for (var i = 0; i &lt; 17; i++) {\\n                _sum += +numbers[i] * +wi[i];\\n            }\\n            if (numbers[17] != check[_sum % 11]) {\\n                fail.fire('身份证格式有误，请检查后重新输入！');\\n                return false;\\n            }\\n            success.fire();\\n            return true;\\n        }\\n        else {\\n            fail.fire('请输入18位身份证！');\\n            return false;\\n        }\\n    },\\n    'taibaozheng': function (condition, success, fail) {\\n        var value = this.val();\\n        if (value === '') {\\n            success.fire();\\n            return true;\\n        }\\n        if (!$.validation.constants.taibaozheng.test(value)) {\\n            fail.fire('台胞证格式有误，请检查后重新输入！');\\n            return false;\\n        }\\n        success.fire();\\n        return true;\\n    },\\n    'zhizhao': function (condition, success, fail) {\\n        var value = this.val();\\n        if (value === '') {\\n            success.fire();\\n            return true;\\n        }\\n        if ($.validation.constants.zhizhao.test(value)) {\\n            var p = 10;\\n            var s;\\n            var a;\\n            var numbers = value.split('');\\n            for (var i = 0; i &lt; 15; i++) {\\n                a = +numbers[i];\\n                s = (p % 11) + a;\\n                p = (s % 10) * 2;\\n                if (p === 0) {\\n                    p = 20;\\n                }\\n            }\\n            if (s % 10 !== 1) {\\n                fail.fire('工商营业执照输入有误，请检查后重新输入！');\\n                return false;\\n            }\\n            success.fire();\\n            return true;\\n        }\\n        else {\\n            fail.fire('请输入15位工商营业执照！');\\n            return false;\\n        }\\n    }\\n};</pre>\\n<h2>添加验证规则</h2>\\n<p>说好的支持自定义验证规则呢？放心，不会少的，而且超简单：</p>\\n<pre class=\\\"lang:js decode:true \\\">$.validation = function (condition, process) {\\n    $.validation.strategy[condition] = process;\\n};</pre>\\n<p> 加个静态方法搞定。</p>\\n<h2>手动发起验证</h2>\\n<p>有些场景下需要手动check一下表单内容才放心吧：</p>\\n<pre class=\\\"lang:js decode:true \\\">$.fn.exec = function () {\\n    return this.each(function () {\\n        var $this = $(this);\\n        if (!$this.is(':input')) {\\n            $this = $this.find(':input');\\n        }\\n        $this.blur();\\n    });\\n};</pre>\\n<p> 原理很简单，对:input子元素触发一次blur事件。</p>\\n<h2>还有一些是我没有做的</h2>\\n<p>都不是很复杂，因为我的业务场景不关注这些，所以就懒过去了。</p>\\n<ol>\\n<li>\\n<p>没做通用的ajax验证\\n现在对于ajax的验证，可以这样做：</p>\\n<pre class=\\\"lang:js decode:true \\\">$.validation('ajax_xx',function(c, s, f) {\\n$.post('some_url',function(data){\\n    if (data.success) {\\n        s.fire();\\n    }else{\\n        f.fire('xxxxxxxx');\\n    }\\n});\\n});</pre>\\n<p> 表单提交前，除了检查有没有.has-error的元素找到填写出错项，还要检查有没有.wait元素，如果有的话都不能立刻提交。\\n如果要有一个通用的ajax验证机制，可以自行扩展<em>$.validation</em>方法</p>\\n</li>\\n<li>\\n<p>没做验证失败时表单提交阻断\\n正如上一条中说的，表单提交前，需要检查.has-error和.wait元素，可以自行扩展<em>$.fn.validation</em>方法，添加form的submit事件绑定。</p>\\n</li>\\n<li>\\n<p>没有为handle验证状态的dom操作提供接口\\n不想做，bootstrap挺好的。</p>\\n</li>\\n<li>\\n<p>没有测试用例\\n不打算给这些代码添加逻辑了，不想写测试用例。</p>\\n</li>\\n</ol>\\n<h2>下载</h2>\\n<p><a href=\\\"http://www.zhouhua.info/wp-content/uploads/2015/04/validation.js\\\">validation.js</a></p>\",\"excerpt\":\"…\",\"fields\":{\"tagSlugs\":[\"/tags/javascript/\",\"/tags/jquery/\",\"/tags/策略模式/\",\"/tags/表单验证/\",\"/tags/设计模式/\"]},\"frontmatter\":{\"title\":\"干货！一步步实现自己的表单验证器\",\"tags\":[\"Javascript\",\"jquery\",\"策略模式\",\"表单验证\",\"设计模式\"],\"date\":\"2015-04-15T17:21:57.000Z\",\"description\":null}}},\"pathContext\":{\"slug\":\"/2015/validation/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---2015-validation-652571a2fa4222503e1a.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Step Over\",\"subtitle\":\"有趣的灵魂终会相遇\",\"copyright\":\"© All rights reserved.\",\"author\":{\"name\":\"周骅\",\"rss\":\"#\",\"email\":\"zhou--hua@163.com\",\"github\":\"zhouhua-js\"}}},\"markdownRemark\":{\"id\":\"/work/playground/zhouhua.site/src/pages/articles/2015/validation.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>表单验证的需求简直太常见了。“<strong><span style=\\\"color: #ff0000;\\\">所有用户的输入都是不可信的</span></strong>”这个思想指导我们在设计表单的时候，一定要进行用户输入的验证。对于用户体验而言，越早的反馈则越佳，所以表单验证的工作应该尽可能地在前端就进行（当然，前端对于后端而言也是输入端，所以后端仍然需要进行检验）。简单的表单验证完全可以给input绑定几个change事件来进行。但表单一复杂，或者相似验证规则一多，这种编码的方式就很难管理事件了。这时候，我们通常需要使用一些库来帮助我们处理表单验证的工作。前端表单验证的库太多了，随便一搜：<a href=\\\"https://www.baidu.com/s?ie=UTF-8&#x26;wd=%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81\\\">表单验证-百度搜索</a>。</p></p>\\n<p>那……为什么还要自己实现一个呢？因为去年工作中遇到了比较复杂的验证逻辑，选一个别人的库一是要学习api，二是维护起来困难，要符合自己的页面风格也不是那么轻松；再加上表单验证器并不复杂，于是就打算自己写一个。所以这个表单验证器并不算那么地通用，不过我觉得传播思路和方法更重要，要想修修改改变成一个通用的库也很容易，只是没那么重要罢了（其实是懒……）。</p>\\n<h2>依赖</h2>\\n<p>jquery + bootstrap。jquery看来是缺不了，bootstrap没那么重要，对代码稍做修改就可以取消依赖。</p>\\n<h2>能做什么</h2>\\n<p>我期望这个表单验证器直接在html代码中指定好需要采用什么样的规则，不需要用javascript进行多余的配置；允许暂时跳过验证；允许扩展验证规则；提供验证难过、验证失败、警告三种验证结果；允许手动触发验证等等。</p>\\n<p>一个典型的bootstrap风格的表单项应该长这个样子：</p>\\n<pre class=\\\"lang:xhtml mark:5 decode:true\\\">&lt;div class=\\\"form-group\\\"&gt;\\n    &lt;label class=\\\"col-xs-2 control-label\\\"&gt;手机号码\\n        &lt;span class=\\\"request\\\"&gt;*&lt;/span&gt;：&lt;/label&gt;\\n    &lt;div class=\\\"col-xs-6\\\"&gt;\\n        &lt;input class=\\\"form-control\\\" name=\\\"mobile\\\" type=\\\"text\\\" data-validate-disable=\\\"true\\\" data-validate=\\\"request:notrim mobile\\\" /&gt;\\n        &lt;p class=\\\"text-info\\\"&gt;请输入真实手机号码。&lt;/p&gt;\\n    &lt;/div&gt;\\n    &lt;div class=\\\"help-block col-xs-4\\\"&gt;&amp;nbsp;&lt;/div&gt;\\n&lt;/div&gt;</pre>\\n<p> 重点看第5行，对于一个普通的input组件，我加了两个属性，</p>\\n<pre class=\\\"lang:js highlight:0 decode:1 inline:1 \\\" >data-validate-disable</pre>\\n<p> 有值表示表单验证时，会跳过这个input组件；</p>\\n<pre class=\\\"lang:js highlight:0 decode:1 inline:1 \\\" >data-validate</pre>\\n<p> 则存放如果要验证的话，将采用什么样的验证规则。这个例子中表示要验证这个input组件是否为空、是否为手机号码这两个规则。注意，在</p>\\n<pre class=\\\"lang:js highlight:0 decode:1 inline:1 \\\" >request</pre>\\n<p> 的后面我还加了一点内容，这是我想传递给验证规则的参数，比如这里我期望告诉验证器，如果input值只有空格，也认为是有值的。相似的，我们可以定义一个规则</p>\\n<pre class=\\\"lang:js highlight:0 decode:1 inline:1 \\\" >min</pre>\\n<p> 来处理最少几个字符，并在html中把这个设定值传递进来，就像这样：</p>\\n<pre class=\\\"lang:js highlight:0 decode:1 inline:1 \\\" >data-validate=\\\"min:10\\\"</pre>\\n<p> 。我也期望一个验证规则允许多个参数传递，参数与参数之间用逗号隔开。</p>\\n<p>看起来很有意思，那就开始动手吧。</p>\\n<h2>先写个jquery插件吧</h2>\\n<pre class=\\\"lang:js decode:true\\\">(function ($) {\\n    $.fn.validation = function () {\\n        return this.each(function () {\\n            var $this = $(this);\\n            if (!$this.is(':input')) {\\n                $this = $this.find(':input');\\n            }\\n            $this.off('blur.zh select.zh focus.zh')\\n                .on('blur.zh select.zh', validate)\\n                .on('focus.zh', clear);\\n        });\\n    };\\n}(jQuery));</pre>\\n<p> 给jquery对象添加一个</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >validation</pre>\\n<p> 方法，用法很简单：</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >$(Selector).validation()</pre>\\n<p> 。支持链式调用。<em>Selector</em>比较自由，如果是</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >:input</pre>\\n<p> 元素，则直接给这些元素初始化验证器；否则找出它们所有的</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >:input</pre>\\n<p> 子元素，给这些子元素初始化验证器。什么意思呢？就以上面的html片断为例，你可以任性地使用如下任意一种方式初始化验证器：</p>\\n<ul>\\n<li>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >$('[name=mobile]').validation(); // 选择:input</pre> \\n</li>\\n<li>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >$('.form-group').validation(); // 选择普通节点，对所有:input子元素生效</pre> \\n</li>\\n<li>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >$('body').validation(); // 对页面中所有的:input元素生效</pre>\\n</li>\\n</ul>\\n<p>再说说所谓的初始化，其实就是绑定事件。那么要绑定什么事件呢？主观上，对于一个输入框，当我们输入好了，焦点离开时，应该就进行输入内容的验证，并给出验证结果。如果验证失败，会有提示信息，但这些提示信息应该在重新获得焦点时清除，否则当用户在修正输入的时候还一直提示上次的错误信息，会让用户无所适从。那么针对以上的情况，我们需要在失去焦点（<em>blur</em>）和获得焦点（<em>focus</em>）时分别绑定验证的方法（<em>validate</em>）和清除错误信息的方法（<em>clear</em>）。另外针对checkbox、radiobox、select等控件，最好也给select事件绑定验证方法。</p>\\n<blockquote>\\n<p>为什么不使用更通用change事件来绑定验证方法呢？原因有二：</p>\\n<ol>\\n<li>我觉得有些场景需要用javascript载入默认值或历史输入。这些内容应该延后验证（不是不验证），不然刚打开页面就是表单验证错误让人很难受。所以change事件不合适。</li>\\n<li>由于获得焦点会清空错误消息，如果没有修改内容，直接失去焦点，这时不会触发change事件，导致不会再验证，表现为错误信息丢失。</li>\\n</ol>\\n</blockquote>\\n<p>那下面就来具体看看<em>validate</em>和<em>clear</em>两个方法。</p>\\n<h2>清除错误消息及验证状态设置</h2>\\n<pre class=\\\"lang:js decode:true\\\">function clear() {\\n    var $this = $(this);\\n    var $parent = $this.closest('.form-group');\\n    if (!$parent.attr('data-for') || \\n        $parent.attr('data-for') === $this.prop('name')) {\\n        $parent.attr('data-for', null).removeClass('has-error waiting has-warning')\\n            .find('.help-block').text('');\\n    }\\n}\\n\\nfunction successHandler() {\\n    var $parent = this.closest('.form-group');\\n    if (!$parent.is('.has-warning')) {\\n        clear.call(this);\\n    }\\n}\\n\\nfunction failHandler(msg) {\\n    var $parent = this.closest('.form-group');\\n    $parent.removeClass('has-warning waiting').addClass('has-error').\\n        attr('data-for', this.prop('name')).find('.help-block').text(msg);\\n}\\n\\nfunction warningHandler(msg) {\\n    var $parent = this.closest('.form-group');\\n    $parent.removeClass('waiting').addClass('has-warning').\\n        attr('data-for', this.prop('name')).find('.help-block').text(msg);\\n}</pre>\\n<p> 这一段一起说，因为这部分内容是dom操作相关的，与bootstrap强相关，如果你不用bootstrap，那就尽情地替换掉吧（估计改几个类名就行了）。这几个函数的用途从名字上就可以看出。clear上面已经提到过，清空验证信息；另外三个分别处理验证通过、验证失败和警告时的信息展示。简单是简单，但这里有两个问题需要额外考虑一下。</p>\\n<p>第一个是验证信息优先级的问题：</p>\\n<p>一个输入项可能同时有多个验证规则要匹配，可能有些验证规则通过，有些失败，有些警告。在具体处理时，我觉得比较合理的流程是：如果出现验证失败，则立刻停止后续验证，直接提示错误信息；如果警告，则提示警告信息，并继续后续规则验证；如果验证成功，理论上不需要做任何处理，直接进行下一步验证，但谨慎起见，还是做一下清空错误信息的工作，但要注意不可以清空掉警告信息（错误信息不用管，因为一产生错误信息，验证也就停止了，不会再触发验证成功了）。</p>\\n<p>另一个问题是同一个表单单元中有多个输入控件的问题，就像这样：</p>\\n<p><img src=\\\"http://www.zhouhua.info/wp-content/uploads/2015/04/QQ20150415121912.png\\\" alt=\\\"QQ20150415121912\\\"></p>\\n<p>几个控件共用了一个错误信息展示文本，我觉得如果某一个控件输入内容有误，必须再次修改这个控件内容才能清空错误信息，修改别的控件时，这个错误信息应该保留。所以在清除错误信息时，我们额外需要知道这个错误信息是由哪个控件引起的。在上面的示例中，我们在处理验证错误和警告时，把引起问题的控件的<em>name</em>记录到表单单元的<em>data-for</em>属性中了。到需要清空的时候再比对一下<em>data-for</em>和当前控件的<em>name</em>是不是一致，不一致就不清空错误信息。</p>\\n<h2>处理验证流程</h2>\\n<p>我们给输入控件的<em>blur</em>和<em>select</em>事件绑定了<em>validate</em>方法，那么这个validate方法如何实现呢？</p>\\n<pre class=\\\"lang:js mark:3-5,17,20-30 decode:true\\\">function validate() {\\n    var $this = $(this);\\n    var success = new $.Callbacks();\\n    var fail = new $.Callbacks();\\n    var warning = new $.Callbacks();\\n    var $parent = $this.closest('.form-group');\\n    success.add(function (value) {\\n        successHandler.call($this, value);\\n    });\\n    fail.add(function (value) {\\n        failHandler.call($this, value);\\n    });\\n    warning.add(function (value) {\\n        warningHandler.call($this, value);\\n    });\\n    clear.call($this);\\n    if ($this.is(':disabled') || $this.is('[data-validate-disable]')) {\\n        return;\\n    }\\n    if ($this.attr('data-validate')) {\\n        var conditions = ($this.attr('data-validate') || '').split(/\\\\s+/g);\\n        for (var i in\\n            conditions) {\\n            var condition = conditions[i];\\n            $parent.addClass('waiting');\\n            if (!pickStrategy(condition.split(/[:,]/g), $this, success, fail, warning)) {\\n                break;\\n            }\\n        }\\n    }\\n}</pre>\\n<p> 先看这段代码的前一部分，我定义了三个$.Callbacks对象，分别用以处理不同验证结果的响应。从效果上，不用$.Callbacks对象，直接传递函数引用也是可行的，我是想把dom操作和验证逻辑分离开，用类似事件触发的异步形式来处理验证逻辑。</p>\\n<p>再看第17行，它规定了两种情形不执行验证，一种是控件被禁用，另一种是控件中存在<em>data-validate-disable</em>属性。这个不用多解释了。</p>\\n<p>重点看20~30行，这段是关键。第21行中，我们把<em>data-validate</em>中的内容按空白（空格、tab、换行）切割到一个数组<em>conditions</em>中，<em>conditions</em>中的每一项都是一条需要验证的规则。那么很自然地，遍历这个数组。再看第26行，引入了一个新的方法<em>pickStrategy</em>，很明显它是对这条规则进行验证。先别管它的实现，看看它接收的参数。还记得前面我们说要允许用</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >rule:param1,param2</pre>\\n<p> 的形式给验证规则传入参数吗？<em>pickStrategy</em>拿到的第一个参数就是</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >[rule, param1, param2]</pre>\\n<p> ，通过</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >condition.spit(/[:,]/g)</pre>\\n<p> 解析出。第二个参数是当前处理的控件的jquery对象，后面三个分别是验证成功、失败、警告三种情形的回调对象。如果验证失败，<em>pickStrategy</em>应该返回</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >false</pre>\\n<p> ，同时中止验证，否则验证下一条规则。</p>\\n<h2>策略模式</h2>\\n<p>下面就要来说<em>pickStrategy</em>方法了，不过先要补充一点背景知识——策略模式。策略模式是一种设计模式。</p>\\n<p>设计模式是搞软件工程的人常常挂在嘴边的词汇，表示对设计的复用。当然前端开发在工程化的进程上每家公司情况各异，我估计绝大多数公司的前端开发并不考虑工程上的问题，只考虑完成需求。因而对于没有OO编程开发背景的前端开发而言，设计模式可能是陌生的，甚至程序设计（别紧张，没有在说程序编写）本身就是陌生的。由于工程化的忽略和javascript语言本身的优点（很多模式没必要实现）和缺点（很多模式无法实现），前端开发中很少提设计模式。那么前端开发者怎么理解设计模式呢？设计模式就是一系统问题（场景）的通用解决思路。比如有人觉得jquery的链式调用很好用，能很大程度降低工作量，于是在别的地方也用函数</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >return this;</pre>\\n<p> 的方式构造支持链式调用的函数，这就可以认为是一个模式（谈不上设计模式）。</p>\\n<p>那策略模式是为了解决什么问题，或应对什么场景的呢？如果干一件事、完成一个任务可以有不同的策略，不同的算法来完成，这些策略、算法应该具有相同的输入和输出，但可以使用不同的资源（即不care中间实现差异）。具体要采用什么策略和方法则在程序运行时依据条件选择。举个例子？</p>\\n<p><img src=\\\"http://www.zhouhua.info/wp-content/uploads/2015/04/QQ20150415155218.png\\\" alt=\\\"QQ20150415155218\\\"></p>\\n<p> 压缩文件，你可以选择不同的算法，但它们拥有相同的输入和输出。</p>\\n<p>那么我们做表单验证跟策略模式有什么关系呢？我们完全可以把每个验证规则看作是一个策略，我们支持的所有的策略放在一起，取个高大上的名字叫“策略池”。当我们想验证一个规则的时候，只需要去策略池中取出这个策略跑一下，不需要在一个很大的函数里面跑一堆if…else，或者switch…case。另外如果有新的规则加进来，只要把它塞到策略池中，无需更改已有的代码，<strong>实现验证规则和验证流程解耦</strong>。</p>\\n<p>先实现一个策略池吧：</p>\\n<pre class=\\\"lang:js decode:true  \\\">$.validation.strategy = {};</pre>\\n<p> 太棒了，一句代码就完事了，爱死javascript了！</p>\\n<p>再回到<em>pickStrategy</em>方法，看看怎么从这个策略池中拿到我们需要的验证规则：</p>\\n<pre class=\\\"lang:js mark:3,5 decode:true\\\">function pickStrategy(tokens, scope, success, fail, warning) {\\n    var name = tokens.shift();\\n    var strategy = $.validation.strategy[name];\\n    if (strategy) {\\n        return strategy.call(scope, tokens, success, fail, warning);\\n    }\\n    else {\\n        success.fire();\\n        return true;\\n    }\\n}</pre>\\n<p> 先说这个<em>token</em>，还记得它是什么吗？如果要验证的规则是“min:5”，那么<em>token</em>就是</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >['min', '5']</pre>\\n<p> 这个数组。第2行取出这个数组的第一项</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >'min'</pre>\\n<p> ，再从策略池中取出这个验证规则。如果没有这个规则，则跳过这次验证，认为此次通过；如果有这个规则，则执行这个规则（见第5行），需要注意一下第5行的<em>token</em>已经发生变化了，除去规则名称，只剩下参数了，延续前面的例子，这里<em>token</em>应该是</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >['5']</pre>\\n<p> 。</p>\\n<p>现在我们的策略池是空的，那可不行，先试着写一个验证“min”规则的方法吧：</p>\\n<pre class=\\\"lang:js decode:true\\\">$.validation.strategy.min = function (condition, success, fail) {\\n    if (this.val() === '') {\\n        success.fire();\\n        return true;\\n    }\\n    var length = +(condition &amp;&amp; condition[0]);\\n    if (length) {\\n        if (this.val().length &gt;= length) {\\n            success.fire();\\n            return true;\\n        }\\n        else {\\n            fail.fire('请至少输入' + length + '个字！');\\n            return false;\\n        }\\n    }\\n    else {\\n        success.fire();\\n        return true;\\n    }\\n}</pre>\\n<p> 这个方法内，<em>this</em>指向当前验证的控件的jquery对象，第1个参数是额外带给验证规则的参数；第2个参数是验证成功的回调，使用时需要配合</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >return true;</pre>\\n<p> （见9、10行）；第3个参数是验证失败的回调，使用是需要配合</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >return false;</pre>\\n<p> （见13、14行）；第4个参数是警告的回调，需要配合</p>\\n<pre class=\\\"lang:js decode:1 inline:1 \\\" >return true;</pre>\\n<p> ，这个验证中没用到。</p>\\n<p>起始的几个验证方法也可以直接写在策略池中，我写了几个，供大家参考（代码比较长，展开需谨慎。不想展开？你可能要错过身份证验证、邮箱验证、url验证等一堆干货了！）：</p>\\n<pre class=\\\"minimize:true lang:js decode:true \\\">$.validation.constants = {\\n    'request': /./,\\n    'trimLeft': /^\\\\s+/,\\n    'trimRight': /\\\\s+$/,\\n    'trim': /(^\\\\s+)|(\\\\s+$)/g,\\n    'number': /^-?\\\\d+(,\\\\d{3,4})*(\\\\.\\\\d+)?$/,\\n    'purenumber': /^\\\\d+$/,\\n    'shenfenzheng': /^\\\\d{17}[\\\\dx]$/i,\\n    'taibaozheng': /^\\\\d{8}(\\\\d{2})?$/,\\n    'zhizhao': /^\\\\d{15}$/,\\n    'mobile': /^1[345789]\\\\d{9}$/,\\n    'telephone': /^\\\\d{7,8}([ +-]\\\\d+)?$/,\\n    'email': /^[a-z0-9.\\\\-_+]+@[a-z0-9\\\\-_]+(.[a-z0-9\\\\-_]+)+$/i,\\n    'url': /^(https?:\\\\/\\\\/)?(([\\\\d]{1,3}\\\\.){3}[\\\\d]{1,3}|([\\\\d\\\\w_!~*\\\\\\\\'()-]+\\\\.)*([\\\\d\\\\w][\\\\d\\\\w-]{0,61})?[\\\\d\\\\w]\\\\.[\\\\w]{2,6})(:[\\\\d]{1,4})?((\\\\/?)|(\\\\/[\\\\d\\\\w_!~*\\\\\\\\'().;?:@&amp;=+$,%#-]+)+\\\\/?)$/\\n};\\n\\n$.validation.strategy = {\\n    'request': function (condition, success, fail) {\\n        if (this.is(\\\"[type=checkbox]\\\") || this.is(\\\"[type=radio]\\\")) {\\n            var name = this.attr(\\\"name\\\");\\n            if (name) {\\n                if ($(\\\"[name=\\\" + name + \\\"]:checked\\\").length) {\\n                    success.fire();\\n                    return true;\\n                }\\n                else {\\n                    fail.fire('不能为空！');\\n                    return false;\\n                }\\n            }\\n            else {\\n                success.fire();\\n                return true;\\n            }\\n        }\\n        else {\\n            if (condition &amp;&amp; condition[0]) {\\n                switch (condition[0].toLowerCase()) {\\n                    case 'notrim':\\n                        break;\\n                    case 'trimleft':\\n                        this.val(this.val().replace($.validation.constants.trimLeft, ''));\\n                        break;\\n                    case 'trimright':\\n                        this.val(this.val().replace($.validation.constants.trimRight, ''));\\n                        break;\\n                    default:\\n                        this.val(this.val().replace($.validation.constants.trim, ''));\\n                        break;\\n                }\\n            }\\n            if ($.validation.constants.request.test(this.val())) {\\n                success.fire();\\n                return true;\\n            }\\n            fail.fire('不能为空！');\\n            return false;\\n        }\\n    },\\n    'min': function (condition, success, fail) {\\n        if (this.val() === '') {\\n            success.fire();\\n            return true;\\n        }\\n        var length = +(condition &amp;&amp; condition[0]);\\n        if (length) {\\n            if (this.val().length &gt;= length) {\\n                success.fire();\\n                return true;\\n            }\\n            else {\\n                fail.fire('请至少输入' + length + '个字！');\\n                return false;\\n            }\\n        }\\n        else {\\n            success.fire();\\n            return true;\\n        }\\n    },\\n    'max': function (condition, success, fail) {\\n        var length = +(condition &amp;&amp; condition[0]);\\n        if (length) {\\n            if (this.val().length &lt;= length) {\\n                success.fire();\\n                return true;\\n            }\\n            else {\\n                fail.fire('不能超过' + length + '个字！');\\n                return false;\\n            }\\n        }\\n        else {\\n            success.fire();\\n            return true;\\n        }\\n    },\\n    'number': function (condition, success, fail) {\\n        var value = this.val();\\n        if (value === '') {\\n            success.fire();\\n            return true;\\n        }\\n        condition = condition || [];\\n        if (!$.validation.constants.number.test(value)) {\\n            fail.fire('请输入数字！');\\n            return false;\\n        }\\n        for (var i in\\n            condition) {\\n            var c = condition[i].toLowerCase();\\n            if (c === 'pure') {\\n                if (!$.validation.constants.purenumber.test(value)) {\\n                    fail.fire('请输入0~9组成的数字！');\\n                    return false;\\n                }\\n            }\\n            else if (/^\\\\d+[~-]\\\\d+$/.test(c)) {\\n                var match = c.match(/\\\\d+/g);\\n                var length = value.length;\\n                if (length &lt; +match[0]) {\\n                    fail.fire('请至少输入' + match[0] + '位数字！');\\n                    return false;\\n                }\\n                if (length &gt; +match[1]) {\\n                    fail.fire('最多只能输入' + match[1] + '位数字！');\\n                    return false;\\n                }\\n            }\\n            else if (/^\\\\d+$/.test(c)) {\\n                if (+c !== value.length) {\\n                    fail.fire('请输入' + c + '位数字！');\\n                    return false;\\n                }\\n            }\\n            success.fire();\\n            return true;\\n        }\\n    },\\n    'mobile': function (condition, success, fail) {\\n        var value = this.val();\\n        if (value === '') {\\n            success.fire();\\n            return true;\\n        }\\n        if (!$.validation.constants.mobile.test(value)) {\\n            fail.fire('手机号码输入有误，请检查后重新输入！');\\n            return false;\\n        }\\n        success.fire();\\n        return true;\\n    },\\n    'url': function (condition, success, fail) {\\n        var value = this.val();\\n        if (value === '') {\\n            success.fire();\\n            return true;\\n        }\\n        if (!$.validation.constants.url.test(value.toLowerCase())) {\\n            fail.fire('请输入正确的网址！如http://www.baidu.com');\\n            return false;\\n        }\\n        success.fire();\\n        return true;\\n    },\\n    'email': function (condition, success, fail) {\\n        var value = this.val();\\n        if (value === '') {\\n            success.fire();\\n            return true;\\n        }\\n        if (!$.validation.constants.email.test(value)) {\\n            fail.fire('电子邮箱格式错误，请检查后重新输入！');\\n            return false;\\n        }\\n        success.fire();\\n        return true;\\n    },\\n    'telephone': function (condition, success, fail) {\\n        var value = this.val();\\n        if (value === '') {\\n            success.fire();\\n            return true;\\n        }\\n        if (!$.validation.constants.telephone.test(value)) {\\n            fail.fire('电话号码输入有误，请检查后重新输入！！');\\n            return false;\\n        }\\n        success.fire();\\n        return true;\\n    },\\n    'shenfenzheng': function (condition, success, fail) {\\n        var value = this.val();\\n        if (value === '') {\\n            success.fire();\\n            return true;\\n        }\\n        value = value.toLowerCase();\\n        if ($.validation.constants.shenfenzheng.test(value)) {\\n            var numbers = value.toLowerCase().split('');\\n            // 验证地区\\n            var aCity = {\\n                11: '北京',\\n                12: '天津',\\n                13: '河北',\\n                14: '山西',\\n                15: '内蒙古',\\n                21: '辽宁',\\n                22: '吉林',\\n                23: '黑龙江',\\n                31: '上海',\\n                32: '江苏',\\n                33: '浙江',\\n                34: '安徽',\\n                35: '福建',\\n                36: '江西',\\n                37: '山东',\\n                41: '河南',\\n                42: '湖北',\\n                43: '湖南',\\n                44: '广东',\\n                45: '广西',\\n                46: '海南',\\n                50: '重庆',\\n                51: '四川',\\n                52: '贵州',\\n                53: '云南',\\n                54: '西藏',\\n                61: '陕西',\\n                62: '甘肃',\\n                63: '青海',\\n                64: '宁夏',\\n                65: '新疆',\\n                71: '台湾',\\n                81: '香港',\\n                82: '澳门',\\n                91: '国外'\\n            };\\n            if (!aCity[numbers[0] + numbers[1]]) {\\n                fail.fire('身份证格式有误，请检查后重新输入！');\\n                return false;\\n            }\\n            var wi = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2];\\n            var check = ['1', '0', 'x', '9', '8', '7', '6', '5', '4', '3', '2'];\\n            var _sum = 0;\\n            for (var i = 0; i &lt; 17; i++) {\\n                _sum += +numbers[i] * +wi[i];\\n            }\\n            if (numbers[17] != check[_sum % 11]) {\\n                fail.fire('身份证格式有误，请检查后重新输入！');\\n                return false;\\n            }\\n            success.fire();\\n            return true;\\n        }\\n        else {\\n            fail.fire('请输入18位身份证！');\\n            return false;\\n        }\\n    },\\n    'taibaozheng': function (condition, success, fail) {\\n        var value = this.val();\\n        if (value === '') {\\n            success.fire();\\n            return true;\\n        }\\n        if (!$.validation.constants.taibaozheng.test(value)) {\\n            fail.fire('台胞证格式有误，请检查后重新输入！');\\n            return false;\\n        }\\n        success.fire();\\n        return true;\\n    },\\n    'zhizhao': function (condition, success, fail) {\\n        var value = this.val();\\n        if (value === '') {\\n            success.fire();\\n            return true;\\n        }\\n        if ($.validation.constants.zhizhao.test(value)) {\\n            var p = 10;\\n            var s;\\n            var a;\\n            var numbers = value.split('');\\n            for (var i = 0; i &lt; 15; i++) {\\n                a = +numbers[i];\\n                s = (p % 11) + a;\\n                p = (s % 10) * 2;\\n                if (p === 0) {\\n                    p = 20;\\n                }\\n            }\\n            if (s % 10 !== 1) {\\n                fail.fire('工商营业执照输入有误，请检查后重新输入！');\\n                return false;\\n            }\\n            success.fire();\\n            return true;\\n        }\\n        else {\\n            fail.fire('请输入15位工商营业执照！');\\n            return false;\\n        }\\n    }\\n};</pre>\\n<h2>添加验证规则</h2>\\n<p>说好的支持自定义验证规则呢？放心，不会少的，而且超简单：</p>\\n<pre class=\\\"lang:js decode:true \\\">$.validation = function (condition, process) {\\n    $.validation.strategy[condition] = process;\\n};</pre>\\n<p> 加个静态方法搞定。</p>\\n<h2>手动发起验证</h2>\\n<p>有些场景下需要手动check一下表单内容才放心吧：</p>\\n<pre class=\\\"lang:js decode:true \\\">$.fn.exec = function () {\\n    return this.each(function () {\\n        var $this = $(this);\\n        if (!$this.is(':input')) {\\n            $this = $this.find(':input');\\n        }\\n        $this.blur();\\n    });\\n};</pre>\\n<p> 原理很简单，对:input子元素触发一次blur事件。</p>\\n<h2>还有一些是我没有做的</h2>\\n<p>都不是很复杂，因为我的业务场景不关注这些，所以就懒过去了。</p>\\n<ol>\\n<li>\\n<p>没做通用的ajax验证\\n现在对于ajax的验证，可以这样做：</p>\\n<pre class=\\\"lang:js decode:true \\\">$.validation('ajax_xx',function(c, s, f) {\\n$.post('some_url',function(data){\\n    if (data.success) {\\n        s.fire();\\n    }else{\\n        f.fire('xxxxxxxx');\\n    }\\n});\\n});</pre>\\n<p> 表单提交前，除了检查有没有.has-error的元素找到填写出错项，还要检查有没有.wait元素，如果有的话都不能立刻提交。\\n如果要有一个通用的ajax验证机制，可以自行扩展<em>$.validation</em>方法</p>\\n</li>\\n<li>\\n<p>没做验证失败时表单提交阻断\\n正如上一条中说的，表单提交前，需要检查.has-error和.wait元素，可以自行扩展<em>$.fn.validation</em>方法，添加form的submit事件绑定。</p>\\n</li>\\n<li>\\n<p>没有为handle验证状态的dom操作提供接口\\n不想做，bootstrap挺好的。</p>\\n</li>\\n<li>\\n<p>没有测试用例\\n不打算给这些代码添加逻辑了，不想写测试用例。</p>\\n</li>\\n</ol>\\n<h2>下载</h2>\\n<p><a href=\\\"http://www.zhouhua.info/wp-content/uploads/2015/04/validation.js\\\">validation.js</a></p>\",\"excerpt\":\"…\",\"fields\":{\"tagSlugs\":[\"/tags/javascript/\",\"/tags/jquery/\",\"/tags/策略模式/\",\"/tags/表单验证/\",\"/tags/设计模式/\"]},\"frontmatter\":{\"title\":\"干货！一步步实现自己的表单验证器\",\"tags\":[\"Javascript\",\"jquery\",\"策略模式\",\"表单验证\",\"设计模式\"],\"date\":\"2015-04-15T17:21:57.000Z\",\"description\":null}}},\"pathContext\":{\"slug\":\"/2015/validation/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/2015-validation.json\n// module id = 488\n// module chunks = 9671605651797"],"sourceRoot":""}