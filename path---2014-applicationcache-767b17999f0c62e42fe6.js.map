{"version":3,"sources":["webpack:///path---2014-applicationcache-767b17999f0c62e42fe6.js","webpack:///./.cache/json/2014-applicationcache.json"],"names":["webpackJsonp","368","module","exports","data","site","siteMetadata","title","subtitle","copyright","author","name","rss","email","github","markdownRemark","id","html","excerpt","fields","tagSlugs","frontmatter","tags","date","description","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,YAAAC,SAAA,YAAAC,UAAA,yBAAAC,QAA0FC,KAAA,KAAAC,IAAA,IAAAC,MAAA,oBAAAC,OAAA,gBAA0EC,gBAAmBC,GAAA,mHAAAC,KAAA,+sfAAm3eC,QAAA,sHAAAC,QAA6yBC,UAAA,6EAAwFC,aAAgBd,MAAA,oBAAAe,MAAA,+CAAAC,KAAA,2BAAAC,YAAA,QAA0IC,aAAgBC,KAAA","file":"path---2014-applicationcache-767b17999f0c62e42fe6.js","sourcesContent":["webpackJsonp([192098445605419],{\n\n/***/ 368:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Step Over\",\"subtitle\":\"有趣的灵魂终会相遇\",\"copyright\":\"© All rights reserved.\",\"author\":{\"name\":\"周骅\",\"rss\":\"#\",\"email\":\"zhou--hua@163.com\",\"github\":\"zhouhua-js\"}}},\"markdownRemark\":{\"id\":\"/work/playground/www.zhouhua.site/src/pages/articles/2014/applicationcache.md absPath of file >>> MarkdownRemark\",\"html\":\"<p><em>Application Cache</em> 是HTML5为web应用离线使用而增加的api，虽然都是有关存储，但与LocalStorage、 Cookie、SessionStorage有相当大的不同。Application Cache存储的是一系列的请求资源，允许浏览器在请求这些资源的时候，不必通过网络。如果设计良好的话，使用Application Cache能达到离线状态下，web应用仍能带来友好的用户体验。</p>\\n<h2>使用方法</h2>\\n<h3>过程与原理</h3>\\n<p>Application Cache的使用要做两个方面的工作，浏览器端和服务器端。在服务器端需要维护一个缓存清单<em>manifest</em>文件，这个文件里面记录了需要缓存的请求、不需要加入缓存的请求等内容。具体的manifest文件的语法及示例参见<a href=\\\"http://www.w3school.com.cn/html5/html_5_app_cache.asp\\\">http://www.w3school.com.cn/html5/html<em>5</em>app_cache.asp</a>。浏览器通过请求这个manifest文件来判断是否可以使用application cache，以及application cache是否需要更新等。浏览器对于manifest文件的新旧判断依据很简单，就是是否一样，只要有一点区别，浏览器就认为manifest文件有更新，需要重新缓存所有数据。所以我们常常通过更改manifest注释的方式来提醒浏览器要更新缓存。需要注意的是，manifest文件的文件名及路径没有特别要求，但对于它的<em>MIME-type</em>必须设置为<code>text/cache-manifest</code>。</p>\\n<p>在浏览器端的设置很容易，只需要在HTML标签上添加manifest属性即可，类似：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-html\\\"><code><span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>html</span> <span class=\\\"token attr-name\\\">manifest</span><span class=\\\"token attr-value\\\"><span class=\\\"token punctuation\\\">=</span><span class=\\\"token punctuation\\\">\\\"</span>cache.appcache<span class=\\\"token punctuation\\\">\\\"</span></span><span class=\\\"token punctuation\\\">></span></span>\\n</code></pre>\\n      </div>\\n<p>仅仅这样做就完成了Application Cache的配置，关于cache的检查、更新、读取都是浏览器自动完成。</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/static/flow-9a783a9d3ff87177906eb81af636cc84-c8ec5.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block; ; max-width: 960px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 76.23762376237623%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAACeElEQVQ4y41SPW/TUBTNP2KrBAgQQweQoKoQM0xM/AOEGJgQSycGhCrUBUGalkZtSAULqFJKW5qQpnFCnCgh366dOLEdfz4fru3muwiu9PLei98595x7bwj/Ga7rjnbXZf4a393Ru9C/wA4br0ngJFmQwJ0mnM40Dx6Gw0w0pBSkPn+hkNAsmbcz5tCJoa2Z2CpJiFckREsiWqoN25bxLfMC+foGPIhqiDjrJaFb4rzlWVWHbQX3dn/j0VcB93fLSNT6sMwmEtwzIlzDwGRoyjlw1VV0NW5MOKyDF4pewz73HMXGR885pO537KWfQOge+3eH+dtfGxcaK3P9x5JSQ4p/hR+VONLCAAe1Q2wkX0JUOJg2oBkGKbPJqgXLAxCOuc5IUGjSqu04GFhBttWMjIX1DBajRSzFG1CtoFlebQMSFxoRG7YzVa4pQm80FCNgDBcE3NzMYmnnF5ZjHGqyNmvQ/1WJ1HbYRZZJIWN+Vi+yHQNvuSbWuBLCfBcdzaBGRJAqr0A3xREpY+4I4xOOhpP+8GqiWUFGRlaqjTdIZB5A17IEclFo7OCYf00j0gnMs2CgFcP2SzCn0D+zQL5Gj3SzjT6NA6Nh9kLqpVFufaaTOW3+HOPXcEgmk+ySrCMvaRCoM3XFRE4y0B4ATcVCVugg9nMF7/YeIyfw4EUdTdVES7NQ6ekodgfokIiQc074dL+KS+9PcI0acYW6u7B+issR2sNpXI2c4k6sjOV4Hdc3C7i1XcTdWB6LWxx9P8Ht7RxuEO7hF36ssE2ZeFLIkcLMmUJLRbLVx1Gjj4O6gDj3AZ+4KN1lHNZl/1tWVP23WVFDkbB1xcAfPalmZkSAL7gAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"flow\\\"\\n        title=\\\"\\\"\\n        src=\\\"/static/flow-9a783a9d3ff87177906eb81af636cc84-c83f1.png\\\"\\n        srcset=\\\"/static/flow-9a783a9d3ff87177906eb81af636cc84-569e3.png 240w,\\n/static/flow-9a783a9d3ff87177906eb81af636cc84-93400.png 480w,\\n/static/flow-9a783a9d3ff87177906eb81af636cc84-c83f1.png 960w,\\n/static/flow-9a783a9d3ff87177906eb81af636cc84-c8ec5.png 1010w\\\"\\n        sizes=\\\"(max-width: 960px) 100vw, 960px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    \\n图1：manifest的解析过程</p>\\n<p>浏览器解析manifest的过程如上图所示。HTML5定义了Application Cache的几种事件，并允许JS捕获这些事件。事实上JS对application cache很难主动地进行操作，也没有读写接口，绝大部分情况下，application cache的使用是不必借助JS的。还有一点需要补充，以上是网络连接正常时的流程，当网络连接不正常时，浏览器请求manifest文件时连接失败，则进入离线模式，直接从application cache中加载页面，同时application cache会触发<code>error</code>事件。</p>\\n<p>需要注意的是，下载manifest清单里的内容是与页面载入同时进行的，也就是说，如果本次载入需要更新缓存，则本次页面载入时无法使用最新版本的缓存。</p>\\n<h3>可用性</h3>\\n<p>Application Cache被支持情况见下图：</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/static/pc-93d0b7cb137048bbd5d14e4e1da98a47-9d561.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block; ; max-width: 561px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 21.390374331550802%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAAsSAAALEgHS3X78AAAAoElEQVQI142LWQ7CMAwFe//z8YEEKo2TNFuXNK2zdAFc4ABYT6PnsVzNMUljKSGmvO3TEmNZX/9NZYfpcmuuNQjTP6S+gySy1sInXHdcO1DuNMoJ04GyQndMmjFg1Y2hZpJxrd0IUgvl6IcJDdKcbG3DFfUv6VqDJPmAtvdzFWYcfegH76eAKe3HEzGWsm37QT3lsiBS/60pY0yprOQxlzcmFuCP3aNa8gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"pc\\\"\\n        title=\\\"\\\"\\n        src=\\\"/static/pc-93d0b7cb137048bbd5d14e4e1da98a47-9d561.png\\\"\\n        srcset=\\\"/static/pc-93d0b7cb137048bbd5d14e4e1da98a47-9d395.png 240w,\\n/static/pc-93d0b7cb137048bbd5d14e4e1da98a47-ac675.png 480w,\\n/static/pc-93d0b7cb137048bbd5d14e4e1da98a47-9d561.png 561w\\\"\\n        sizes=\\\"(max-width: 561px) 100vw, 561px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    \\n图2：桌面浏览器的支持情况</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/static/mobile-b827e1fb994b5f60c1e9f4f602ad1b1e-8a23c.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block; ; max-width: 681px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 17.474302496328928%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAAsSAAALEgHS3X78AAAAkklEQVQI1y2O6w6DIBSDff/n25KBCip42cTJxQO4eNjQLGmar+2fFrB/FuMsBLP5uhXjvCB+D0xZmLLjkS6+Il7wj5iKSa03yrl81t14J4xwUTaSMEGYLJu+6oZH3XI5VW1PmaA8lwM9125UutBue6lFvVfrwMdonHMAECL4kN0bC8MUZqWN3XzwIWrrTvAhn/0BRXCn77RTIzIAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"mobile\\\"\\n        title=\\\"\\\"\\n        src=\\\"/static/mobile-b827e1fb994b5f60c1e9f4f602ad1b1e-8a23c.png\\\"\\n        srcset=\\\"/static/mobile-b827e1fb994b5f60c1e9f4f602ad1b1e-80efa.png 240w,\\n/static/mobile-b827e1fb994b5f60c1e9f4f602ad1b1e-db079.png 480w,\\n/static/mobile-b827e1fb994b5f60c1e9f4f602ad1b1e-8a23c.png 681w\\\"\\n        sizes=\\\"(max-width: 681px) 100vw, 681px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    \\n图3：移动浏览器的支持情况</p>\\n<p>参考：<a href=\\\"https://developer.mozilla.org/en-US/docs/HTML/Using_the_application_cache\\\">https://developer.mozilla.org/en-US/docs/HTML/Using<em>the</em>application_cache</a>。</p>\\n<p>整体上，Application Cache的受支持情况比较理想。即使对于不支持的浏览器而言，通常情况下也不会产生不一致的表现，所以兼容性问题不是应用Application Cache的拦路虎。</p>\\n<p>在测试的过程中，我对浏览器允许manifest列表长度及允许的cache空间比较感兴趣。网上传言各浏览器对这两点会有限制。但在我不完备的测试中，没有发现具体的限制。在桌面版的Chrome中，缓存1000+条请求，1G+的数据均未出错；安卓手机中也尝试缓存过1000+条请求，100M+的数据，同样正常。我觉得这样的测试很极限，实际应用不可能出现这样的场景。当缓存请求数过多，数据量太大，那么在页面载入的时候会进行漫长的下载过程，对用户体验、流量和服务器来说都不合适。反过来说呢，我推测在我们正常应用范围内，不需要对cache空间和请求数目太过担心，唯一需要担心的是考虑把什么样的数据缓存起来才最合适。</p>\\n<h2>优点</h2>\\n<p>使用Application Cache的优点主要体现在网络性能的提升上。把一些http的请求转为从本地存储中读取，有效降低网络延迟，提升请求加载速度。这点从下面测试截图中可以看出。同时，cache的使用减少了用户网络请求的次数，从而节约了用户流量。并且能够在一定程度上降低web应用对网络的依赖性。</p>\\n<p>除此之外，我觉得Application Cache的使用足够简单，向开发人员屏蔽了实现细节，只需要很小的工作量就可以使用。不仅如此，在成熟项目中使用此功能，对原有逻辑几乎没有影响，即使设备不支持也不会产生副作用。  </p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/static/result-707c9581755806f95f4d99537114e779-a1510.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block; ; max-width: 633px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 116.27172195892577%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAIAAACEf/j0AAAACXBIWXMAAAsSAAALEgHS3X78AAAC5klEQVQ4y11U23aqMBT0/7+s1dbatbQKcgl3RIEkCuEmnklClR6WDzHJMLNn9mZBXFf+iBf4QZadoyjquu7x9+m73nVwh/i+HwRhHCdxFF+v18U5y+IoOqsny7Lb7dY0jagFY6yua/wFeOj7U3ryPBJGEZCAYb9t20VAiO04QeAbpuk4Dq6WZZEmqWmavue5rosdIcQ5O7uOkySxYRhd32tFi9D3gVmuVt/fG7xvHEfGWT8MOOOMlWWJhZRQVVh0XXs6nVDX/X4fhmFhm8f9z89yuVyv17iKXTCDargPRV6kaTo+HlCJKnBUVxXcQV1A9n2/8Bxnt90C/Pb2tt1u67pinDdtC54iz4uiwAKKOOdYNELAIFQ7MaMs0zBWUvY3bkA2ZVSDISSO4z/gRsCytp3JPhwOYP76+ipLKmXTUjQN3pLnFxg5jg/YSynFDnQh15dsGGZbNpg3m40OhnLWqqgBKAtpWFVVwE+y4/hlmGWYu90OzJ+fn7AHB1ArRDPe73meI3kQSsM414Z5yjDQ4qZkPuz3YAYe+vFuxjiOwcMYBXjO3DYNGhGnE7NrWcbhMJcNi2shVM050pKBc65rxqvBfLtVU80OwIahc8Zt3CgguxGSmVIUot2GHO12GIavqHxCrKOlo0InyYQo1bLh1yW/SPB1lnMcv8C2aW5Vk+BBnwIGsFCyiyJPk2QuW0ZFyDyqQNcMtzFx8BDetKpJgLlccslc3fhvVJA9i8o04bZuEsBkhynZsluKIvBD7AAJOTIq2SQEQU5ReY5rHY/v7+8arBJimhngSLXnMyqUg6jaJzNRg7H6+IBy27bBKQdDtSck4NuCRVVXVzWtoq7DADm3r6jQYRgpgIMgAKfqMBkVRgqDhQVoEZUG4wvxMiwg3jOqSk08ZUxHVeZyKP8byd+pGqbe3v/sf6dKfgx0k2CYaFkmKio1VWyUNdfenNkn0jDdYVRZqmXLmrEqi0k2n2Tj8/qs+R+i0gTj42zN1AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"result\\\"\\n        title=\\\"\\\"\\n        src=\\\"/static/result-707c9581755806f95f4d99537114e779-a1510.png\\\"\\n        srcset=\\\"/static/result-707c9581755806f95f4d99537114e779-e9b68.png 240w,\\n/static/result-707c9581755806f95f4d99537114e779-7d48d.png 480w,\\n/static/result-707c9581755806f95f4d99537114e779-a1510.png 633w\\\"\\n        sizes=\\\"(max-width: 633px) 100vw, 633px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    \\n图4：本地搭建环境测试结果</p>\\n<h3>问题点</h3>\\n<p>在测试过程中，我也发现了一些值得注意的问题：</p>\\n<ol>\\n<li>\\n<p>新版本缓存不立刻生效问题</p>\\n<p>受制于Application Cache的实现机制，当检测到Manifest新版本，并更新缓存时，页面加载过程已经开始，甚至页面加载完成时，cache更新还没有完成。于是浏览器的策略是当manifest有更新时，此次加载不会使用新版数据。不仅如此，直到下次检查manifest更新之前的所有请求的缓存均为旧版本缓存。这意味着如果页面一直不刷新，那么通过application cache请求到的都是旧版本数据。</p>\\n<p>Application Cache提供了<code>update()</code>方法来手动发起manifest版本的检测；提供了<code>swapCache()</code>方法手动启用新版数据。如果应用对数据版本新旧不敏感，则可以使用这两个方法来保持cache最新数据。</p>\\n</li>\\n<li>\\n<p>Manifest中的请求路径相对于manifest文件，而非当面加载页面</p>\\n<p>如果在<em>www.a.com/index.html</em>页面上指定了manifest地址为：<em>www.a.com/manifest/app.cache</em>，那么在manifest中定义的一条请求地址如果是a.jpg，那么它代表的URL为<em>www.a.com/mainifest/a.jpg</em>。</p>\\n</li>\\n<li>\\n<p>被缓存的不仅仅是manifest清单的内容  </p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/static/chrome-0c5aceea7325befc560b762a7d9cb7c9-8aeb9.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block; ; max-width: 508px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 19.685039370078737%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAAsSAAALEgHS3X78AAAA8klEQVQI1xXJTUvDMADG8X5yJx5UxIsbw5Mn2ToROpcJ3nbYm5ubpa9pszRp2qRdU4pvBQ92Fis8/PnBo9yMlrcTf7Dk/RlTF7E6Zw1607DBYMEeXrORLoEuta2cPBu+Y5Sfb0WeppzlWaqszWjjJiudrgz2YsVrg5ko2/Evm76b5COQFc0PzcKitoJiviFWWGJZ+eJ7tiVKF7ArIDqAt8ei+yg6Y970+im90ERL5cdqfHInjnpRqx9falFznQ3l+TA7vRdtwBXfCyiNfIgwJo4NIUSO7dmmixDBKICuh3f/SMQ+Tfaui36qw29dl2XpefgP99XCis8ui/oAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"chrome\\\"\\n        title=\\\"\\\"\\n        src=\\\"/static/chrome-0c5aceea7325befc560b762a7d9cb7c9-8aeb9.png\\\"\\n        srcset=\\\"/static/chrome-0c5aceea7325befc560b762a7d9cb7c9-7d484.png 240w,\\n/static/chrome-0c5aceea7325befc560b762a7d9cb7c9-16d6f.png 480w,\\n/static/chrome-0c5aceea7325befc560b762a7d9cb7c9-8aeb9.png 508w\\\"\\n        sizes=\\\"(max-width: 508px) 100vw, 508px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    \\n图5：浏览器cache情况</p>\\n<p>如上图所示，被缓存的数据还包含manifest本身，其类型为Manifest，以及启用application cache的页面，其类型为Master。至于application中缓存Master类型的机制我还不是十分清楚，这里无法详谈。</p>\\n</li>\\n<li>\\n<p>卸载application cache问题</p>\\n<p>Application cache的卸载略微麻烦。文档上说只要当manifest请求返回4xx即可卸载application cache，但实际操作下来发现，需要给<strong>所有</strong>类型为Master的页面指定一个不存在有manifest，才可以卸载cache，而且这个过程也不是实时的，往往有一定的延迟，可能与浏览器的实现有关。</p>\\n</li>\\n<li>\\n<p>“回滚悖论”</p>\\n<p> 这个问题很少被人提到，名字我自己取的，但在我的测试中，这个问题相当典型。目前浏览器在解析manifest的策略有这样两个：</p>\\n<ul>\\n<li>如果处理manifest清单过程中触发<code>error</code>事件，则为保证内容一致性，废弃此次所有下载的内容，使用旧版本数据；</li>\\n<li>如果下载文件失败，则触发<code>error</code>事件。</li>\\n</ul>\\n<p>假设现在manifest清单上有一个文件的访问出现异常，例如restful服务调整、图片名称变更等等，哪怕这个文件根本用不到，它也会导致整个application cache更新失败。浏览器执行这样策略的出发点是为了保证application cache中的内容保持同一版本，但似乎矫枉过正。实际应用中我们无法改变这个策略，但需要知道这里的风险，当清单中有文件无法下载，则会导致缓存永远无法更新，直到manifest文件修复。在此期间，浏览器每次都加执行manifest的解析、下载、失败、回滚这样的循环，造成服务器和网络的浪费。</p>\\n</li>\\n<li>\\n<p>“更新悖论”</p>\\n<p>其实上一个问题称之为“悖论”有点夸张，但这个问题却不一定。考虑这样一个问题，如果我们将index.html的manifest的指向从a.cache改为b.cache会发生什么。答案是如果不更新或删除a.cache的内容，缓存将不更新。原因是index.html被浏览器缓存了，每次解析的时候仍然是检查a.cache的更新情况，即使我们在更新资源的同时，记得更新b.cache，结果每次检查的结果也全是<code>noupdate</code>。</p>\\n</li>\\n<li>\\n<p>多页面多manifest与多页面单manifest</p>\\n<p>首先需要留意application cache是由manifest管理的。例如 <em>a.html</em> 的manifest为 <em>a.cache</em>，<em>b.html</em> 的manifest为 <em>b.cache</em>，两个manifest都加入了<em>common.js</em>的缓存。现在更新了 <em>common.js</em> 的内容，并修改了两个manifest的版本号，如果加载 <em>a.html</em>，则 <em>common.js</em> 会更新到application cache中，那么再加载<em>b.html</em>时，从application cache中读出的是新版本的common.js还是旧版本的呢？是旧版本的，因为每个manifest独立管理自己的application cache内容，虽然在同一个站点下，虽然请求内容完全一样，但 <em>common.js</em>却是被缓存在两处，彼此独立。</p>\\n<p> 类似的，<em>a.html</em> 和 <em>b.html</em> 的manifest都是 <em>a.cache</em>，现在更新了 <em>common.js</em> 和 <em>a.cache</em>，如果加载了 <em>a.html</em>，<em>common.js</em> 更新到了application cache中，那么此时加载 <em>b.html</em> 会加载新版本还是旧版本的 <em>common.js</em> 呢？是新版本，因为两个页面的 <em>common.js</em> 由同一个manifest管理。</p>\\n</li>\\n<li>\\n<p>受制于HTTP报头的<code>Cache-control</code>字段</p>\\n<p>若此字段设置为<code>no-cache</code>，则不通过application cache获取数据。但检查manifest的流程并没有变，依然会更新最新的manifest，并下载manifest内规定的文件。\\n所以通过ajax请求数据，且希望使用到application cache时，注意配置（如有必要）：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code>$<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">ajaxSetup</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">{</span>\\n    cache<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token boolean\\\">true</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre>\\n      </div>\\n</li>\\n<li>\\n<p>Application cache更新进度的问题</p>\\n<p>如果需要追踪Application cache的更新进度，理论上可以通过监听application cache的<code>progress</code>事件来完成，每个文件下载时会触发<code>progress</code>事件。但由于manifest解析流程和页面加载流程同时进行，所以在处理<code>progress</code>事件时极有可能do\\nm或js库尚未加载，可能很难在页面上做呈现。不过如果手动触发<code>update()</code>方法，并监听<code>progress</code>事件，相对会可控得多。</p>\\n</li>\\n</ol>\\n<h2>总结</h2>\\n<p>我认为使用application cache从技术上和可用性上而言，实现成本比较低，开发量比较少，副作用比较小，适用性比较广。但怎么用，用多少是需要考虑的点。由于原理上，application cache是把manifest上的资源一起下载下来，所以manifest里的内容不宜过多，数据量不宜过大；由于manifest的解析通常以页面刷新为触发点，且更新的缓存不会立即被使用，所以缓存的资源应以静态资源、更新频率比较低的资源为主。另外要做好对manifest文件的管理，避免上面所提的由于清单内文件不可访问或manifest更新不及时造成的一些问题。</p>\",\"excerpt\":\"Application Cache  是HTML5为web应用离线使用而增加的api，虽然都是有关存储，但与LocalStorage、 Cookie、SessionStorage有相当大的不同。Application Cache…\",\"fields\":{\"tagSlugs\":[\"/tags/application-cache/\",\"/tags/html-5/\",\"/tags/manifest/\",\"/tags/离线存储/\"]},\"frontmatter\":{\"title\":\"Application Cache\",\"tags\":[\"application cache\",\"html5\",\"manifest\",\"离线存储\"],\"date\":\"2014-03-14T22:40:00.000Z\",\"description\":null}}},\"pathContext\":{\"slug\":\"/2014/applicationcache/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---2014-applicationcache-767b17999f0c62e42fe6.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Step Over\",\"subtitle\":\"有趣的灵魂终会相遇\",\"copyright\":\"© All rights reserved.\",\"author\":{\"name\":\"周骅\",\"rss\":\"#\",\"email\":\"zhou--hua@163.com\",\"github\":\"zhouhua-js\"}}},\"markdownRemark\":{\"id\":\"/work/playground/www.zhouhua.site/src/pages/articles/2014/applicationcache.md absPath of file >>> MarkdownRemark\",\"html\":\"<p><em>Application Cache</em> 是HTML5为web应用离线使用而增加的api，虽然都是有关存储，但与LocalStorage、 Cookie、SessionStorage有相当大的不同。Application Cache存储的是一系列的请求资源，允许浏览器在请求这些资源的时候，不必通过网络。如果设计良好的话，使用Application Cache能达到离线状态下，web应用仍能带来友好的用户体验。</p>\\n<h2>使用方法</h2>\\n<h3>过程与原理</h3>\\n<p>Application Cache的使用要做两个方面的工作，浏览器端和服务器端。在服务器端需要维护一个缓存清单<em>manifest</em>文件，这个文件里面记录了需要缓存的请求、不需要加入缓存的请求等内容。具体的manifest文件的语法及示例参见<a href=\\\"http://www.w3school.com.cn/html5/html_5_app_cache.asp\\\">http://www.w3school.com.cn/html5/html<em>5</em>app_cache.asp</a>。浏览器通过请求这个manifest文件来判断是否可以使用application cache，以及application cache是否需要更新等。浏览器对于manifest文件的新旧判断依据很简单，就是是否一样，只要有一点区别，浏览器就认为manifest文件有更新，需要重新缓存所有数据。所以我们常常通过更改manifest注释的方式来提醒浏览器要更新缓存。需要注意的是，manifest文件的文件名及路径没有特别要求，但对于它的<em>MIME-type</em>必须设置为<code>text/cache-manifest</code>。</p>\\n<p>在浏览器端的设置很容易，只需要在HTML标签上添加manifest属性即可，类似：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-html\\\"><code><span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>html</span> <span class=\\\"token attr-name\\\">manifest</span><span class=\\\"token attr-value\\\"><span class=\\\"token punctuation\\\">=</span><span class=\\\"token punctuation\\\">\\\"</span>cache.appcache<span class=\\\"token punctuation\\\">\\\"</span></span><span class=\\\"token punctuation\\\">></span></span>\\n</code></pre>\\n      </div>\\n<p>仅仅这样做就完成了Application Cache的配置，关于cache的检查、更新、读取都是浏览器自动完成。</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/static/flow-9a783a9d3ff87177906eb81af636cc84-c8ec5.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block; ; max-width: 960px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 76.23762376237623%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAACeElEQVQ4y41SPW/TUBTNP2KrBAgQQweQoKoQM0xM/AOEGJgQSycGhCrUBUGalkZtSAULqFJKW5qQpnFCnCgh366dOLEdfz4fru3muwiu9PLei98595x7bwj/Ga7rjnbXZf4a393Ru9C/wA4br0ngJFmQwJ0mnM40Dx6Gw0w0pBSkPn+hkNAsmbcz5tCJoa2Z2CpJiFckREsiWqoN25bxLfMC+foGPIhqiDjrJaFb4rzlWVWHbQX3dn/j0VcB93fLSNT6sMwmEtwzIlzDwGRoyjlw1VV0NW5MOKyDF4pewz73HMXGR885pO537KWfQOge+3eH+dtfGxcaK3P9x5JSQ4p/hR+VONLCAAe1Q2wkX0JUOJg2oBkGKbPJqgXLAxCOuc5IUGjSqu04GFhBttWMjIX1DBajRSzFG1CtoFlebQMSFxoRG7YzVa4pQm80FCNgDBcE3NzMYmnnF5ZjHGqyNmvQ/1WJ1HbYRZZJIWN+Vi+yHQNvuSbWuBLCfBcdzaBGRJAqr0A3xREpY+4I4xOOhpP+8GqiWUFGRlaqjTdIZB5A17IEclFo7OCYf00j0gnMs2CgFcP2SzCn0D+zQL5Gj3SzjT6NA6Nh9kLqpVFufaaTOW3+HOPXcEgmk+ySrCMvaRCoM3XFRE4y0B4ATcVCVugg9nMF7/YeIyfw4EUdTdVES7NQ6ekodgfokIiQc074dL+KS+9PcI0acYW6u7B+issR2sNpXI2c4k6sjOV4Hdc3C7i1XcTdWB6LWxx9P8Ht7RxuEO7hF36ssE2ZeFLIkcLMmUJLRbLVx1Gjj4O6gDj3AZ+4KN1lHNZl/1tWVP23WVFDkbB1xcAfPalmZkSAL7gAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"flow\\\"\\n        title=\\\"\\\"\\n        src=\\\"/static/flow-9a783a9d3ff87177906eb81af636cc84-c83f1.png\\\"\\n        srcset=\\\"/static/flow-9a783a9d3ff87177906eb81af636cc84-569e3.png 240w,\\n/static/flow-9a783a9d3ff87177906eb81af636cc84-93400.png 480w,\\n/static/flow-9a783a9d3ff87177906eb81af636cc84-c83f1.png 960w,\\n/static/flow-9a783a9d3ff87177906eb81af636cc84-c8ec5.png 1010w\\\"\\n        sizes=\\\"(max-width: 960px) 100vw, 960px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    \\n图1：manifest的解析过程</p>\\n<p>浏览器解析manifest的过程如上图所示。HTML5定义了Application Cache的几种事件，并允许JS捕获这些事件。事实上JS对application cache很难主动地进行操作，也没有读写接口，绝大部分情况下，application cache的使用是不必借助JS的。还有一点需要补充，以上是网络连接正常时的流程，当网络连接不正常时，浏览器请求manifest文件时连接失败，则进入离线模式，直接从application cache中加载页面，同时application cache会触发<code>error</code>事件。</p>\\n<p>需要注意的是，下载manifest清单里的内容是与页面载入同时进行的，也就是说，如果本次载入需要更新缓存，则本次页面载入时无法使用最新版本的缓存。</p>\\n<h3>可用性</h3>\\n<p>Application Cache被支持情况见下图：</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/static/pc-93d0b7cb137048bbd5d14e4e1da98a47-9d561.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block; ; max-width: 561px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 21.390374331550802%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAAsSAAALEgHS3X78AAAAoElEQVQI142LWQ7CMAwFe//z8YEEKo2TNFuXNK2zdAFc4ABYT6PnsVzNMUljKSGmvO3TEmNZX/9NZYfpcmuuNQjTP6S+gySy1sInXHdcO1DuNMoJ04GyQndMmjFg1Y2hZpJxrd0IUgvl6IcJDdKcbG3DFfUv6VqDJPmAtvdzFWYcfegH76eAKe3HEzGWsm37QT3lsiBS/60pY0yprOQxlzcmFuCP3aNa8gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"pc\\\"\\n        title=\\\"\\\"\\n        src=\\\"/static/pc-93d0b7cb137048bbd5d14e4e1da98a47-9d561.png\\\"\\n        srcset=\\\"/static/pc-93d0b7cb137048bbd5d14e4e1da98a47-9d395.png 240w,\\n/static/pc-93d0b7cb137048bbd5d14e4e1da98a47-ac675.png 480w,\\n/static/pc-93d0b7cb137048bbd5d14e4e1da98a47-9d561.png 561w\\\"\\n        sizes=\\\"(max-width: 561px) 100vw, 561px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    \\n图2：桌面浏览器的支持情况</p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/static/mobile-b827e1fb994b5f60c1e9f4f602ad1b1e-8a23c.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block; ; max-width: 681px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 17.474302496328928%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAAsSAAALEgHS3X78AAAAkklEQVQI1y2O6w6DIBSDff/n25KBCip42cTJxQO4eNjQLGmar+2fFrB/FuMsBLP5uhXjvCB+D0xZmLLjkS6+Il7wj5iKSa03yrl81t14J4xwUTaSMEGYLJu+6oZH3XI5VW1PmaA8lwM9125UutBue6lFvVfrwMdonHMAECL4kN0bC8MUZqWN3XzwIWrrTvAhn/0BRXCn77RTIzIAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"mobile\\\"\\n        title=\\\"\\\"\\n        src=\\\"/static/mobile-b827e1fb994b5f60c1e9f4f602ad1b1e-8a23c.png\\\"\\n        srcset=\\\"/static/mobile-b827e1fb994b5f60c1e9f4f602ad1b1e-80efa.png 240w,\\n/static/mobile-b827e1fb994b5f60c1e9f4f602ad1b1e-db079.png 480w,\\n/static/mobile-b827e1fb994b5f60c1e9f4f602ad1b1e-8a23c.png 681w\\\"\\n        sizes=\\\"(max-width: 681px) 100vw, 681px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    \\n图3：移动浏览器的支持情况</p>\\n<p>参考：<a href=\\\"https://developer.mozilla.org/en-US/docs/HTML/Using_the_application_cache\\\">https://developer.mozilla.org/en-US/docs/HTML/Using<em>the</em>application_cache</a>。</p>\\n<p>整体上，Application Cache的受支持情况比较理想。即使对于不支持的浏览器而言，通常情况下也不会产生不一致的表现，所以兼容性问题不是应用Application Cache的拦路虎。</p>\\n<p>在测试的过程中，我对浏览器允许manifest列表长度及允许的cache空间比较感兴趣。网上传言各浏览器对这两点会有限制。但在我不完备的测试中，没有发现具体的限制。在桌面版的Chrome中，缓存1000+条请求，1G+的数据均未出错；安卓手机中也尝试缓存过1000+条请求，100M+的数据，同样正常。我觉得这样的测试很极限，实际应用不可能出现这样的场景。当缓存请求数过多，数据量太大，那么在页面载入的时候会进行漫长的下载过程，对用户体验、流量和服务器来说都不合适。反过来说呢，我推测在我们正常应用范围内，不需要对cache空间和请求数目太过担心，唯一需要担心的是考虑把什么样的数据缓存起来才最合适。</p>\\n<h2>优点</h2>\\n<p>使用Application Cache的优点主要体现在网络性能的提升上。把一些http的请求转为从本地存储中读取，有效降低网络延迟，提升请求加载速度。这点从下面测试截图中可以看出。同时，cache的使用减少了用户网络请求的次数，从而节约了用户流量。并且能够在一定程度上降低web应用对网络的依赖性。</p>\\n<p>除此之外，我觉得Application Cache的使用足够简单，向开发人员屏蔽了实现细节，只需要很小的工作量就可以使用。不仅如此，在成熟项目中使用此功能，对原有逻辑几乎没有影响，即使设备不支持也不会产生副作用。  </p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/static/result-707c9581755806f95f4d99537114e779-a1510.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block; ; max-width: 633px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 116.27172195892577%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAIAAACEf/j0AAAACXBIWXMAAAsSAAALEgHS3X78AAAC5klEQVQ4y11U23aqMBT0/7+s1dbatbQKcgl3RIEkCuEmnklClR6WDzHJMLNn9mZBXFf+iBf4QZadoyjquu7x9+m73nVwh/i+HwRhHCdxFF+v18U5y+IoOqsny7Lb7dY0jagFY6yua/wFeOj7U3ryPBJGEZCAYb9t20VAiO04QeAbpuk4Dq6WZZEmqWmavue5rosdIcQ5O7uOkySxYRhd32tFi9D3gVmuVt/fG7xvHEfGWT8MOOOMlWWJhZRQVVh0XXs6nVDX/X4fhmFhm8f9z89yuVyv17iKXTCDargPRV6kaTo+HlCJKnBUVxXcQV1A9n2/8Bxnt90C/Pb2tt1u67pinDdtC54iz4uiwAKKOOdYNELAIFQ7MaMs0zBWUvY3bkA2ZVSDISSO4z/gRsCytp3JPhwOYP76+ipLKmXTUjQN3pLnFxg5jg/YSynFDnQh15dsGGZbNpg3m40OhnLWqqgBKAtpWFVVwE+y4/hlmGWYu90OzJ+fn7AHB1ArRDPe73meI3kQSsM414Z5yjDQ4qZkPuz3YAYe+vFuxjiOwcMYBXjO3DYNGhGnE7NrWcbhMJcNi2shVM050pKBc65rxqvBfLtVU80OwIahc8Zt3CgguxGSmVIUot2GHO12GIavqHxCrKOlo0InyYQo1bLh1yW/SPB1lnMcv8C2aW5Vk+BBnwIGsFCyiyJPk2QuW0ZFyDyqQNcMtzFx8BDetKpJgLlccslc3fhvVJA9i8o04bZuEsBkhynZsluKIvBD7AAJOTIq2SQEQU5ReY5rHY/v7+8arBJimhngSLXnMyqUg6jaJzNRg7H6+IBy27bBKQdDtSck4NuCRVVXVzWtoq7DADm3r6jQYRgpgIMgAKfqMBkVRgqDhQVoEZUG4wvxMiwg3jOqSk08ZUxHVeZyKP8byd+pGqbe3v/sf6dKfgx0k2CYaFkmKio1VWyUNdfenNkn0jDdYVRZqmXLmrEqi0k2n2Tj8/qs+R+i0gTj42zN1AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"result\\\"\\n        title=\\\"\\\"\\n        src=\\\"/static/result-707c9581755806f95f4d99537114e779-a1510.png\\\"\\n        srcset=\\\"/static/result-707c9581755806f95f4d99537114e779-e9b68.png 240w,\\n/static/result-707c9581755806f95f4d99537114e779-7d48d.png 480w,\\n/static/result-707c9581755806f95f4d99537114e779-a1510.png 633w\\\"\\n        sizes=\\\"(max-width: 633px) 100vw, 633px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    \\n图4：本地搭建环境测试结果</p>\\n<h3>问题点</h3>\\n<p>在测试过程中，我也发现了一些值得注意的问题：</p>\\n<ol>\\n<li>\\n<p>新版本缓存不立刻生效问题</p>\\n<p>受制于Application Cache的实现机制，当检测到Manifest新版本，并更新缓存时，页面加载过程已经开始，甚至页面加载完成时，cache更新还没有完成。于是浏览器的策略是当manifest有更新时，此次加载不会使用新版数据。不仅如此，直到下次检查manifest更新之前的所有请求的缓存均为旧版本缓存。这意味着如果页面一直不刷新，那么通过application cache请求到的都是旧版本数据。</p>\\n<p>Application Cache提供了<code>update()</code>方法来手动发起manifest版本的检测；提供了<code>swapCache()</code>方法手动启用新版数据。如果应用对数据版本新旧不敏感，则可以使用这两个方法来保持cache最新数据。</p>\\n</li>\\n<li>\\n<p>Manifest中的请求路径相对于manifest文件，而非当面加载页面</p>\\n<p>如果在<em>www.a.com/index.html</em>页面上指定了manifest地址为：<em>www.a.com/manifest/app.cache</em>，那么在manifest中定义的一条请求地址如果是a.jpg，那么它代表的URL为<em>www.a.com/mainifest/a.jpg</em>。</p>\\n</li>\\n<li>\\n<p>被缓存的不仅仅是manifest清单的内容  </p>\\n<p>\\n  <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/static/chrome-0c5aceea7325befc560b762a7d9cb7c9-8aeb9.png\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n  \\n  <span\\n    class=\\\"gatsby-resp-image-wrapper\\\"\\n    style=\\\"position: relative; display: block; ; max-width: 508px; margin-left: auto; margin-right: auto;\\\"\\n  >\\n    <span\\n      class=\\\"gatsby-resp-image-background-image\\\"\\n      style=\\\"padding-bottom: 19.685039370078737%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAAsSAAALEgHS3X78AAAA8klEQVQI1xXJTUvDMADG8X5yJx5UxIsbw5Mn2ToROpcJ3nbYm5ubpa9pszRp2qRdU4pvBQ92Fis8/PnBo9yMlrcTf7Dk/RlTF7E6Zw1607DBYMEeXrORLoEuta2cPBu+Y5Sfb0WeppzlWaqszWjjJiudrgz2YsVrg5ko2/Evm76b5COQFc0PzcKitoJiviFWWGJZ+eJ7tiVKF7ArIDqAt8ei+yg6Y970+im90ERL5cdqfHInjnpRqx9falFznQ3l+TA7vRdtwBXfCyiNfIgwJo4NIUSO7dmmixDBKICuh3f/SMQ+Tfaui36qw29dl2XpefgP99XCis8ui/oAAAAASUVORK5CYII='); background-size: cover; display: block;\\\"\\n    >\\n      <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        style=\\\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\\\"\\n        alt=\\\"chrome\\\"\\n        title=\\\"\\\"\\n        src=\\\"/static/chrome-0c5aceea7325befc560b762a7d9cb7c9-8aeb9.png\\\"\\n        srcset=\\\"/static/chrome-0c5aceea7325befc560b762a7d9cb7c9-7d484.png 240w,\\n/static/chrome-0c5aceea7325befc560b762a7d9cb7c9-16d6f.png 480w,\\n/static/chrome-0c5aceea7325befc560b762a7d9cb7c9-8aeb9.png 508w\\\"\\n        sizes=\\\"(max-width: 508px) 100vw, 508px\\\"\\n      />\\n    </span>\\n  </span>\\n  \\n  </a>\\n    \\n图5：浏览器cache情况</p>\\n<p>如上图所示，被缓存的数据还包含manifest本身，其类型为Manifest，以及启用application cache的页面，其类型为Master。至于application中缓存Master类型的机制我还不是十分清楚，这里无法详谈。</p>\\n</li>\\n<li>\\n<p>卸载application cache问题</p>\\n<p>Application cache的卸载略微麻烦。文档上说只要当manifest请求返回4xx即可卸载application cache，但实际操作下来发现，需要给<strong>所有</strong>类型为Master的页面指定一个不存在有manifest，才可以卸载cache，而且这个过程也不是实时的，往往有一定的延迟，可能与浏览器的实现有关。</p>\\n</li>\\n<li>\\n<p>“回滚悖论”</p>\\n<p> 这个问题很少被人提到，名字我自己取的，但在我的测试中，这个问题相当典型。目前浏览器在解析manifest的策略有这样两个：</p>\\n<ul>\\n<li>如果处理manifest清单过程中触发<code>error</code>事件，则为保证内容一致性，废弃此次所有下载的内容，使用旧版本数据；</li>\\n<li>如果下载文件失败，则触发<code>error</code>事件。</li>\\n</ul>\\n<p>假设现在manifest清单上有一个文件的访问出现异常，例如restful服务调整、图片名称变更等等，哪怕这个文件根本用不到，它也会导致整个application cache更新失败。浏览器执行这样策略的出发点是为了保证application cache中的内容保持同一版本，但似乎矫枉过正。实际应用中我们无法改变这个策略，但需要知道这里的风险，当清单中有文件无法下载，则会导致缓存永远无法更新，直到manifest文件修复。在此期间，浏览器每次都加执行manifest的解析、下载、失败、回滚这样的循环，造成服务器和网络的浪费。</p>\\n</li>\\n<li>\\n<p>“更新悖论”</p>\\n<p>其实上一个问题称之为“悖论”有点夸张，但这个问题却不一定。考虑这样一个问题，如果我们将index.html的manifest的指向从a.cache改为b.cache会发生什么。答案是如果不更新或删除a.cache的内容，缓存将不更新。原因是index.html被浏览器缓存了，每次解析的时候仍然是检查a.cache的更新情况，即使我们在更新资源的同时，记得更新b.cache，结果每次检查的结果也全是<code>noupdate</code>。</p>\\n</li>\\n<li>\\n<p>多页面多manifest与多页面单manifest</p>\\n<p>首先需要留意application cache是由manifest管理的。例如 <em>a.html</em> 的manifest为 <em>a.cache</em>，<em>b.html</em> 的manifest为 <em>b.cache</em>，两个manifest都加入了<em>common.js</em>的缓存。现在更新了 <em>common.js</em> 的内容，并修改了两个manifest的版本号，如果加载 <em>a.html</em>，则 <em>common.js</em> 会更新到application cache中，那么再加载<em>b.html</em>时，从application cache中读出的是新版本的common.js还是旧版本的呢？是旧版本的，因为每个manifest独立管理自己的application cache内容，虽然在同一个站点下，虽然请求内容完全一样，但 <em>common.js</em>却是被缓存在两处，彼此独立。</p>\\n<p> 类似的，<em>a.html</em> 和 <em>b.html</em> 的manifest都是 <em>a.cache</em>，现在更新了 <em>common.js</em> 和 <em>a.cache</em>，如果加载了 <em>a.html</em>，<em>common.js</em> 更新到了application cache中，那么此时加载 <em>b.html</em> 会加载新版本还是旧版本的 <em>common.js</em> 呢？是新版本，因为两个页面的 <em>common.js</em> 由同一个manifest管理。</p>\\n</li>\\n<li>\\n<p>受制于HTTP报头的<code>Cache-control</code>字段</p>\\n<p>若此字段设置为<code>no-cache</code>，则不通过application cache获取数据。但检查manifest的流程并没有变，依然会更新最新的manifest，并下载manifest内规定的文件。\\n所以通过ajax请求数据，且希望使用到application cache时，注意配置（如有必要）：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code>$<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">ajaxSetup</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">{</span>\\n    cache<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token boolean\\\">true</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre>\\n      </div>\\n</li>\\n<li>\\n<p>Application cache更新进度的问题</p>\\n<p>如果需要追踪Application cache的更新进度，理论上可以通过监听application cache的<code>progress</code>事件来完成，每个文件下载时会触发<code>progress</code>事件。但由于manifest解析流程和页面加载流程同时进行，所以在处理<code>progress</code>事件时极有可能do\\nm或js库尚未加载，可能很难在页面上做呈现。不过如果手动触发<code>update()</code>方法，并监听<code>progress</code>事件，相对会可控得多。</p>\\n</li>\\n</ol>\\n<h2>总结</h2>\\n<p>我认为使用application cache从技术上和可用性上而言，实现成本比较低，开发量比较少，副作用比较小，适用性比较广。但怎么用，用多少是需要考虑的点。由于原理上，application cache是把manifest上的资源一起下载下来，所以manifest里的内容不宜过多，数据量不宜过大；由于manifest的解析通常以页面刷新为触发点，且更新的缓存不会立即被使用，所以缓存的资源应以静态资源、更新频率比较低的资源为主。另外要做好对manifest文件的管理，避免上面所提的由于清单内文件不可访问或manifest更新不及时造成的一些问题。</p>\",\"excerpt\":\"Application Cache  是HTML5为web应用离线使用而增加的api，虽然都是有关存储，但与LocalStorage、 Cookie、SessionStorage有相当大的不同。Application Cache…\",\"fields\":{\"tagSlugs\":[\"/tags/application-cache/\",\"/tags/html-5/\",\"/tags/manifest/\",\"/tags/离线存储/\"]},\"frontmatter\":{\"title\":\"Application Cache\",\"tags\":[\"application cache\",\"html5\",\"manifest\",\"离线存储\"],\"date\":\"2014-03-14T22:40:00.000Z\",\"description\":null}}},\"pathContext\":{\"slug\":\"/2014/applicationcache/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/2014-applicationcache.json\n// module id = 368\n// module chunks = 192098445605419"],"sourceRoot":""}