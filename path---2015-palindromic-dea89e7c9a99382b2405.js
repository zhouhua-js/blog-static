webpackJsonp([0xd491f23a3162],{575:function(r,e){r.exports={data:{site:{siteMetadata:{title:"Step Over",subtitle:"有趣的灵魂终会相遇",copyright:"© All rights reserved.",author:{name:"周骅",rss:"#",email:"zhou--hua@163.com",github:"zhouhua-js"}}},markdownRemark:{id:"/work/playground/zhouhua.site/src/pages/articles/2015/palindromic.md absPath of file >>> MarkdownRemark",html:"<p>当年去携程面试时，刘大师问了一个判断回文字符串（类似于123454321）的方法，我是有备而来，刷刷就写了：</p></p>\n<pre class=\"lang:js decode:true \">function test(str) {\n    return str.split('').reverse().join('') === str;\n}</pre>\n<p> So easy。不过刘大师不喜欢这种geek范的东西，只好老老实实又写了一份循环版的……C++语言的……伪代码。还好当年不是技术面。</p>\n<p>不过今天呢，我要尝试用第三种方法，当然必须是javascript，来解决这个问题！</p>\n<pre class=\"lang:js decode:true\">function test(str) {\n    var length = str.length;\n    var regArrCenter = length % 2 === 0 ? [] : ['.'];\n    var regArrLeft = ['^'];\n    var regArrRight = ['$'];\n    for (var i = 1; i &lt;= length / 2; i++) {\n        regArrLeft.push('(.)');\n        regArrRight.unshift('\\\\' + i);\n    }\n    var regStr = regArrLeft.concat(regArrCenter, regArrRight).join('');\n    var reg = new RegExp(regStr);\n    return reg.test(str);\n}</pre>\n<p>这个方法是通过回文字符串规律，构造正则表达式完成的，这个思路还是比较偏的。怎么说呢，有规律的地方就有正则。性能没考虑，估计跟循环法差不多，慢于数组操作。</p>",excerpt:"当年去携程面试时，刘大师问了一个判断回文字符串（类似于123454321）的方法，我是有备而来，刷刷就写了：  So easy。不过刘大师不喜欢这种geek范的东西，只好老老实实又写了一份循环版的……C…",fields:{tagSlugs:["/tags/javascript/","/tags/正则/"]},frontmatter:{title:"判断回文字符串的新方法",tags:["Javascript","正则"],date:"2015-03-26T15:14:04.000Z",description:null}}},pathContext:{slug:"/2015/palindromic/"}}}});
//# sourceMappingURL=path---2015-palindromic-dea89e7c9a99382b2405.js.map