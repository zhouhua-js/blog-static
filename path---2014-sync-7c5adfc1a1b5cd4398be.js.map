{"version":3,"sources":["webpack:///path---2014-sync-7c5adfc1a1b5cd4398be.js","webpack:///./.cache/json/2014-sync.json"],"names":["webpackJsonp","564","module","exports","data","site","siteMetadata","title","subtitle","copyright","author","name","rss","email","github","markdownRemark","id","html","excerpt","fields","tagSlugs","frontmatter","tags","date","description","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,YAAAC,SAAA,YAAAC,UAAA,yBAAAC,QAA0FC,KAAA,KAAAC,IAAA,IAAAC,MAAA,oBAAAC,OAAA,gBAA0EC,gBAAmBC,GAAA,mGAAAC,KAAA,qqLAA8oKC,QAAA,wHAAAC,QAA49BC,UAAA,0FAAqGC,aAAgBd,MAAA,gBAAAe,MAAA,+CAAAC,KAAA,2BAAAC,YAAA,QAAsIC,aAAgBC,KAAA","file":"path---2014-sync-7c5adfc1a1b5cd4398be.js","sourcesContent":["webpackJsonp([179882069598393],{\n\n/***/ 564:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Step Over\",\"subtitle\":\"有趣的灵魂终会相遇\",\"copyright\":\"© All rights reserved.\",\"author\":{\"name\":\"周骅\",\"rss\":\"#\",\"email\":\"zhou--hua@163.com\",\"github\":\"zhouhua-js\"}}},\"markdownRemark\":{\"id\":\"/work/playground/zhouhua.site/src/pages/articles/2014/sync.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>Node.js中与生俱来的单线程编程、回调函数异步式风格让我们有时喜有时忧。先说单线程，很多人会费解于Node.js的单线程如何能做到高并发？这个问题不是本文重点，点到为止。澄清一点，Node.js的单线程仅仅指javascript引擎是单线程的，无论如何我们没有办法在javascript中实现多线程和阻塞（本文用到的方法同样不是通过V8引擎实现同步的）；但对于Node.js的其他方面不代表不能多线程，例如IO。如果现在Node.js遭受大量请求，而这些请求都是IO密集型的，那么此时Node.js每接受一个请求，在遇到耗时较长的IO操作时，javascript线程并不会一直在此等待，而是交出控制，在回调堆栈里添加IO操作完成后要执行的操作（当回调层级过多，访问数量过大，大量的回调链可能会爆栈）。而在这段时间内，Node.js又可以处理其他请求了。所以对于Node.js而言，虽然javascript是单线程的，每次只能处理一个请求，但javascript处理一个请求的时间往往较短（对于IO密集型应用而言），只要可以异步处理，那么在处理的过程中，此次请求都会释放控制，使Node.js能处理其他请求。这并发请求的同时，IO其实一直处于并发状态，减少处理请求的线程数，节约资源以增加IO的线程数，对于通常耗时很长的IO密集型请求来说，无疑能带来性能上的提升。</p>\\n<p>前面啰啰嗦嗦地一直在强调IO密集型，其实是在强调Node.js的强项。相应的，它的短板就是CPU密集型的请求。道理很简单，javascript不会并发，只能一个请求完成后才能处理其他请求。一个请求处理的时间越长，其他请求等待的时间越长。同一时间只会有一个请求被处理，并发性能很低。</p>\\n<p>话说到这儿，我想申明一点：Node.js不应该被阻塞；能异步处理的方法异步处理（如使用fs.readFile()，而非fs.readFileSync()方法）。</p>\\n<p>Node.js中不能阻塞，并不代表Node.js外不能阻塞。前面我们有讲到<a href=\\\"/2014/03/13/fibers/\\\">fibers</a>，现在，我们就来尝试在fibers中实现阻塞。就以处理一个http请求为例吧：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> Fiber <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">require</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'fibers'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">var</span> http <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">require</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"http\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token function\\\">Fiber</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">var</span> httpFiber <span class=\\\"token operator\\\">=</span> Fiber<span class=\\\"token punctuation\\\">.</span>current<span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">var</span> html <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">\\\"\\\"</span><span class=\\\"token punctuation\\\">;</span>\\n    http<span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">get</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"http://www.baidu.com\\\"</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span>res<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">var</span> dataFiber <span class=\\\"token operator\\\">=</span> Fiber<span class=\\\"token punctuation\\\">.</span>current<span class=\\\"token punctuation\\\">;</span>\\n        res<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">on</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"data\\\"</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span>data<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            html <span class=\\\"token operator\\\">+=</span> data<span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        res<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">on</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"end\\\"</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span>data<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            httpFiber<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">run</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    Fiber<span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">yield</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>html<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">run</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre>\\n      </div>\\n<blockquote>\\n<p><code>yield()</code>、<code>run()</code>这两个方法还不了解的同学，请自行查阅<a href=\\\"/2014/03/13/fibers/\\\">《fibers in Node.js》</a>。</p>\\n</blockquote>\\n<p>fibers的运行并不在Node.js进程中，所以在fibers内部实现阻塞对Node.js整体的性能并没有影响。而且实现起来也是相当容易，只需要在想阻塞的时候，把fiber yield掉。需要继续运行，则执行<code>run()</code>恢复fiber。在上面的例子中，我们希望当http.get请求发起时阻塞当前程序，当所有数据接收完成时，恢复程序。于是我们在调用http.get后使用<code>Fiber.yield()</code>中断此fiber。在对response的监听中，如果触发<code>end</code>事件表明数据传输完成，于是在<code>end</code>的回调函数中，调用<code>Fiber.current.run()</code>恢复fiber，这样，后续的代码就以同步的方式拿到http.get请求的数据。</p>\\n<p>上面的示例只是提供一种思路。如果对这种思路进行一些抽象封装，比如说，对有接受回调函数为参数的异步方法进行一步柯里化，在调用后中断，并劫持回调函数，以恢复程序的代码为回调函数。获取异步数据后，再程序触发预定的回调函数，这样基本能实现异步方法同步化。这段说得比较乱，基本上就是<code>fibers/future</code>的实现思路，如果有兴趣，请参考其<a href=\\\"https://github.com/laverdet/Node.js-fibers/blob/master/future.js\\\">源代码</a>。</p>\",\"excerpt\":\"Node.js中与生俱来的单线程编程、回调函数异步式风格让我们有时喜有时忧。先说单线程，很多人会费解于Node.js的单线程如何能做到高并发？这个问题不是本文重点，点到为止。澄清一点，Node.js的单线程仅仅指javascript…\",\"fields\":{\"tagSlugs\":[\"/tags/fiber/\",\"/tags/javascript/\",\"/tags/node-js/\",\"/tags/同步/\",\"/tags/并发/\",\"/tags/异步/\"]},\"frontmatter\":{\"title\":\"在Node.js中实现阻塞\",\"tags\":[\"fiber\",\"Javascript\",\"Node.js\",\"同步\",\"并发\",\"异步\"],\"date\":\"2014-03-18T22:45:57.000Z\",\"description\":null}}},\"pathContext\":{\"slug\":\"/2014/sync/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---2014-sync-7c5adfc1a1b5cd4398be.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Step Over\",\"subtitle\":\"有趣的灵魂终会相遇\",\"copyright\":\"© All rights reserved.\",\"author\":{\"name\":\"周骅\",\"rss\":\"#\",\"email\":\"zhou--hua@163.com\",\"github\":\"zhouhua-js\"}}},\"markdownRemark\":{\"id\":\"/work/playground/zhouhua.site/src/pages/articles/2014/sync.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>Node.js中与生俱来的单线程编程、回调函数异步式风格让我们有时喜有时忧。先说单线程，很多人会费解于Node.js的单线程如何能做到高并发？这个问题不是本文重点，点到为止。澄清一点，Node.js的单线程仅仅指javascript引擎是单线程的，无论如何我们没有办法在javascript中实现多线程和阻塞（本文用到的方法同样不是通过V8引擎实现同步的）；但对于Node.js的其他方面不代表不能多线程，例如IO。如果现在Node.js遭受大量请求，而这些请求都是IO密集型的，那么此时Node.js每接受一个请求，在遇到耗时较长的IO操作时，javascript线程并不会一直在此等待，而是交出控制，在回调堆栈里添加IO操作完成后要执行的操作（当回调层级过多，访问数量过大，大量的回调链可能会爆栈）。而在这段时间内，Node.js又可以处理其他请求了。所以对于Node.js而言，虽然javascript是单线程的，每次只能处理一个请求，但javascript处理一个请求的时间往往较短（对于IO密集型应用而言），只要可以异步处理，那么在处理的过程中，此次请求都会释放控制，使Node.js能处理其他请求。这并发请求的同时，IO其实一直处于并发状态，减少处理请求的线程数，节约资源以增加IO的线程数，对于通常耗时很长的IO密集型请求来说，无疑能带来性能上的提升。</p>\\n<p>前面啰啰嗦嗦地一直在强调IO密集型，其实是在强调Node.js的强项。相应的，它的短板就是CPU密集型的请求。道理很简单，javascript不会并发，只能一个请求完成后才能处理其他请求。一个请求处理的时间越长，其他请求等待的时间越长。同一时间只会有一个请求被处理，并发性能很低。</p>\\n<p>话说到这儿，我想申明一点：Node.js不应该被阻塞；能异步处理的方法异步处理（如使用fs.readFile()，而非fs.readFileSync()方法）。</p>\\n<p>Node.js中不能阻塞，并不代表Node.js外不能阻塞。前面我们有讲到<a href=\\\"/2014/03/13/fibers/\\\">fibers</a>，现在，我们就来尝试在fibers中实现阻塞。就以处理一个http请求为例吧：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> Fiber <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">require</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'fibers'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">var</span> http <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">require</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"http\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token function\\\">Fiber</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">var</span> httpFiber <span class=\\\"token operator\\\">=</span> Fiber<span class=\\\"token punctuation\\\">.</span>current<span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">var</span> html <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">\\\"\\\"</span><span class=\\\"token punctuation\\\">;</span>\\n    http<span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">get</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"http://www.baidu.com\\\"</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span>res<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">var</span> dataFiber <span class=\\\"token operator\\\">=</span> Fiber<span class=\\\"token punctuation\\\">.</span>current<span class=\\\"token punctuation\\\">;</span>\\n        res<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">on</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"data\\\"</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span>data<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            html <span class=\\\"token operator\\\">+=</span> data<span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        res<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">on</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"end\\\"</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span>data<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            httpFiber<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">run</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    Fiber<span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">yield</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>html<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">run</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre>\\n      </div>\\n<blockquote>\\n<p><code>yield()</code>、<code>run()</code>这两个方法还不了解的同学，请自行查阅<a href=\\\"/2014/03/13/fibers/\\\">《fibers in Node.js》</a>。</p>\\n</blockquote>\\n<p>fibers的运行并不在Node.js进程中，所以在fibers内部实现阻塞对Node.js整体的性能并没有影响。而且实现起来也是相当容易，只需要在想阻塞的时候，把fiber yield掉。需要继续运行，则执行<code>run()</code>恢复fiber。在上面的例子中，我们希望当http.get请求发起时阻塞当前程序，当所有数据接收完成时，恢复程序。于是我们在调用http.get后使用<code>Fiber.yield()</code>中断此fiber。在对response的监听中，如果触发<code>end</code>事件表明数据传输完成，于是在<code>end</code>的回调函数中，调用<code>Fiber.current.run()</code>恢复fiber，这样，后续的代码就以同步的方式拿到http.get请求的数据。</p>\\n<p>上面的示例只是提供一种思路。如果对这种思路进行一些抽象封装，比如说，对有接受回调函数为参数的异步方法进行一步柯里化，在调用后中断，并劫持回调函数，以恢复程序的代码为回调函数。获取异步数据后，再程序触发预定的回调函数，这样基本能实现异步方法同步化。这段说得比较乱，基本上就是<code>fibers/future</code>的实现思路，如果有兴趣，请参考其<a href=\\\"https://github.com/laverdet/Node.js-fibers/blob/master/future.js\\\">源代码</a>。</p>\",\"excerpt\":\"Node.js中与生俱来的单线程编程、回调函数异步式风格让我们有时喜有时忧。先说单线程，很多人会费解于Node.js的单线程如何能做到高并发？这个问题不是本文重点，点到为止。澄清一点，Node.js的单线程仅仅指javascript…\",\"fields\":{\"tagSlugs\":[\"/tags/fiber/\",\"/tags/javascript/\",\"/tags/node-js/\",\"/tags/同步/\",\"/tags/并发/\",\"/tags/异步/\"]},\"frontmatter\":{\"title\":\"在Node.js中实现阻塞\",\"tags\":[\"fiber\",\"Javascript\",\"Node.js\",\"同步\",\"并发\",\"异步\"],\"date\":\"2014-03-18T22:45:57.000Z\",\"description\":null}}},\"pathContext\":{\"slug\":\"/2014/sync/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/2014-sync.json\n// module id = 564\n// module chunks = 179882069598393"],"sourceRoot":""}