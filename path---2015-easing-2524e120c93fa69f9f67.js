webpackJsonp([0xd5b52c6dfc04],{475:function(n,e){n.exports={data:{site:{siteMetadata:{title:"Step Over",subtitle:"有趣的灵魂终会相遇",copyright:"© All rights reserved.",author:{name:"周骅",rss:"#",email:"zhou--hua@163.com",github:"zhouhua-js"}}},markdownRemark:{id:"/work/playground/zhouhua.site/src/pages/articles/2015/easing.md absPath of file >>> MarkdownRemark",html:'<p>问题引入：实现如下效果</p>\n<div id="container">\n<div id="first"></div>\n<div id="second"></div>\n</div>\n<p>两个方块的追逐效果，使用css3，实现起来没什么难度：</p>\n<pre class="lang:xhtml decode:true " title="HTML结构"><div id="container">\n    <div id="first"></div>\n    <div id="second"></div>\n</div></pre>\n<pre class="lang:css decode:true" title="CSS">#container{\n  position: relative;\n  width: 320px;\n  height: 320px;\n  border:1px solid #ccc;\n}\n\n@-webkit-keyframes run{\n  0% {\n    left:0;\n    top:0;\n  }\n  25% {\n    left:220px;\n    top:0;\n  }\n  50% {\n    left:220px;\n    top:220px;\n  }\n  75% {\n    left:0;\n    top:220px;\n  }\n  100% {\n    left:0;\n    top:0;\n  }\n}\n@keyframes run{\n  0% {\n    left:0;\n    top:0;\n  }\n  25% {\n    left:220px;\n    top:0;\n  }\n  50% {\n    left:220px;\n    top:220px;\n  }\n  75% {\n    left:0;\n    top:220px;\n  }\n  100% {\n    left:0;\n    top:0;\n  }\n}\n\n#first{\n  width: 100px;\n  height: 100px;\n  background: orange;\n  position: absolute;\n  -webkit-animation: run 1.6s 0.8s infinite;\n  animation: run 1.6s 0.8s infinite;\n}\n\n#second{\n  width: 100px;\n  height: 100px;\n  background: red;\n  position: absolute;\n  -webkit-animation: run 1.6s infinite;\n  animation: run 1.6s infinite;\n}</pre>\n<p>用到了css3的animate属性，不是很复杂。不过出于兼容性的考虑，我们决定使用jquery的animate方法来重新实现。</p>\n<h2>简单粗暴地多次使用$.animate</h2>\n<p>可以看到，每个方块的运动都可以分解成四步，每一步都是向一个方向运动。于是如果要用$.animate来实现，可以在一个循环里，依次调用四遍$.animate来实现：</p>\n<pre class="lang:css decode:true " title="CSS" >#container{\n  position: relative;\n  width: 320px;\n  height: 320px;\n  border:1px solid #ccc;\n}\n\n#first{\n  width: 100px;\n  height: 100px;\n  background: orange;\n  position: absolute;\n  left: 0;\n  top: 0;\n}\n\n#second{\n  width: 100px;\n  height: 100px;\n  background: red;\n  position: absolute;\n  right:0;\n  bottom:0;\n}</pre>\n<pre class="lang:js decode:true " title="javascript" >    var $first=$(\'#first\');\n    var $second=$(\'#second\');\n\n    (function firstMove(){\n        $first.animate({\n            "left":220,\n            "top": 0,\n        },400,"linear",function(){\n            $first.animate({\n                "left":220,\n                "top":220\n            },400,"linear",function(){\n                $first.animate({\n                    "left":0,\n                    "top":220\n                },400,"linear",function(){\n                    $first.animate({\n                        "left":0,\n                        "top":0\n                    },400,"linear",function(){\n                        firstMove();\n                    });\n                });\n            });\n        });\n    })();\n\n    (function secondMove(){\n        $second.animate({\n            "right":220,\n            "bottom":0\n        },400,"linear",function(){\n            $second.animate({\n                "right":220,\n                "bottom":220\n            },400,"linear",function(){\n                $second.animate({\n                    "right":0,\n                    "bottom":220\n                },400,"linear",function(){\n                    $second.animate({\n                        "right":0,\n                        "bottom":0\n                    },400,"linear",function(){\n                        secondMove();\n                    });\n                });\n            });\n        });\n    })();</pre>\n<p>这种实现简单粗暴。我写的这段代码回调链太深了，不好看。有比我更熟悉jquery的朋友不使用complete回调，而是直接$.animate().animate()这样的调用链，效果一样，代码会短很多。不过jquery代码美化优化什么的不是今天的重点。重点是什么？学习缓动函数。</p>\n<h2>缓动函数（animation easing）</h2>\n<p>缓动函数是用来描述动画效果，在jquery中，实现了两种，分别是</p>\n<pre class="inline:true decode:1 " >linear</pre>\n<p>和</p>\n<pre class="inline:true decode:1 " >swing</pre>\n<p>。</p>\n<pre class="inline:true decode:1 " >linear</pre>\n<p>效果就是没有效果，动画速度是均匀的，呈线性变化。</p>\n<pre class="inline:true decode:1 " >swing</pre>\n<p>呢，动画效果呈线慢-快-慢的变化。</p>\n<pre class="inline:true decode:1 " >swing</pre>\n<p>也是$.animate的默认动画效果。</p>\n<p>或许仅仅这么说还是难以让人理解缓动函数在干什么，那就参考一下下面来自jquery ui的例子：</p>\n<iframe style="width:100%;height:600px;" src="http://jqueryui.com/resources/demos/effect/easing.html" class="demo-frame"></iframe>\n<p>或者参考<a href="http://gsgd.co.uk/sandbox/jquery/easing/">jquery easing plugin</a>。</p>\n<p>回到jquery ui提供的各个缓动函数示意图上，对于任意一张示意图，横向表示时间，纵向表示动画变化量。当斜率越大时，表示此时动画速率越快。</p>\n<p>我们定义几个变量和常量来标记一下：动画起始变化量为<em>begin</em>，为方便计算，定义为常数0；动画结束和起始时的变化差值（总变化量）<em>change</em>，为方便计算，定义为常数1；动画持续时间<em>duration</em>；动画已进行时间<em>currentTime</em>；动画进行的进度<em>progress</em>，它等同于</p>\n<pre class="lang:js decode:1 inline:1 " >currentTime / duration</pre>\n<p>；当前变化量<em>eased</em>，jquery中这样定义：</p>\n<pre class="lang:js decode:true " title="easing定义" >eased = easingFunction(progress, currentTime, begin=0, change=1, duration);</pre>\n<p>从上面的效果中随便挑一个出来看看是如何实现的吧：</p>\n<pre class="lang:js decode:true " title="easeOutBounce的实现" >function easeOutBounce(progress, currentTime, begin, change, duration) {\n    if ((currentTime/=duration) < (1/2.75)) {\n        return change*(7.5625*currentTime*currentTime) + begin;\n    } else if (currentTime < (2/2.75)) {\n        return change*(7.5625*(currentTime-=(1.5/2.75))*currentTime + .75) + begin;\n    } else if (currentTime < (2.5/2.75)) {\n        return change*(7.5625*(currentTime-=(2.25/2.75))*currentTime + .9375) + begin;\n    } else {\n        return change*(7.5625*(currentTime-=(2.625/2.75))*currentTime + .984375) + begin;\n    }\n}</pre>\n<p>说到这儿，我想该插一点相关话题。熟悉css3的朋友会知道，css3的动画也有缓动函数，不过换了个名字，叫<em>timing function</em>。在transition中是transition-timing-function，在animate里是animate-timing-function。主要支持的动画有ease、linear、ease-in、ease-out、ease-in-out等。那如果想要的动画不在浏览器默认支持的列表中怎么办？css3也是支持自定义timing-function的，不过不同于jquery的easing function，timing function并不是描述特定时间下的动画量，而是直接描述上面我们看到的曲线图。timing function允许使用三次贝塞尔曲线方程描述动画曲线。三次贝塞尔方程接受4个点的参数：</p>\n<pre class="lang:js decode:true " title="三次贝塞尔方程" >cubic-bezier(P0, P1, P2, P3)</pre>\n<p>但在css的timing function场景下，P0点就是(0, 0)，P3点就是(1, 1)。于是变量就只剩下两个点的坐标，调用方式就变成了：</p>\n<pre class="lang:js decode:1 inline:1 " >cubic-bezier(P1x, P1y, P2x, P2y)</pre>\n<p>。在W3C的规范中，定义了这四个点的纵横坐标都需要在0和1之间，这也就意味着无论怎么变化，曲线上所有的点都必须在这个1*1的正方形内，对比上面jquery ui easing的曲线图，我们可以确认像elastic这类的效果，使用timing-function就无能为力了。</p>\n<p>想多了解一下css3的timing function，不妨到<a href="http://cubic-bezier.com/">这个网站</a>上自己动手试验一下。</p>\n<h2>编写easing function</h2>\n<p>说了半天的timing function，终于又回到easing function上来了。自己动手写easing function，那自由度，无边无际。从上面的介绍中，我们往往会有这样一个错觉，progress=0时，eased=0；progress=1时，eased=1。timing function中，因为P0和P3是定死的，所以这条一定成立，但在easing function中，其实并没有这个限制。</p>\n<p>什么意思？以我们开篇的动画为例，我们看一个方块从左上角运动一圈的轨迹。先说水平方向上，progress&#x3C;0.25时，left属性从0px变成220px；0.25&#x3C;=progress&#x3C;0.5时，left保持220px；0.5&#x3C;=progress&#x3C;0.75时，left属性从220px变成0px；0.75&#x3C;=progress&#x3C;1时，left保持0px。再看竖直方向上，progress&#x3C;0.25时，top保持0px；0.25&#x3C;=progress&#x3C;0.5时，top从0px变成220px；0.5&#x3C;=progress&#x3C;0.75时，top保持220px；0.75&#x3C;=progress&#x3C;1时，top从220px变成0px。那么这个过程反映成easing function就是：</p>\n<pre class="lang:js decode:true " title="自定义easing函数" >function horizontal(progress) {\n    if (progress &lt; 0.25) {\n        return progress * 4;\n    }\n    else if (progress &lt; 0.5) {\n        return 1;\n    }\n    else if (progress &lt; 0.75) {\n        return (0.75 - progress) * 4;\n    }\n    return 0;\n}\nfunction vertical(progress) {\n    if (progress &lt; 0.25) {\n        return 0;\n    }\n    else if (progress &lt; 0.5) {\n        return (progress - 0.25) * 4;\n    }\n    else if (progress &lt; 0.75) {\n        return 1;\n    }\n    return (1 - progress) * 4;\n}</pre>\n<p>接下来扩展jquery的easing效果库：</p>\n<pre class="lang:js decode:true " >$.extend($.easing,\n        {\n            "vertical": vertical,\n            "horizontal": horizontal\n        });</pre>\n<p>在$.animate中就可以像linear或者swing那样使用了：</p>\n<pre class="lang:js decode:true " >(function firstMove(){\n    $first.animate({\n        "left":220,\n        "top":220\n    },{\n        duration: 1600,\n        specialEasing: {\n            left: \'horizontal\',\n            top: \'vertical\'\n        },\n        complete: function() {\n            firstMove();\n        }\n    });\n})();\n(function secondMove(){\n    $second.animate({\n        "left":0,\n        "top":0\n    },{\n        duration: 1600,\n        specialEasing: {\n            left: \'horizontal\',\n            top: \'vertical\'\n        },\n        complete: function() {\n            secondMove();\n        }\n    });\n})();</pre>\n<p>我们通过specialEasing这个参数为水平方向和竖直方向指定了不同的动画效果。当然了，在这个场景中，自己写缓动函数并没有降低整体的复杂度，毕竟这个缓动函数逻辑太碎，理解起来肯定比四个animate连起来的方式复杂。但我希望能给大家带来一些思路上的启示，为以后可能遇到的问题积累经验。</p>',excerpt:"问题引入：实现如下效果 两个方块的追逐效果，使用css3，实现起来没什么难度： 用到了css3的animate属性，不是很复杂。不过出于兼容性的考虑，我们决定使用jquery的animate方法来重新实现。 简单粗暴地多次使用$.animate…",fields:{tagSlugs:["/tags/animate/","/tags/css-3/","/tags/javascript/","/tags/动画/","/tags/缓动函数/"]},frontmatter:{title:"学写jquery缓动函数",tags:["animate","css3","Javascript","动画","缓动函数"],date:"2015-03-10T16:31:50.000Z",description:null}}},pathContext:{slug:"/2015/easing/"}}}});
//# sourceMappingURL=path---2015-easing-2524e120c93fa69f9f67.js.map