{"version":3,"sources":["webpack:///path---2014-fibers-21a3ad5bbaf6bbe7970b.js","webpack:///./.cache/json/2014-fibers.json"],"names":["webpackJsonp","559","module","exports","data","site","siteMetadata","title","subtitle","copyright","author","name","rss","email","github","markdownRemark","id","html","excerpt","fields","tagSlugs","frontmatter","tags","date","description","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,YAAAC,SAAA,YAAAC,UAAA,yBAAAC,QAA0FC,KAAA,KAAAC,IAAA,IAAAC,MAAA,oBAAAC,OAAA,gBAA0EC,gBAAmBC,GAAA,qGAAAC,KAAA,6p2BAAs72BC,QAAA,gDAAAC,QAAg7BC,UAAA,+EAA0FC,aAAgBd,MAAA,oBAAAe,MAAA,2CAAAC,KAAA,2BAAAC,YAAA,QAAsIC,aAAgBC,KAAA","file":"path---2014-fibers-21a3ad5bbaf6bbe7970b.js","sourcesContent":["webpackJsonp([83930789870602],{\n\n/***/ 559:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Step Over\",\"subtitle\":\"有趣的灵魂终会相遇\",\"copyright\":\"© All rights reserved.\",\"author\":{\"name\":\"周骅\",\"rss\":\"#\",\"email\":\"zhou--hua@163.com\",\"github\":\"zhouhua-js\"}}},\"markdownRemark\":{\"id\":\"/work/playground/zhouhua.site/src/pages/articles/2014/fibers.md absPath of file >>> MarkdownRemark\",\"html\":\"<h2>fiber/纤程</h2>\\n<p>在操作系统中，除了进程和线程外，还有一种较少应用的<strong>纤程</strong>（fiber，也叫协程）。纤程常常拿来跟线程做对比，对于操作系统而言，它们都是较轻量级的运行态。通常认为纤程比线程更为轻量，开销更小。不同之处在于，纤程是由线程或纤程创建的，纤程调度完全由用户代码控制，对系统内核而言，是一种非抢占性的调度方式，纤程实现了合作式的多任务；而线程和进程则受内核调度，依照优先级，实现了抢占式的多任务。另外，系统内核是不知道纤程的具体运行状态，纤程的使用其实是比较与操作系统无关。</p>\\n<p>在Node.js中，单线程是仅针对javascript而言的，其底层其实充斥着多线程。而如果需要在javascript中实现多线程，一种常见的做法是编写C++ addon，绕过javascript的单线程机制。不过这种方法提升了开发调试的难度和成本。像其他很多脚本语言，我们也可以把纤程的概念引入到Node.js中。</p>\\n<h2>node-fibers</h2>\\n<p><code>node-fibers</code>这个库就为Node.js提供了纤程的功能。多线程方面没有测试出理想的结果，不过在异步转同步作用显著，也许在减少Node.js调用堆栈、无限递归方面也会有价值可挖。本文档主要介绍<code>node-fibers</code>库的使用方法和异步转同步等内容。</p>\\n<h3>安装</h3>\\n<p><code>node-fibers</code>是采用C语言编写，直接下载源码需要编译，通常直接npm安装即可：</p>\\n<p><code>npm install fibers</code></p>\\n<h3>fibers库的使用</h3>\\n<h4>API</h4>\\n<ul>\\n<li>\\n<p><code>Fiber(fn)</code>/<code>new Fiber(fn)</code>:</p>\\n<p>创建一个纤程，可以当成构造函数使用，也可以当成普通函数调用。如下例：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">fibo</span><span class=\\\"token punctuation\\\">(</span>n<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">return</span> n <span class=\\\"token operator\\\">&amp;</span>gt<span class=\\\"token punctuation\\\">;</span> <span class=\\\"token number\\\">1</span> <span class=\\\"token operator\\\">?</span> <span class=\\\"token function\\\">fibo</span><span class=\\\"token punctuation\\\">(</span>n <span class=\\\"token operator\\\">-</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">+</span> <span class=\\\"token function\\\">fibo</span><span class=\\\"token punctuation\\\">(</span>n <span class=\\\"token operator\\\">-</span> <span class=\\\"token number\\\">2</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">:</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token function\\\">Fiber</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">fibo</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">40</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre>\\n      </div>\\n<p>当<code>run()</code>调用的时候，纤程启动，并为<code>fn</code>分配新的堆栈，<code>fn</code>会在这个新的堆栈上运行，直到<code>fn</code>有返回值或调用<code>yield()</code>。<code>fn</code>返回后或调用<code>yield()</code>后，堆栈重置，当再次调用<code>run()</code>时，纤程会再次启动，<code>fn</code>运行于首次分配的堆栈中。</p>\\n</li>\\n<li>\\n<p><code>Fiber.current</code>:</p>\\n<p>获得当前纤程，并可对其进行操作。如果指定一个变量与其相关联，请务必确保此纤程能够释放，否则V8的垃圾回收机制会一直忽略这部分的内存，造成内存泄漏。</p>\\n</li>\\n<li>\\n<p><code>Fiber.yield(param)</code>:</p>\\n<p>前面的说明中已经提及过这个函数。<code>yield()</code>方法用于中断纤程，一定程度上类似<code>return</code>。一旦执行<code>yield()</code>，则此<code>Fiber</code>中后续代码将没有机会执行，例如：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> fiber <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">Fiber</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"Fiber Start\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    Fiber<span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">yield</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"Fiber Stop\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">run</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token comment\\\">// 输出: \\\"Fiber Start\\\"</span>\\n</code></pre>\\n      </div>\\n<p>执行后只会输出“Fiber Start”，后一个输出命令没有执行。如果向<code>yield()</code>传入参数，那么此参数作为<code>run()</code>的返回值。</p>\\n</li>\\n</ul>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> fiber <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">Fiber</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    Fiber<span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">yield</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"success\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">run</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nconsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>fiber<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// -> \\\"success\\\"</span>\\n</code></pre>\\n      </div>\\n<ul>\\n<li>\\n<p><code>Fiber.prototype.run(param)</code>:</p>\\n<p>这个方法已经很熟悉了，之前隐约有提及调用<code>run()</code>的两种时态，一是Fiber未启动时，一时Fiber被yield时。在这两种时态下，<code>run()</code>的行为并不太一样。\\n当Fiber未启动时，<code>run()</code>接受一个参数，并把它传递给<code>fn</code>，作为其参数。当Fiber处理yielding状态时，<code>run()</code>接受一个参数，并把它作为<code>yield()</code>的返回值，fn并不会从头运行，而是从中断处继续运行。关于<code>fn</code>、<code>yield</code>、<code>run</code>三者的参数、返回值等关系，可以通过下面的小例子来说明：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> Fiber <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">require</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'fibers'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">var</span> fiber <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">Fiber</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span>a<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"第一次调用run:\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"fn参数为：\\\"</span><span class=\\\"token operator\\\">+</span>a<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">var</span> b <span class=\\\"token operator\\\">=</span> Fiber<span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">yield</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"yield\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"第二次调用run:\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"fn参数为：\\\"</span><span class=\\\"token operator\\\">+</span>a<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"yield返回值为：\\\"</span><span class=\\\"token operator\\\">+</span>b<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">return</span> <span class=\\\"token string\\\">\\\"return\\\"</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token comment\\\">// 第一次运行run()</span>\\n<span class=\\\"token keyword\\\">var</span> c<span class=\\\"token operator\\\">=</span>fiber<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">run</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"One\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token comment\\\">// 第二次运行run()</span>\\n<span class=\\\"token keyword\\\">var</span> d<span class=\\\"token operator\\\">=</span>fiber<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">run</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"Two\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nconsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"调用yield，run返回：\\\"</span><span class=\\\"token operator\\\">+</span>c<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nconsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"fn运行完成，run返回：\\\"</span><span class=\\\"token operator\\\">+</span>d<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre>\\n      </div>\\n<p>输出如下：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code>/*\\n第一次调用run:\\nfn参数为：One\\n第二次调用run:\\nfn参数为：One\\nyield返回值为：Two\\n调用yield，run返回：yield\\nfn运行完成，run返回：return\\n*/</code></pre>\\n      </div>\\n<p>从上面例子中，可以很明显看出<code>yield</code>的使用方法与现在的javascript的语法相当不同。在别的语言中（C#、Python等）已经实现了<code>yield</code>关键字，作为迭代器的中断。不妨在Node.js上也实现一个迭代器，具体体会一下<code>yield</code>的使用。还是以开头的斐波那契数列为例：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> <span class=\\\"token function-variable function\\\">fiboGenerator</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">var</span> a <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">,</span> b <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">while</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>a <span class=\\\"token operator\\\">==</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            a <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">;</span>\\n            Fiber<span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">yield</span><span class=\\\"token punctuation\\\">(</span>a<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token punctuation\\\">{</span>\\n            b <span class=\\\"token operator\\\">+=</span> a<span class=\\\"token punctuation\\\">;</span>\\n            b <span class=\\\"token operator\\\">==</span> a <span class=\\\"token operator\\\">?</span> a <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">1</span> <span class=\\\"token punctuation\\\">:</span> a <span class=\\\"token operator\\\">=</span> b <span class=\\\"token operator\\\">-</span> a<span class=\\\"token punctuation\\\">;</span>\\n            Fiber<span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">yield</span><span class=\\\"token punctuation\\\">(</span>b<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token keyword\\\">var</span> f <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Fiber</span><span class=\\\"token punctuation\\\">(</span>fiboGenerator<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nf<span class=\\\"token punctuation\\\">.</span>next <span class=\\\"token operator\\\">=</span> f<span class=\\\"token punctuation\\\">.</span>run<span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">var</span> i <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">;</span> i <span class=\\\"token operator\\\">&lt;=</span> <span class=\\\"token number\\\">10</span><span class=\\\"token punctuation\\\">;</span> i<span class=\\\"token operator\\\">++</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>f<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">next</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>输出为：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code>/*\\n1\\n1\\n2\\n3\\n5\\n8\\n13\\n21\\n34\\n55\\n*/</code></pre>\\n      </div>\\n<p>有两个问题需要留意，第一，<code>yield</code>说是方法，更多地像关键字，与<code>run</code>不同，<code>yield</code>不需要依托Fiber实例，而<code>run</code>则需要。如果在Fiber内部调用<code>run</code>，则一定要使用：<code>Fiber.current.run()</code>；第二，<code>yield</code>本身为javascript的保留关键字，不确定是否会、何时会启用，所以代码在将来可能会面临变更。</p>\\n</li>\\n<li>\\n<p><code>Fiber.prototype.reset()</code>:</p>\\n<p>我们已经知道Fiber可能存在不同的时态，同时会影响<code>run</code>的行为。而<code>reset</code>方法则不管Fiber处理什么状态，都恢复到初始状态。随后再执行<code>run</code>，就会重新运行<code>fn</code>。</p>\\n</li>\\n<li>\\n<p><code>Fiber.prototype.throwInto(Exception)</code>:</p>\\n<p>本质上<code>throwInto</code>会抛出传给它的异常，并将异常信息作为<code>run</code>的返回值。如果在Fiber内不对它抛出的异常作处理，异常会继续冒泡。不管异常是否处理，它会强制<code>yield</code>，中断Fiber。</p>\\n</li>\\n</ul>\\n<h3>future库的使用</h3>\\n<p>在Node.js中直接使用Fiber并不一直是合理的，因为Fiber的API实在简单，实际使用中难免会产生重复冗长的代码，不利于维护。推荐在Node.js与Fiber之间增加一层抽象，让Fiber能够更好地工作。<code>future</code>库就提供了这样一种抽象。<code>future</code>库或者任何一层抽象也许都不是完美的，没有谁对谁错，只有适用不适用。比如，<code>future</code>库向我们提供了简单的API能够完成异步转同步的工作，然而它对封装 generator （类似上面的斐波那契数列生成器）则无能为力。</p>\\n<p><code>future</code>库不需要单独下载安装，已经包含在<code>fibers</code>库中，使用时只需要 <code>var future=require('fibers/future')</code> 即可。</p>\\n<h4>API</h4>\\n<ul>\\n<li>\\n<p><code>Function.prototype.future()</code>:</p>\\n<p>给<code>Function</code>类型添加了<code>future</code>方法，将function转化成一个“funture-function”。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> <span class=\\\"token function-variable function\\\">futureFun</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">power</span><span class=\\\"token punctuation\\\">(</span>a<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">return</span> a <span class=\\\"token operator\\\">*</span> a<span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">future</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nconsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">futureFun</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">10</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">wait</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre>\\n      </div>\\n<p>实际上<code>power</code>方法是在Fibel内执行的。不过现有版本的<code>future</code>有bug，官方没有具体的说明，如果需要使用此功能，请删除掉<code>future.js</code>的第339行和第350行。</p>\\n</li>\\n<li>\\n<p><code>new Future()</code></p>\\n<p><code>Future</code>对象的构造函数，下文详细介绍。</p>\\n</li>\\n<li>\\n<p><code>Future.wrap(fn, idx)</code></p>\\n<p><code>wrap</code>方法封装了异步转同步的操作，是<code>future</code>库中对我们最有价值的方法。<code>fn</code>表示需要转换的函数，<code>idx</code>表示<code>fn</code>接受的参数数目，认为其<code>callback</code>方法为最后一个参数（这边API的制定颇有争议，有人倾向传递<code>callback</code>应该处于的位置，好在<code>wrap</code>方法比较简单，可以比较容易修改代码）。看一个例子就能了解<code>wrap</code>的用法：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> readFileSync <span class=\\\"token operator\\\">=</span> Future<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">wrap</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">require</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"fs\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span>readFile<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token function\\\">Fiber</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">var</span> html <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">readFileSync</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"./1.txt\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">wait</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">toString</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>html<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">run</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre>\\n      </div>\\n<p>从这个例子中可以看出Fiber异步转同步确实非常有效，除了语法上多了一步<code>.wait()</code>外，其他已经<code>fs</code>提供的<code>fs.readFileSync</code>方法别无二致了。</p>\\n</li>\\n<li>\\n<p><code>Future.wait(futures)</code>:</p>\\n<p>这个方法前面已经多次看到了。顾名思义，它的作用就是等待结果。如果要等待一个future的实例的结果，直接调用<code>futureInstance.wait()</code>即可；如果需要等待一系列future实例的结果，则调用<code>Future.wait(futuresArray)</code>。需要注意的是，在第二种用法中，一个future实例在运行时出现错误，<code>wait</code>方法不会抛出错误，不过我们可以使用<code>get()</code>方法直接获取运行结果。</p>\\n</li>\\n<li>\\n<p><code>Future.prototype.get()</code>:</p>\\n<p><code>get()</code>的用法与<code>wait()</code>的第一种方式很像，所不同的是，<code>get()</code>立刻返回结果。如果数据没有准备好，<code>get()</code>会抛出错误。</p>\\n</li>\\n<li>\\n<p><code>Future.prototype.resolve(param1,param2)</code>:</p>\\n<p>上面的的<code>wrap</code>方法总给人以一种<code>future</code>其实在吞噬异步方法的回调函数，并直接返回异步结果。事实上<code>future</code>也通过<code>resolve</code>方法提供设置回调函数的解决方案。<code>resolve</code>最多接受两个参数，如果只传入一个参数，<code>future</code>认为传了一个Node.js风格的回调函数，例如如下示例：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code>futureInstance<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">resolve</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span>err<span class=\\\"token punctuation\\\">,</span> data<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>err<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">throw</span>  err<span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token punctuation\\\">{</span>\\n        console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>data<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">toString</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre>\\n      </div>\\n<p>如果传入两个参数，则表示对错误和数据分别做处理，示例如下：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code>futureInstance<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">resolve</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span>err<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">throw</span> err<span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span>data<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>data<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">toString</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre>\\n      </div>\\n<p>另外<code>future</code>并不区分<code>resolve</code>的调用时机，如果数据没有准备好，则将回调函数压入队列，由<code>resolver()</code>方法统一调度，否则直接取数据立即执行回调函数。</p>\\n</li>\\n<li>\\n<p><code>Future.prototype.isResolved()</code>:</p>\\n<p>返回布尔值，表示操作是否已经执行。</p>\\n</li>\\n<li>\\n<p><code>Future.prototype.proxy(futureInstance)</code>:</p>\\n<p><code>proxy</code>方法提供一种<code>future</code>实例的代理，本质上是对<code>resolve</code>方法的包装，其实是将一个instance的回调方法作为另一个instance的回调执行者。例如：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> target <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Future</span><span class=\\\"token punctuation\\\">;</span>\\ntarget<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">resolve</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span>err<span class=\\\"token punctuation\\\">,</span> data<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>data<span class=\\\"token punctuation\\\">)</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">var</span> <span class=\\\"token function-variable function\\\">proxyFun</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span>num<span class=\\\"token punctuation\\\">,</span> cb<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token function\\\">cb</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">null</span><span class=\\\"token punctuation\\\">,</span> num <span class=\\\"token operator\\\">*</span> num<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token function\\\">Fiber</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">var</span> proxy <span class=\\\"token operator\\\">=</span> Future<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">wrap</span><span class=\\\"token punctuation\\\">(</span>proxyFun<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">10</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    proxy<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">proxy</span><span class=\\\"token punctuation\\\">(</span>target<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">run</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// 输出100</span>\\n</code></pre>\\n      </div>\\n<p>虽然执行的是<code>proxy</code>，但是最终<code>target</code>的回调函数执行了，并且是以<code>proxy</code>的执行结果驱动<code>target</code>的回调函数。这种代理手段也许在我们的实际应用中有很大作用，我暂时还没有深入地思考过。</p>\\n</li>\\n<li>\\n<p><code>Future.prototype.return(value)</code>:</p>\\n</li>\\n<li>\\n<p><code>Future.prototype.throw(error)</code>:</p>\\n</li>\\n<li>\\n<p><code>Future.prototype.resolver()</code>:</p>\\n</li>\\n<li>\\n<p><code>Future.prototype.detach()</code>:</p>\\n<p>以上四个API呢我感觉相对于别的API，实际使用的场景或作用比较一般。<code>return</code>和<code>throw</code>都受<code>resolver</code>方法调度，这三个方法都很重要，在正常的future使用流程中都会默默工作着，只是我没有想出具体单独使用它们的场景，所以没有办法具体介绍。<code>detach</code>方法只能算<code>resolve</code>方法的简化版，亦没有介绍的必要。</p>\\n</li>\\n</ul>\\n<blockquote>\\n<p>updated 2017/02/13\\nes6的generator function特性已能完全实现fiber的所有功能。辅助es7的async/await语法，我们可以很轻松地处理异步问题。</p>\\n</blockquote>\",\"excerpt\":\"fiber/纤程 在操作系统中，除了进程和线程外，还有一种较少应用的 纤程 （fiber…\",\"fields\":{\"tagSlugs\":[\"/tags/fiber/\",\"/tags/javascript/\",\"/tags/node-js/\",\"/tags/多线程/\",\"/tags/纤程/\"]},\"frontmatter\":{\"title\":\"fibers in Node.js\",\"tags\":[\"fiber\",\"Javascript\",\"Node.js\",\"多线程\",\"纤程\"],\"date\":\"2014-03-13T22:38:40.000Z\",\"description\":null}}},\"pathContext\":{\"slug\":\"/2014/fibers/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---2014-fibers-21a3ad5bbaf6bbe7970b.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Step Over\",\"subtitle\":\"有趣的灵魂终会相遇\",\"copyright\":\"© All rights reserved.\",\"author\":{\"name\":\"周骅\",\"rss\":\"#\",\"email\":\"zhou--hua@163.com\",\"github\":\"zhouhua-js\"}}},\"markdownRemark\":{\"id\":\"/work/playground/zhouhua.site/src/pages/articles/2014/fibers.md absPath of file >>> MarkdownRemark\",\"html\":\"<h2>fiber/纤程</h2>\\n<p>在操作系统中，除了进程和线程外，还有一种较少应用的<strong>纤程</strong>（fiber，也叫协程）。纤程常常拿来跟线程做对比，对于操作系统而言，它们都是较轻量级的运行态。通常认为纤程比线程更为轻量，开销更小。不同之处在于，纤程是由线程或纤程创建的，纤程调度完全由用户代码控制，对系统内核而言，是一种非抢占性的调度方式，纤程实现了合作式的多任务；而线程和进程则受内核调度，依照优先级，实现了抢占式的多任务。另外，系统内核是不知道纤程的具体运行状态，纤程的使用其实是比较与操作系统无关。</p>\\n<p>在Node.js中，单线程是仅针对javascript而言的，其底层其实充斥着多线程。而如果需要在javascript中实现多线程，一种常见的做法是编写C++ addon，绕过javascript的单线程机制。不过这种方法提升了开发调试的难度和成本。像其他很多脚本语言，我们也可以把纤程的概念引入到Node.js中。</p>\\n<h2>node-fibers</h2>\\n<p><code>node-fibers</code>这个库就为Node.js提供了纤程的功能。多线程方面没有测试出理想的结果，不过在异步转同步作用显著，也许在减少Node.js调用堆栈、无限递归方面也会有价值可挖。本文档主要介绍<code>node-fibers</code>库的使用方法和异步转同步等内容。</p>\\n<h3>安装</h3>\\n<p><code>node-fibers</code>是采用C语言编写，直接下载源码需要编译，通常直接npm安装即可：</p>\\n<p><code>npm install fibers</code></p>\\n<h3>fibers库的使用</h3>\\n<h4>API</h4>\\n<ul>\\n<li>\\n<p><code>Fiber(fn)</code>/<code>new Fiber(fn)</code>:</p>\\n<p>创建一个纤程，可以当成构造函数使用，也可以当成普通函数调用。如下例：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">fibo</span><span class=\\\"token punctuation\\\">(</span>n<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">return</span> n <span class=\\\"token operator\\\">&amp;</span>gt<span class=\\\"token punctuation\\\">;</span> <span class=\\\"token number\\\">1</span> <span class=\\\"token operator\\\">?</span> <span class=\\\"token function\\\">fibo</span><span class=\\\"token punctuation\\\">(</span>n <span class=\\\"token operator\\\">-</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">+</span> <span class=\\\"token function\\\">fibo</span><span class=\\\"token punctuation\\\">(</span>n <span class=\\\"token operator\\\">-</span> <span class=\\\"token number\\\">2</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">:</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token function\\\">Fiber</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">fibo</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">40</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre>\\n      </div>\\n<p>当<code>run()</code>调用的时候，纤程启动，并为<code>fn</code>分配新的堆栈，<code>fn</code>会在这个新的堆栈上运行，直到<code>fn</code>有返回值或调用<code>yield()</code>。<code>fn</code>返回后或调用<code>yield()</code>后，堆栈重置，当再次调用<code>run()</code>时，纤程会再次启动，<code>fn</code>运行于首次分配的堆栈中。</p>\\n</li>\\n<li>\\n<p><code>Fiber.current</code>:</p>\\n<p>获得当前纤程，并可对其进行操作。如果指定一个变量与其相关联，请务必确保此纤程能够释放，否则V8的垃圾回收机制会一直忽略这部分的内存，造成内存泄漏。</p>\\n</li>\\n<li>\\n<p><code>Fiber.yield(param)</code>:</p>\\n<p>前面的说明中已经提及过这个函数。<code>yield()</code>方法用于中断纤程，一定程度上类似<code>return</code>。一旦执行<code>yield()</code>，则此<code>Fiber</code>中后续代码将没有机会执行，例如：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> fiber <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">Fiber</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"Fiber Start\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    Fiber<span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">yield</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"Fiber Stop\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">run</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token comment\\\">// 输出: \\\"Fiber Start\\\"</span>\\n</code></pre>\\n      </div>\\n<p>执行后只会输出“Fiber Start”，后一个输出命令没有执行。如果向<code>yield()</code>传入参数，那么此参数作为<code>run()</code>的返回值。</p>\\n</li>\\n</ul>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> fiber <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">Fiber</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    Fiber<span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">yield</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"success\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">run</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nconsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>fiber<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// -> \\\"success\\\"</span>\\n</code></pre>\\n      </div>\\n<ul>\\n<li>\\n<p><code>Fiber.prototype.run(param)</code>:</p>\\n<p>这个方法已经很熟悉了，之前隐约有提及调用<code>run()</code>的两种时态，一是Fiber未启动时，一时Fiber被yield时。在这两种时态下，<code>run()</code>的行为并不太一样。\\n当Fiber未启动时，<code>run()</code>接受一个参数，并把它传递给<code>fn</code>，作为其参数。当Fiber处理yielding状态时，<code>run()</code>接受一个参数，并把它作为<code>yield()</code>的返回值，fn并不会从头运行，而是从中断处继续运行。关于<code>fn</code>、<code>yield</code>、<code>run</code>三者的参数、返回值等关系，可以通过下面的小例子来说明：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> Fiber <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">require</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'fibers'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">var</span> fiber <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">Fiber</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span>a<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"第一次调用run:\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"fn参数为：\\\"</span><span class=\\\"token operator\\\">+</span>a<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">var</span> b <span class=\\\"token operator\\\">=</span> Fiber<span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">yield</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"yield\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"第二次调用run:\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"fn参数为：\\\"</span><span class=\\\"token operator\\\">+</span>a<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"yield返回值为：\\\"</span><span class=\\\"token operator\\\">+</span>b<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">return</span> <span class=\\\"token string\\\">\\\"return\\\"</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token comment\\\">// 第一次运行run()</span>\\n<span class=\\\"token keyword\\\">var</span> c<span class=\\\"token operator\\\">=</span>fiber<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">run</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"One\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token comment\\\">// 第二次运行run()</span>\\n<span class=\\\"token keyword\\\">var</span> d<span class=\\\"token operator\\\">=</span>fiber<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">run</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"Two\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nconsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"调用yield，run返回：\\\"</span><span class=\\\"token operator\\\">+</span>c<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nconsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"fn运行完成，run返回：\\\"</span><span class=\\\"token operator\\\">+</span>d<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre>\\n      </div>\\n<p>输出如下：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code>/*\\n第一次调用run:\\nfn参数为：One\\n第二次调用run:\\nfn参数为：One\\nyield返回值为：Two\\n调用yield，run返回：yield\\nfn运行完成，run返回：return\\n*/</code></pre>\\n      </div>\\n<p>从上面例子中，可以很明显看出<code>yield</code>的使用方法与现在的javascript的语法相当不同。在别的语言中（C#、Python等）已经实现了<code>yield</code>关键字，作为迭代器的中断。不妨在Node.js上也实现一个迭代器，具体体会一下<code>yield</code>的使用。还是以开头的斐波那契数列为例：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> <span class=\\\"token function-variable function\\\">fiboGenerator</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">var</span> a <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">,</span> b <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">while</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>a <span class=\\\"token operator\\\">==</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            a <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">;</span>\\n            Fiber<span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">yield</span><span class=\\\"token punctuation\\\">(</span>a<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token punctuation\\\">{</span>\\n            b <span class=\\\"token operator\\\">+=</span> a<span class=\\\"token punctuation\\\">;</span>\\n            b <span class=\\\"token operator\\\">==</span> a <span class=\\\"token operator\\\">?</span> a <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">1</span> <span class=\\\"token punctuation\\\">:</span> a <span class=\\\"token operator\\\">=</span> b <span class=\\\"token operator\\\">-</span> a<span class=\\\"token punctuation\\\">;</span>\\n            Fiber<span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">yield</span><span class=\\\"token punctuation\\\">(</span>b<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token keyword\\\">var</span> f <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Fiber</span><span class=\\\"token punctuation\\\">(</span>fiboGenerator<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nf<span class=\\\"token punctuation\\\">.</span>next <span class=\\\"token operator\\\">=</span> f<span class=\\\"token punctuation\\\">.</span>run<span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">var</span> i <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">;</span> i <span class=\\\"token operator\\\">&lt;=</span> <span class=\\\"token number\\\">10</span><span class=\\\"token punctuation\\\">;</span> i<span class=\\\"token operator\\\">++</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>f<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">next</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre>\\n      </div>\\n<p>输出为：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code>/*\\n1\\n1\\n2\\n3\\n5\\n8\\n13\\n21\\n34\\n55\\n*/</code></pre>\\n      </div>\\n<p>有两个问题需要留意，第一，<code>yield</code>说是方法，更多地像关键字，与<code>run</code>不同，<code>yield</code>不需要依托Fiber实例，而<code>run</code>则需要。如果在Fiber内部调用<code>run</code>，则一定要使用：<code>Fiber.current.run()</code>；第二，<code>yield</code>本身为javascript的保留关键字，不确定是否会、何时会启用，所以代码在将来可能会面临变更。</p>\\n</li>\\n<li>\\n<p><code>Fiber.prototype.reset()</code>:</p>\\n<p>我们已经知道Fiber可能存在不同的时态，同时会影响<code>run</code>的行为。而<code>reset</code>方法则不管Fiber处理什么状态，都恢复到初始状态。随后再执行<code>run</code>，就会重新运行<code>fn</code>。</p>\\n</li>\\n<li>\\n<p><code>Fiber.prototype.throwInto(Exception)</code>:</p>\\n<p>本质上<code>throwInto</code>会抛出传给它的异常，并将异常信息作为<code>run</code>的返回值。如果在Fiber内不对它抛出的异常作处理，异常会继续冒泡。不管异常是否处理，它会强制<code>yield</code>，中断Fiber。</p>\\n</li>\\n</ul>\\n<h3>future库的使用</h3>\\n<p>在Node.js中直接使用Fiber并不一直是合理的，因为Fiber的API实在简单，实际使用中难免会产生重复冗长的代码，不利于维护。推荐在Node.js与Fiber之间增加一层抽象，让Fiber能够更好地工作。<code>future</code>库就提供了这样一种抽象。<code>future</code>库或者任何一层抽象也许都不是完美的，没有谁对谁错，只有适用不适用。比如，<code>future</code>库向我们提供了简单的API能够完成异步转同步的工作，然而它对封装 generator （类似上面的斐波那契数列生成器）则无能为力。</p>\\n<p><code>future</code>库不需要单独下载安装，已经包含在<code>fibers</code>库中，使用时只需要 <code>var future=require('fibers/future')</code> 即可。</p>\\n<h4>API</h4>\\n<ul>\\n<li>\\n<p><code>Function.prototype.future()</code>:</p>\\n<p>给<code>Function</code>类型添加了<code>future</code>方法，将function转化成一个“funture-function”。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> <span class=\\\"token function-variable function\\\">futureFun</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">power</span><span class=\\\"token punctuation\\\">(</span>a<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">return</span> a <span class=\\\"token operator\\\">*</span> a<span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">future</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nconsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">futureFun</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">10</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">wait</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre>\\n      </div>\\n<p>实际上<code>power</code>方法是在Fibel内执行的。不过现有版本的<code>future</code>有bug，官方没有具体的说明，如果需要使用此功能，请删除掉<code>future.js</code>的第339行和第350行。</p>\\n</li>\\n<li>\\n<p><code>new Future()</code></p>\\n<p><code>Future</code>对象的构造函数，下文详细介绍。</p>\\n</li>\\n<li>\\n<p><code>Future.wrap(fn, idx)</code></p>\\n<p><code>wrap</code>方法封装了异步转同步的操作，是<code>future</code>库中对我们最有价值的方法。<code>fn</code>表示需要转换的函数，<code>idx</code>表示<code>fn</code>接受的参数数目，认为其<code>callback</code>方法为最后一个参数（这边API的制定颇有争议，有人倾向传递<code>callback</code>应该处于的位置，好在<code>wrap</code>方法比较简单，可以比较容易修改代码）。看一个例子就能了解<code>wrap</code>的用法：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> readFileSync <span class=\\\"token operator\\\">=</span> Future<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">wrap</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">require</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"fs\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span>readFile<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token function\\\">Fiber</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">var</span> html <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">readFileSync</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"./1.txt\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">wait</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">toString</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>html<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">run</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre>\\n      </div>\\n<p>从这个例子中可以看出Fiber异步转同步确实非常有效，除了语法上多了一步<code>.wait()</code>外，其他已经<code>fs</code>提供的<code>fs.readFileSync</code>方法别无二致了。</p>\\n</li>\\n<li>\\n<p><code>Future.wait(futures)</code>:</p>\\n<p>这个方法前面已经多次看到了。顾名思义，它的作用就是等待结果。如果要等待一个future的实例的结果，直接调用<code>futureInstance.wait()</code>即可；如果需要等待一系列future实例的结果，则调用<code>Future.wait(futuresArray)</code>。需要注意的是，在第二种用法中，一个future实例在运行时出现错误，<code>wait</code>方法不会抛出错误，不过我们可以使用<code>get()</code>方法直接获取运行结果。</p>\\n</li>\\n<li>\\n<p><code>Future.prototype.get()</code>:</p>\\n<p><code>get()</code>的用法与<code>wait()</code>的第一种方式很像，所不同的是，<code>get()</code>立刻返回结果。如果数据没有准备好，<code>get()</code>会抛出错误。</p>\\n</li>\\n<li>\\n<p><code>Future.prototype.resolve(param1,param2)</code>:</p>\\n<p>上面的的<code>wrap</code>方法总给人以一种<code>future</code>其实在吞噬异步方法的回调函数，并直接返回异步结果。事实上<code>future</code>也通过<code>resolve</code>方法提供设置回调函数的解决方案。<code>resolve</code>最多接受两个参数，如果只传入一个参数，<code>future</code>认为传了一个Node.js风格的回调函数，例如如下示例：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code>futureInstance<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">resolve</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span>err<span class=\\\"token punctuation\\\">,</span> data<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>err<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">throw</span>  err<span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token punctuation\\\">{</span>\\n        console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>data<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">toString</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre>\\n      </div>\\n<p>如果传入两个参数，则表示对错误和数据分别做处理，示例如下：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code>futureInstance<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">resolve</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span>err<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">throw</span> err<span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span>data<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>data<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">toString</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre>\\n      </div>\\n<p>另外<code>future</code>并不区分<code>resolve</code>的调用时机，如果数据没有准备好，则将回调函数压入队列，由<code>resolver()</code>方法统一调度，否则直接取数据立即执行回调函数。</p>\\n</li>\\n<li>\\n<p><code>Future.prototype.isResolved()</code>:</p>\\n<p>返回布尔值，表示操作是否已经执行。</p>\\n</li>\\n<li>\\n<p><code>Future.prototype.proxy(futureInstance)</code>:</p>\\n<p><code>proxy</code>方法提供一种<code>future</code>实例的代理，本质上是对<code>resolve</code>方法的包装，其实是将一个instance的回调方法作为另一个instance的回调执行者。例如：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">var</span> target <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Future</span><span class=\\\"token punctuation\\\">;</span>\\ntarget<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">resolve</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span>err<span class=\\\"token punctuation\\\">,</span> data<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>data<span class=\\\"token punctuation\\\">)</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">var</span> <span class=\\\"token function-variable function\\\">proxyFun</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span>num<span class=\\\"token punctuation\\\">,</span> cb<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token function\\\">cb</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">null</span><span class=\\\"token punctuation\\\">,</span> num <span class=\\\"token operator\\\">*</span> num<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token function\\\">Fiber</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">var</span> proxy <span class=\\\"token operator\\\">=</span> Future<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">wrap</span><span class=\\\"token punctuation\\\">(</span>proxyFun<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">10</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    proxy<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">proxy</span><span class=\\\"token punctuation\\\">(</span>target<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">run</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// 输出100</span>\\n</code></pre>\\n      </div>\\n<p>虽然执行的是<code>proxy</code>，但是最终<code>target</code>的回调函数执行了，并且是以<code>proxy</code>的执行结果驱动<code>target</code>的回调函数。这种代理手段也许在我们的实际应用中有很大作用，我暂时还没有深入地思考过。</p>\\n</li>\\n<li>\\n<p><code>Future.prototype.return(value)</code>:</p>\\n</li>\\n<li>\\n<p><code>Future.prototype.throw(error)</code>:</p>\\n</li>\\n<li>\\n<p><code>Future.prototype.resolver()</code>:</p>\\n</li>\\n<li>\\n<p><code>Future.prototype.detach()</code>:</p>\\n<p>以上四个API呢我感觉相对于别的API，实际使用的场景或作用比较一般。<code>return</code>和<code>throw</code>都受<code>resolver</code>方法调度，这三个方法都很重要，在正常的future使用流程中都会默默工作着，只是我没有想出具体单独使用它们的场景，所以没有办法具体介绍。<code>detach</code>方法只能算<code>resolve</code>方法的简化版，亦没有介绍的必要。</p>\\n</li>\\n</ul>\\n<blockquote>\\n<p>updated 2017/02/13\\nes6的generator function特性已能完全实现fiber的所有功能。辅助es7的async/await语法，我们可以很轻松地处理异步问题。</p>\\n</blockquote>\",\"excerpt\":\"fiber/纤程 在操作系统中，除了进程和线程外，还有一种较少应用的 纤程 （fiber…\",\"fields\":{\"tagSlugs\":[\"/tags/fiber/\",\"/tags/javascript/\",\"/tags/node-js/\",\"/tags/多线程/\",\"/tags/纤程/\"]},\"frontmatter\":{\"title\":\"fibers in Node.js\",\"tags\":[\"fiber\",\"Javascript\",\"Node.js\",\"多线程\",\"纤程\"],\"date\":\"2014-03-13T22:38:40.000Z\",\"description\":null}}},\"pathContext\":{\"slug\":\"/2014/fibers/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/2014-fibers.json\n// module id = 559\n// module chunks = 83930789870602"],"sourceRoot":""}