<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Step Over]]></title><description><![CDATA[Step Over]]></description><link>http://github.com/dylang/node-rss</link><generator>RSS for Node</generator><lastBuildDate>Fri, 09 Feb 2018 07:55:58 GMT</lastBuildDate><item><title><![CDATA[快速排序算法的优化思路总结]]></title><description><![CDATA[前两天在 知乎 上看到了一个关于快速排序算法性能的问题，我简单总结了一个优化思路，现在在自己的博客里也贴一下吧，版权都是我的。 其实里面的大部分内容在我的另一篇博客里有讲过： 深入了解javascript的sort方法 原回答： https://www.zhihu.com/question…]]></description><link>https://www.zhouhua.info//2016/optimizequicksort/</link><guid isPermaLink="false">https://www.zhouhua.info//2016/optimizequicksort/</guid><pubDate>Mon, 11 Jan 2016 10:51:24 GMT</pubDate><content:encoded>&lt;p&gt;前两天在&lt;a href=&quot;https://www.zhihu.com/question/39214230&quot;&gt;知乎&lt;/a&gt;上看到了一个关于快速排序算法性能的问题，我简单总结了一个优化思路，现在在自己的博客里也贴一下吧，版权都是我的。&lt;/p&gt;
&lt;p&gt;其实里面的大部分内容在我的另一篇博客里有讲过：&lt;a href=&quot;http://www.zhouhua.info/2015/06/18/quicksort/&quot;&gt;深入了解javascript的sort方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原回答：&lt;a href=&quot;https://www.zhihu.com/question/39214230/answer/80380554?group_id=668445013272694784&quot;&gt;https://www.zhihu.com/question/39214230/answer/80380554?group_id=668445013272694784&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;快速排序水很深啊。我不贴代码，主要讲讲优化思路和手段吧。&lt;/p&gt;&lt;/p&gt;
&lt;h2&gt;1. 合理选择pivot&lt;/h2&gt;
&lt;p&gt;你就直接选择分区的第一个或最后一个元素做pivot肯定是不合适的。对于已经排好序，或者接近排好序的情况，会进入最差情况，时间复杂度衰退到&lt;img src=&quot;https://zhihu.com/equation?tex=O%28N%5E%7B2%7D+%29&quot; alt=&quot;O(N^{2} )&quot;&gt;。
pivot选取的理想情况是：让分区中比pivot小的元素数量和比pivot大的元素数量差不多。较常用的做法是三数取中（midian of three），即从第一项、最后一项、中间一项中取中位数作为pivot。当然这并不能完全避免最差情况的发生。所以很多时候会采取更小心、更严谨的pivot选择方案（对于大数组特别重要）。比如先把大数组平均切分成左中右三个部分，每个部分用三数取中得到一个中位数，再从得到的三个中位数中找出中位数。
我在javascript v8引擎中看到了另外一种选择pivot的方式：认为超过1000项的数组是大数组，每隔200左右（不固定）选出一个元素，从这些元素中找出中位数，再加入首尾两个元素，从这个三个元素中找出中位数作为pivot。
By the way，现实环境中，你要对一个预先有一定顺序的数组做排序的需求太太太普遍了，这个优化必须要有。&lt;/p&gt;
&lt;h2&gt;2. 更快地分区&lt;/h2&gt;
&lt;p&gt;我看到题主的做法是从左向右依次与pivot比较，做交换，这样做其实效率并不高。举个简单的例子，一个数组[2, 1, 3, 1, 3, 1, 3]，选第一个元素作为pivot，如果按题主的方式，每次发现比2小的数会引起一次交换，一共三次。然而，直观来说，其实只要将第一个3和最后一个1交换就可以达到这三次交换的效果。所以更理想的分区方式是从两边向中间遍历的双向分区方式。实现的话你可以参考楼上 &lt;a href=&quot;https://www.zhihu.com/people/499f2ef7427c6eae7d20d0b7ff99d0e0&quot;&gt;@林面包&lt;/a&gt;的实现。&lt;/p&gt;
&lt;h2&gt;3. 处理重复元素的问题&lt;/h2&gt;
&lt;p&gt;假如一个数组里的元素全部一样大（或者存在大量相同元素），会怎么样？这是一个边界case，但是会令快速排序进入最差情况，因为不管怎么选pivot，都会使分区结果一边很大一边很小。那怎么解决这个问题呢？还是修改分区过程，思路跟上面说的双向分区类似，但是会更复杂，我们需要小于pivot、等于pivot、大于pivot三个分区。既然说了不贴代码，那就点到为止吧，有兴趣可以自己找别人实现看看。&lt;/p&gt;
&lt;h2&gt;4. 优化小数组效率&lt;/h2&gt;
&lt;p&gt;这一点很多人都提到了。为什么要优化小数组？因为对于规模很小的情况，快速排序的优势并不明显（可能没有优势），而递归型的算法还会带来额外的开销。于是对于这类情况可以选择非递归型的算法来替代。好，那就有两个问题：多小的数组算小数组？替换的算法是什么？
通常这个阈值设定为16（v8中设定的是10），替换的算法一般是选择排序。据说阈值的设定是要考虑更好地利用cpu缓存，这个问题我就不是很清楚了，不深入。同样，对于分区得到的小数组是要立刻进行选择排序，还是等分区全部结束了之后，再统一进行选择排序，这个问题也会存在一定的缓存命中的区别，我也不懂，不深入。&lt;/p&gt;
&lt;h2&gt;5. 监控递归过程&lt;/h2&gt;
&lt;p&gt;这里我要说的是内省排序。想想看，我们已经做了一些努力来避免快速排序算法进入最坏的情况。但事实上可能并不如我们想象地那么理想。理想情况下，快速排序算法的递归尝试会到多深呢？这个很好回答：&lt;img src=&quot;https://zhihu.com/equation?tex=log+N&quot; alt=&quot;log N&quot;&gt;。好，如果现在递归深度已经到了&lt;img src=&quot;https://zhihu.com/equation?tex=log+N&quot; alt=&quot;log N&quot;&gt;，我会觉得很正常，毕竟不太可能每次都是最好情况嘛；那如果此时递归深度达到&lt;img src=&quot;https://zhihu.com/equation?tex=2%5Ctimes+log+N&quot; alt=&quot;2\times log N&quot;&gt;呢？我想你应该慌了，比理想情况递归深了一倍还没有结束。而此时，我觉得可以认为可能已经进入最差情况了，继续使用快速排序只会更遭，可以考虑对这个分区采用其他排序算法来处理。通常我们会使用堆排序。为啥要用堆排序？因为它的平均和最差时间复杂度都是&lt;img src=&quot;https://zhihu.com/equation?tex=O%28NlogN%29&quot; alt=&quot;O(NlogN)&quot;&gt;。这就是内省排序的思想。&lt;/p&gt;
&lt;h2&gt;6. 优化递归&lt;/h2&gt;
&lt;p&gt;我想先说明一点：内省排序虽然会避免递归过深，但它的目的并不是为了优化递归。
在分区过程中，我们其实是把一个大的问题分解成两个小一点的问题分别处理。这时我们需要考虑一下，这两个小问题哪个更小。先处理更小规模的问题，再处理更大规模的问题，这样可以减小递归深度，节约栈开销。
楼上也有人提到了尾递归。对于支持尾递归的语言，自然是极好的，小规模的问题先递归，减少递归深度，大规模的问题直接通过尾递归优化掉，不进入递归栈。
然而并不是所有的语言都支持尾递归⊙︿⊙，比如python（据说）和javascript。在javascript的v8引擎中，我看到它是用一个循环变相手动实现了一个与尾递归效果一样的优化，棒棒哒。&lt;/p&gt;
&lt;h2&gt;7. 并行&lt;/h2&gt;
&lt;p&gt;既然快速排序算法是典型的分治算法，那么对于分解下来的小问题是可以在不同的线程中并行处理的。当然对于javascript还是不适用，嗯，我是做前端的。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[深入了解javascript的sort方法]]></title><description><![CDATA[在javascript中，数组对象有一个有趣的方法  sort ，它接收一个类型为函数的参数作为排序的依据。这意味着开发者只需要关注如何比较两个值的大小，而不用管“排序”这件事内部是如何实现的。不过了解一下sort…]]></description><link>https://www.zhouhua.info//2015/quicksort/</link><guid isPermaLink="false">https://www.zhouhua.info//2015/quicksort/</guid><pubDate>Thu, 18 Jun 2015 12:08:03 GMT</pubDate><content:encoded>&lt;p&gt;在javascript中，数组对象有一个有趣的方法 &lt;span id=&quot;crayon-55823efe748b3905568515&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;sort&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，它接收一个类型为函数的参数作为排序的依据。这意味着开发者只需要关注如何比较两个值的大小，而不用管“排序”这件事内部是如何实现的。不过了解一下sort的内部实现也不是一件坏事，何不深入了解一下呢？&lt;/p&gt;
&lt;p&gt;算法课上，我们会接触很多种排序算法，什么冒泡排序、选择排序、快速排序、堆排序等等。那么javascript的 &lt;span id=&quot;crayon-55823efe748c5447680578&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;sort&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;方法采用哪种排序算法呢？要搞清楚这个问题，呃，直接看&lt;a href=&quot;https://github.com/v8/v8/blob/master/src/js/array.js&quot;&gt;v8源代码&lt;/a&gt;好了。v8中对 &lt;span id=&quot;crayon-55823efe748cb471985966&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-t&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;crayon-sy&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;crayon-v&quot;&gt;sort&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的实现是采用javascript完成的，粗看下来，使用了快速排序算法，但明显比我们熟悉的快速排序要复杂。那么到底复杂在什么地方？为什么要搞这么复杂？这是我们今天要探讨的问题。&lt;/p&gt;
&lt;h2&gt;快速排序算法&lt;/h2&gt;
&lt;p&gt;快速排序算法之所以被称为快速排序算法，是因为它能达到最佳和平均时间复杂度均为O(&lt;em&gt;n·&lt;/em&gt;log&lt;em&gt;n&lt;/em&gt;)，是一种应用非常广泛的排序算法。它的原理并不复杂，先找出一个基准元素（pivot，任意元素均可），然后让所有元素跟基准元素比较，比基准元素小的，放到一个集合中，其他的放到另一个集合中；再对这两个集合执行快速排序，最终得到完全排序好的序列。&lt;/p&gt;
&lt;p&gt;所以快速排序的核心是不断把原数组做切割，切割成小数组后再对小数组进行相同的处理，这是一种典型的分治的算法设计思路。实现一个简单的快速排序算法并不困难。我们不妨试一下： &lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;function QuickSort(arr, func) {
    if (!arr || !arr.length) return [];
    if (arr.length === 1) return arr;
    var pivot = arr[0];
    var smallSet = [];
    var bigSet = [];
    for (var i = 1; i &lt; arr.length; i++) {
        if (func(arr[i], pivot) &lt; 0) {
            smallSet.push(arr[i]);
        } else {
            bigSet.push(arr[i]);
        }
    }
    return basicSort(smallSet, func).concat([pivot]).concat(basicSort(bigSet, func));
}&lt;/pre&gt;
&lt;p&gt;这是一个非常基础的实现，选取数组的第一项作为基准元素。&lt;/p&gt;
&lt;h2&gt;原地（in-place）排序&lt;/h2&gt;
&lt;p&gt;我们可以注意到，上面的算法中，我们其实是创建了一个新的数组作为计算结果，从空间使用的角度看是不经济的。javascript的快速排序算法中并没有像上面的代码那样创建一个新的数组，而是在原数组的基础上，通过交换元素位置实现排序。所以，类似于 &lt;span id=&quot;crayon-55823efe748e3451917267&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;push&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;、 &lt;span id=&quot;crayon-55823efe748e9851830112&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;pop&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;、 &lt;span id=&quot;crayon-55823efe748ee693730824&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;splice&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;这几个方法， &lt;span id=&quot;crayon-55823efe748f3319977786&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;sort&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;方法也是会修改原数组对象的！&lt;/p&gt;
&lt;p&gt;我们前面说过，快速排序的核心在于切割数组。那么如果只是在原数组上交换元素，怎么做到切割数组呢？很简单，我们并不需要真的把数组切割出来，只需要记住每个部分起止的索引号。举个例子，假设有一个数组[12, 4, 9, 2, 18, 25]，选取第一项12为基准元素，那么按照原始的快速排序算法，会把这个数组切割成两个小数组：[4, 9, 2], 12, [18, 25]。但是我们同样可以不切割，先通过比较、交换元素，将原数组修改成[4, 9, 2, 12, 18, 25]，再根据基准元素12的位置，认为0~2号元素是一组，4~5号元素是一组，为了表述方便，我这里将比基准元素小的元素组成的分区叫小数分区，另一个分区叫大数分区。这很像电脑硬盘的分区，并不是真的把硬盘分成了C盘、D盘，而是记录下一些起止位置，在逻辑上分成了若干个分区。类似的，在快速排序算法中，我们也把这个过程叫做分区（partition）。所以相应的，我也要修改一下之前的说法了，快速排序算法的核心是分区。&lt;/p&gt;
&lt;p&gt;说了这么多，还是实现一个带分区的快速排序吧： &lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true &quot;&gt;function swap(arr, from, to) {
    if (from == to) return;
    var temp = arr[from];
    arr[from] = arr[to];
    arr[to] = temp;
}

function QuickSortWithPartition(arr, func, from, to) {
    if (!arr || !arr.length) return [];
    if (arr.length === 1) return arr;
    from = from === void 0 ? 0 : from;
    to = to === void 0 ? arr.length - 1 : to;
    var pivot = arr[from];
    var smallIndex = from;
    var bigIndex = from + 1;
    for (; bigIndex &lt;= to; bigIndex++) {
        if (func(arr[bigIndex], pivot) &lt; 0) {
            smallIndex++;
            swap(arr, smallIndex, bigIndex);
        }
    }
    swap(arr, smallIndex, from);
    QuickSortWithPartition(arr, func, from, smallIndex - 1);
    QuickSortWithPartition(arr, func, smallIndex + 1, to);
    return arr;
}&lt;/pre&gt;
&lt;p&gt;看起来代码长了很多，不过并不算复杂。首先由于涉及到数组元素交换，所以先实现一个 &lt;span id=&quot;crayon-55823efe7490c399715279&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;swap&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;方法来处理元素交换。快速排序算法中，增加了两个参数， &lt;span id=&quot;crayon-55823efe74911969289365&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;from&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和 &lt;span id=&quot;crayon-55823efe74917892073239&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-st&quot;&gt;to&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，分别表示当前要处理这个数组的哪个部分， &lt;span id=&quot;crayon-55823efe7491c780726351&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;from&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;是起始索引， &lt;span id=&quot;crayon-55823efe74922683449995&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-st&quot;&gt;to&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;是终止索引；如果这两个参数缺失，则表示处理整个数组。&lt;/p&gt;
&lt;p&gt;同样的，我用最简单的方式选取基准元素，即所要处理分区的第一个元素。然后我定义了&lt;span id=&quot;crayon-55823efe74928230609130&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;smallIndex&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和 &lt;span id=&quot;crayon-55823efe7492e366068923&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;bigIndex&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;两个变量，分别表示的是左侧小数分区的终止索引和右侧大数分区的终止索引。什么意思？就是说从第一个元素（基准元素）到第 &lt;span id=&quot;crayon-55823efe74933360285586&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;smallIndex&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;个元素间的所有元素都比基准元素小，从第 &lt;span id=&quot;crayon-55823efe74939245623313&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;smallIndex&lt;/span&gt; &lt;span class=&quot;crayon-o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;crayon-cn&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;到第 &lt;span id=&quot;crayon-55823efe7493e215880882&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;bigIndex&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;个元素都比基准元素大。一开始没有比较时，很显然这两部分分区都是空的，而比较的过程很简单，直接是 &lt;span id=&quot;crayon-55823efe74944209617172&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;bigIndex&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;向右移，一直移到分区尾部。每当 &lt;span id=&quot;crayon-55823efe7494a061279075&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;bigIndex&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;增加1，我们会进行一次判断，看看这个位置上的元素是不是比基准元素大，如果大的话，不用做处理，它已经处于大数分区了；但如果比基准元素小，就需要进行一次交换。怎么交换呢？首先将 &lt;span id=&quot;crayon-55823efe74950231451095&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;smallIndex&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;增加1，意味着小数分区增加了一个元素，但此时 &lt;span id=&quot;crayon-55823efe74956441980109&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;smallIndex&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;位置的元素很明显是一个大数（这个说法其实不对，如果之前大数分区里面没有元素，此时 &lt;span id=&quot;crayon-55823efe7495c987614829&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;smallIndex&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和&lt;span id=&quot;crayon-55823efe74961858641195&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;bigIndex&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;相等，但对交换没有影响），而在 &lt;span id=&quot;crayon-55823efe74967995139514&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;bigIndex&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;位置的元素是一个小数，所以只要把这两个位置的元素交换一下就好了。&lt;/p&gt;
&lt;p&gt;最后可别忘了一开始的起始元素，它的位置并不正确，不过只要将它和 &lt;span id=&quot;crayon-55823efe7496d372340020&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;smallIndex&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;位置的元素交换位置就可以了。同时我们得到了对应的小数分区 &lt;span id=&quot;crayon-55823efe74972035589438&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-sy&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;crayon-v&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;crayon-sy&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;crayon-sy&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;crayon-sy&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;crayon-v&quot;&gt;smallIndex&lt;/span&gt; &lt;span class=&quot;crayon-o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;crayon-cn&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;crayon-sy&quot;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和大数分区&lt;span id=&quot;crayon-55823efe74978496103785&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-sy&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;crayon-v&quot;&gt;smallIndex&lt;/span&gt; &lt;span class=&quot;crayon-o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;crayon-cn&quot;&gt;1…to&lt;/span&gt;&lt;span class=&quot;crayon-sy&quot;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。再对这两个分区递归排序即可。&lt;/p&gt;
&lt;h2&gt;分区过程的优化&lt;/h2&gt;
&lt;p&gt;上面的分区过程（仅仅）还是有一定的优化空间的，因为上面的分区过程中，大数分区和小数分区都是从左向右增长，其实我们可以考虑从两侧向中间遍历，这样能有效地减少交换元素的次数。举个例子，例如我们有一个数组 &lt;span id=&quot;crayon-55823efe7497f268268777&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-sy&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;crayon-cn&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;crayon-sy&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;crayon-cn&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;crayon-sy&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;crayon-cn&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;crayon-sy&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;crayon-cn&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;crayon-sy&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;crayon-cn&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;crayon-sy&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;crayon-cn&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;crayon-sy&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;crayon-cn&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;crayon-sy&quot;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，采用上面的分区算法，一共碰到三次比基准元素小的情况，所以会发生三次交换；而如果我们换个思路，把从右往左找到小于基准和元素，和从左往右找到大于基准的元素交换，这个数组只需要交换一次就可以了，即把第一个3和最后一个1交换。&lt;/p&gt;
&lt;p&gt;我们也来尝试写一下实现： &lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;function QuickSortWithPartitionOp(arr, func, from, to) {
    if (!arr || !arr.length) return [];
    from = from === void 0 ? 0 : from;
    to = to === void 0 ? arr.length - 1 : to;
    if (from &gt;= to - 1) return arr;
    var pivot = arr[from];
    var smallEnd = from + 1;
    var bigBegin = to;
    while (smallEnd &lt; bigBegin) {
        while (func(arr[bigBegin], pivot) &gt; 0 &amp;amp;&amp;amp; smallEnd &lt; bigBegin) {
            bigBegin--;
        }
        while (func(arr[smallEnd], pivot) &lt; 0 &amp;amp;&amp;amp; smallEnd &lt; bigBegin) {
            smallEnd++;
        }
        if (smallEnd &lt; bigBegin) {
            swap(arr, smallEnd, bigBegin);
        }
    }
    swap(arr, smallEnd, from);
    QuickSortWithPartitionOp(arr, func, from, smallEnd - 1);
    QuickSortWithPartitionOp(arr, func, smallEnd + 1, to);
    return arr;
}&lt;/pre&gt;
&lt;h2&gt;分区与性能&lt;/h2&gt;
&lt;p&gt;前面我们说过，快速排序算法平均时间复杂度是O(&lt;em&gt;n·&lt;/em&gt;log&lt;em&gt;n&lt;/em&gt;)，但它的最差情况下时间复杂度会衰弱到O(&lt;em&gt;n&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;)。而性能好坏的关键就在于分区是否合理。如果每次都能平均分成相等的两个分区，那么只需要log&lt;em&gt;n&lt;/em&gt;层迭代；而如果每次分区都不合理，总有一个分区是空的，那么需要&lt;em&gt;n&lt;/em&gt;层迭代，这是性能最差的场景。&lt;/p&gt;
&lt;p&gt;那么性能最差的场景会出现吗？对于一个内容随机的数组而言，不太可能出现最差情况。但我们平时在编程时，处理的数组往往并不是内容随机的，而是很可能预先有一定顺序。设想一下，如果一个数组已经排好序了，由于之前的算法中，我们都是采用第一个元素作为基准元素，那么必然会出现每次分区都会有一个分区为空。这种情况当然需要避免。&lt;/p&gt;
&lt;p&gt;一种很容易的解决方法是不要选取固定位置的元素作为基准元素，而是随机从数组里挑出一个元素作为基准元素。这个方法很有效，极大概率地避免了最差情况。这种处理思想很简单，我就不另外写代码了。&lt;/p&gt;
&lt;p&gt;然而极大概率地避免最差情况并不等于避免最差情况，特别是对于数组很大的时候，更要求我们在选取基准元素的时候要更谨慎些。&lt;/p&gt;
&lt;h2&gt;三数取中（median-of-three）&lt;/h2&gt;
&lt;p&gt;基准元素应当精心挑选，而挑选基准元素的一种方法为三数取中，即挑选基准元素时，先把第一个元素、最后一个元素和中间一个元素挑出来，这三个元素中大小在中间的那个元素就被认为是基准元素。&lt;/p&gt;
&lt;p&gt;简单实现一下获取基准元素的方法：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;function getPivot(arr, func, from, to) {
    var middle = (from + to) &gt;&gt; 1;
    var i0 = arr[from];
    var i1 = arr[to];
    var i2 = arr[middle];
    var temp;
    if (func(i0, i1) &gt; 0) {
        temp = i0;
        i0 = i1;
        i1 = temp;
    }
    if (func(i0, i2) &gt; 0) {
        arr[middle] = i0;
        arr[from] = i2;
        arr[to] = i1;
        return i0;
    } else {
        arr[from] = i0;
        if (func(i1, i2) &gt; 0) {
            arr[middle] = i1;
            arr[to] = i2;
            return i1;
        } else {
            arr[middle] = i2;
            arr[to] = i1;
            return i2;
        }
    }
}&lt;/pre&gt;
&lt;p&gt;这个例子里我完全没管基准元素的位置，一是降低复杂度，另一个原因是下面讨论重复元素处理时，基准元素的位置没什么意义。不过我把最小的值赋给了第一个元素，最大的值赋给了第二个元素，后面处理重复元素时会有帮助。&lt;/p&gt;
&lt;p&gt;当然，仅仅是三数取中获得的基准元素，也不见得是可靠的。于是有一些其他的取中值的方法出现。有几种比较典型的手段，一种是平均间隔取一个元素，多个元素取中位数（即多取几个，增加可靠性）；一种是对三数取中进行递归运算，先把大数组平均分成三块，对每一块进行三数取中，会得到三个中值，再对这三个中值取中位数。&lt;/p&gt;
&lt;p&gt;不过查阅v8的源代码，发现v8的基准元素选取更为复杂。如果数组长度不超过1000，则进行基本的三数取中；如果数组长度超过1000，那么v8的处理是除去首尾的元素，对剩下的元素每隔200左右（200~215，并不固定）挑出一个元素。对这些元素排序，找出中间的那个，并用这个元素跟原数组首尾两个元素一起进行三数取中。这段代码我就不写了。&lt;/p&gt;
&lt;h2&gt;针对重复元素的处理&lt;/h2&gt;
&lt;p&gt;到目前为止，我们在处理元素比较的时候比较随意，并没有太多地考虑元素相等的问题。但实际上我们做了这么多性能优化，对于重复元素引起的性能问题并没有涉及到。重复元素会带来什么问题呢？设想一下，一个数组里如果所有元素都相等，基准元素不管怎么选都是一样的。那么在分区的时候，必然出现除基准元素外的其他元素都被分到一起去了，进入最差性能的case。&lt;/p&gt;
&lt;p&gt;那么对于重复元素应该怎么处理呢？从性能的角度，如果发现一个元素与基准元素相同，那么它应该被记录下来，避免后续再进行不必要的比较。所以还是得改分区的代码。&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;function QuickSortWithPartitionDump(arr, func, from, to) {
    if (!arr || !arr.length) return [];
    from = from === void 0 ? 0 : from;
    to = to === void 0 ? arr.length - 1 : to;
    if (from &gt;= to - 1) return arr;
    var pivot = getPivot(arr, func, from, to);
    var smallEnd = from;
    var bigBegin = to;
    for (var i = smallEnd + 1; i &lt; bigBegin; i++) {
        var order = func(arr[i], pivot);
        if (order &lt; 0) {
            smallEnd++;
            swap(arr, i, smallEnd);
        } else if (order &gt; 0) {
            while (bigBegin &gt; i &amp;amp;&amp;amp; order &gt; 0) {
                bigBegin--;
                order = func(arr[bigBegin], pivot);
            }
            if (bigBegin == i) break;
            swap(arr, i, bigBegin);
            if (order &lt; 0) {
                swap(arr, i, smallEnd);
                smallEnd++;
            }
        }
    }
    QuickSortWithPartitionDump(arr, func, from, smallEnd);
    QuickSortWithPartitionDump(arr, func, bigBegin, to);
    return arr;
}&lt;/pre&gt;
&lt;p&gt;简单解释一下这段代码，上文已经说过，在 &lt;span id=&quot;crayon-55823efe749bc239866524&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;getPivot&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;方法中，我将比基准小的元素放到第一位，把比基准大的元素放到最后一位。定义三个变量 &lt;span id=&quot;crayon-55823efe749c2545522118&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;smallEnd&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;、 &lt;span id=&quot;crayon-55823efe749c8631653491&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;bigBegin&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;、 &lt;span id=&quot;crayon-55823efe749cd772947600&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，从 &lt;span id=&quot;crayon-55823efe749d3693385942&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;from&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;到&lt;span id=&quot;crayon-55823efe749d8347613362&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;smallEnd&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;之间的元素都比基准元素小，从 &lt;span id=&quot;crayon-55823efe749de144619752&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;smallEnd&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;到 &lt;span id=&quot;crayon-55823efe749e3538024602&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;之间的元素都和基准元素一样大，从&lt;span id=&quot;crayon-55823efe749e9018494957&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;到 &lt;span id=&quot;crayon-55823efe749ee179249772&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;bigBegin&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;之间的元素都是还没有比较的，从 &lt;span id=&quot;crayon-55823efe749f4779126120&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;bigBegin&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;到 &lt;span id=&quot;crayon-55823efe749f9199085068&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-st&quot;&gt;to&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;之间的元素都比基准元素大。了解这个关系就好理解这段代码了。遍历从 &lt;span id=&quot;crayon-55823efe749ff492114727&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;smallEnd&lt;/span&gt; &lt;span class=&quot;crayon-o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;crayon-cn&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;到 &lt;span id=&quot;crayon-55823efe74a04163830805&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;bigBegin&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;之间的元素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果这个元素小于基准，那么 &lt;span id=&quot;crayon-55823efe74a0a801953492&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;smallEnd&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;增加1，这时 &lt;span id=&quot;crayon-55823efe74a0f199187562&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;smallEnd&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;位置的元素是等于基准元素的（或者此时 &lt;span id=&quot;crayon-55823efe74a15742404851&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;smallEnd&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;与 &lt;span id=&quot;crayon-55823efe74a1a593891892&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;相等），交换 &lt;span id=&quot;crayon-55823efe74a20930334937&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;smallEnd&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;与 &lt;span id=&quot;crayon-55823efe74a25145531379&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;处的元素就可以了。&lt;/li&gt;
&lt;li&gt;果这个元素大于基准，相对比较复杂一点。此时让 &lt;span id=&quot;crayon-55823efe74a2b644865861&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;bigBegin&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;减小1，检查大数分区前面一个元素是不是大于基准，如果大于基准，重复此步骤，不断让 &lt;span id=&quot;crayon-55823efe74a31915814877&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;bigBegin&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;减小1，直到找到不比基准大的元素（如果这个过程中，发现 &lt;span id=&quot;crayon-55823efe74a36414537354&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;bigBegin&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;与 &lt;span id=&quot;crayon-55823efe74a3c760195660&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;相等，则中止遍历，说明分区结束）。找到这个不比基准大小元素时需要区分是不是比基准小。如果比基准小，需要做两步交换，先将&lt;span id=&quot;crayon-55823efe74a42928630440&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;位置的大数和 &lt;span id=&quot;crayon-55823efe74a47652275788&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;bigBegin&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;位置的小数交换，这时跟第一种case同时， &lt;span id=&quot;crayon-55823efe74a4d045512622&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;smallEnd&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;增加1，并且将 &lt;span id=&quot;crayon-55823efe74a52713331667&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;位置的小数和 &lt;span id=&quot;crayon-55823efe74a58375764364&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;smallEnd&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;位置的元素交换。如果和基准相等，则只需要将 &lt;span id=&quot;crayon-55823efe74a5d074232941&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;位置的大数和 &lt;span id=&quot;crayon-55823efe74a63389260328&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;bigBegin&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;位置的小数交换。&lt;/li&gt;
&lt;li&gt;果这个元素与基准相等，什么也不用做。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;小数组优化&lt;/h2&gt;
&lt;p&gt;对于小数组（小于16项或10项。v8认为10项以下的是小数组。），可能使用快速排序的速度还不如平均复杂度更高的选择排序。所以对于小数组，可以使用选择排序法要提高性能，减少递归深度。&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;function insertionSort(a, func, from, to) {
    for (var i = from + 1; i &lt; to; i++) {
        var element = a[i];
        for (var j = i - 1; j &gt;= from; j--) {
            var tmp = a[j];
            if (func(tmp, element) &gt; 0) {
                a[j + 1] = tmp;
            } else {
                break;
            }
        }
        a[j + 1] = element;
    }
}&lt;/pre&gt;
&lt;h2&gt;v8引擎没有做的优化&lt;/h2&gt;
&lt;p&gt;由于快速排序的不稳定性（少数情况下性能差，前文已经详细描述过），David Musser于1997设计了内省排序法（Introsort）。这个算法在快速排序的基础上，监控递归的深度。一旦长度为&lt;em&gt;n&lt;/em&gt;的数组经过了log&lt;em&gt;n&lt;/em&gt;层递归（快速排序算法最佳情况下的递归层数）还没有结束的话，就认为这次快速排序的效率可能不理想，转而将剩余部分换用其他排序算法，通常使用堆排序算法（Heapsort，最差时间复杂度和最优时间复杂度均为O(&lt;em&gt;n·&lt;/em&gt;log&lt;em&gt;n&lt;/em&gt;)）。&lt;/p&gt;
&lt;h2&gt;v8引擎额外做的优化&lt;/h2&gt;
&lt;p&gt;快速排序递归很深，如果递归太深的话，很可以出现“爆栈”，我们应该尽可能避免这种情况。上面提到的对小数组采用选择排序算法，以及采用内省排序算法都可以减少递归深度。不过v8引擎中，做了一些不太常见的优化，每次我们分区后，v8引擎会选择元素少的分区进行递归，而将元素多的分区直接通过循环处理，无疑这样的处理大大减小了递归深度。我大致把v8这种处理的过程写一下：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true &quot;&gt;function quickSort(arr, from, to){
    while(true){
        // 排序分区过程省略
        // ...

        if (to - bigBegin &lt; smallEnd - from) {
            quickSort(a, bigBegin, to);
            to = smallEnd;
        } else {
            quickSort(a, from, smallEnd);
            from = bigBegin;
        }
    }
}&lt;/pre&gt;
&lt;p&gt;不得不说是一个很巧妙的实现。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;不知不觉这篇文章写了这么长。本来想对比各种优化之间的性能差异，现在看来也没有什么必要。虽然快速排序算法是一个很容易很基础的算法，但我相信很多人并没有能够这么深入地去了解、去优化一个算法。而读过了v8引擎对于这么一个简单算法的实现后，我发现它并没有简单地为了实现一个算法而去实现，而是确确实实地尽一切可能去提高算法效率，去消除可能引起性能问题的因素。结论是你真的可以放心地使用 &lt;span id=&quot;crayon-55823efe74a8b517379522&quot; class=&quot;crayon-syntax crayon-syntax-inline  crayon-theme-zhouhua crayon-theme-zhouhua-inline crayon-font-monaco&quot;&gt;&lt;span class=&quot;crayon-pre crayon-code&quot;&gt;&lt;span class=&quot;crayon-t&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;crayon-sy&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;crayon-v&quot;&gt;sort&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;方法，它的性能令人放心。那么剩下问题的就是：作为开发者，我们应该如何编写高质量高性能的代码？是不是应该更精益求精一点，让我们代码更经得起推敲，更值得信任？&lt;/p&gt;</content:encoded></item><item><title><![CDATA[让你的网站成为自定义搜索引擎]]></title><description><![CDATA[起 有一天，我在打理博客的时候，无意看到了这样的提示： “按tab可通过zhouhua.info进行搜索”？这是什么？于是我按了tab： 看起来很高级嘛！输入“正则表达式”看看： 竟然真的有效果！到底发生了什么…… 打开chrome…]]></description><link>https://www.zhouhua.info//2015/opensearch/</link><guid isPermaLink="false">https://www.zhouhua.info//2015/opensearch/</guid><pubDate>Fri, 05 Jun 2015 23:27:56 GMT</pubDate><content:encoded>&lt;h2&gt;起&lt;/h2&gt;
&lt;p&gt;有一天，我在打理博客的时候，无意看到了这样的提示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/05/QQ20150527145709.png&quot; alt=&quot;QQ20150527145709&quot;&gt;&lt;/p&gt;
&lt;p&gt;“按tab可通过zhouhua.info进行搜索”？这是什么？于是我按了tab：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/05/QQ20150527150159.png&quot; alt=&quot;QQ20150527150159&quot;&gt;&lt;/p&gt;
&lt;p&gt;看起来很高级嘛！输入“正则表达式”看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/05/QQ20150527150313.png&quot; alt=&quot;QQ20150527150313&quot;&gt;&lt;/p&gt;
&lt;p&gt;竟然真的有效果！到底发生了什么……&lt;/p&gt;
&lt;p&gt;打开chrome的搜索引擎管理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/05/QQ20150527150721.png&quot; alt=&quot;QQ20150527150721&quot;&gt;&lt;/p&gt;
&lt;p&gt;我的博客怎么就被认为是搜索引擎呢？一定要搞明白怎么回事。&lt;/p&gt;&lt;/p&gt;
&lt;h2&gt;承&lt;/h2&gt;
&lt;p&gt;要让浏览器知道自己的网站是一个搜索引擎，在技术上并不难实现。很久之前amazon就提出了&lt;a href=&quot;http://www.opensearch.org/Specifications/OpenSearch/1.1#OpenSearch_description_document&quot;&gt;OpenSearch标准草案&lt;/a&gt;。浏览器们是认这个标准的，只是各自实现不太一样。而开发者大多不太了解这玩意儿。总之挺鸡肋的吧，不过挺简单的，单纯提升点逼格也不错。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文所涉及的体验针对chrome，其他浏览器未测试。据我所知，IE浏览器处理OpenSearch时，并不会主动信任一个网站为搜索引擎，而是需要网站管理者向微软提出申请，审核通过才会被IE认为是搜索引擎。&lt;/p&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么就来试试吧。&lt;/p&gt;
&lt;p&gt;首先要告诉浏览器：我是搜索引擎。做法很简单，在网页的head部分加上这样一行：&lt;/p&gt;
&lt;pre class=&quot;lang:xhtml decode:true&quot;&gt;&amp;lt;link rel=&quot;search&quot; type=&quot;application/opensearchdescription+xml&quot; href=&quot;http://www.zhouhua.info/opensearch.xml&quot; title=&quot;step over&quot;&amp;gt;&lt;/pre&gt;
&lt;p&gt;我们看到type定义了一种从来没见过的mine类型&lt;/p&gt;
&lt;pre class=&quot;lang:ini decode:1 inline:1 &quot; &gt;application/opensearchdescription+xml&lt;/pre&gt;
&lt;p&gt; ，不用紧张，这是openSearch标准规定的，你不用额外对服务器进行配置，只要提供一个能访问到的xml文件。在这个例子中，我的xml文件路径为&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;http://www.zhouhua.info/opensearch.xml&lt;/pre&gt;
&lt;p&gt; 。关键就是要看这个xml是什么样的。标准中定义了很多，但我觉得设置几个简单的属性就够了：&lt;/p&gt;
&lt;pre class=&quot;lang:xhtml decode:true&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
&amp;lt;OpenSearchDescription xmlns=&quot;http://a9.com/-/spec/opensearch/1.1/&quot;&amp;gt;
    &amp;lt;ShortName&amp;gt;屠龙刀&amp;lt;/ShortName&amp;gt;
    &amp;lt;Description&amp;gt;搜索周骅的博客&amp;lt;/Description&amp;gt;
    &amp;lt;Url type=&quot;text/html&quot; method=&quot;get&quot; template=&quot;http://zhouhua.info/?s={searchTerms}&quot;/&amp;gt;
&amp;lt;/OpenSearchDescription&amp;gt;&lt;/pre&gt;
&lt;p&gt;我这里定义了三个属性，ShortName表示搜索引擎的名字，Description代表搜索引擎的描述，这都比较好理解。比较重要的是Url属性，它定义了搜索的方式。有这个例子里，规定了搜索结果是以text/html的形式返回，规定了用get方式去访问搜索action，规定了处理搜索的url为&lt;a href=&quot;http://zhouhua.info/?s=%7BsearchTerms%7D%EF%BC%8C%E5%85%B6%E4%B8%AD%7BsearchTerms%7D%E4%BC%9A%E8%A2%AB%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E6%9B%BF%E6%8D%A2%E3%80%82%E6%9C%89%E4%B8%80%E4%B8%AA%E6%AF%94%E8%BE%83%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%8C%E6%88%91%E7%A8%8D%E5%BE%AE%E8%AF%B4%E4%B8%80%E4%B8%8B%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BD%A0%E7%9A%84%E7%AB%99%E7%82%B9%E6%9C%89%E6%90%9C%E7%B4%A2%E8%AF%8D%E5%BB%BA%E8%AE%AE%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%8C%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%86%8D%E5%AE%9A%E4%B9%89%E4%B8%80%E6%9D%A1Url%E5%AD%97%E6%AE%B5%EF%BC%8C%E5%B0%86template%E6%8C%87%E5%90%91%E8%AF%B7%E6%B1%82%E6%90%9C%E7%B4%A2%E5%BB%BA%E8%AE%AE%E7%9A%84ajax%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%90%8C%E6%97%B6%E8%AE%BE%E7%BD%AErel%E5%B1%9E%E6%80%A7%E4%B8%BAsuggestion%E3%80%82%E7%B1%BB%E4%BC%BC%E8%BF%99%E6%A0%B7%EF%BC%9A&quot;&gt;http://zhouhua.info/?s={searchTerms}，其中{searchTerms}会被用户输入的关键字替换。有一个比较有意思的功能，我稍微说一下，如果你的站点有搜索词建议的功能，你可以再定义一条Url字段，将template指向请求搜索建议的ajax地址，同时设置rel属性为suggestion。类似这样：&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;lang:xhtml decode:true&quot;&gt;&amp;lt;Url type=&quot;application/json&quot; rel=&quot;suggestions&quot; template=&quot;http://my_site/suggest?q={searchTerms}&quot; /&amp;gt;&lt;/pre&gt;
&lt;p&gt;标准里定义了Url可以有四种rel类型，我感觉比较有价值的就两种，一种是设置获取搜索结果的url，rel为result，这种最重要，如果不设置rel属性，那么会默认这个Url字段是这个作用；第二种是设置获取搜索建议的url，它的rel属性为suggestions，如果取这个值，那么这个属性是不可以省略的。其他的两种取值就不说了。&lt;/p&gt;
&lt;p&gt;除了以上的一些字段，其实可定制的内容还有很多，有兴趣的可以&lt;a href=&quot;http://www.opensearch.org/Specifications/OpenSearch/1.1&quot;&gt;查看文档&lt;/a&gt;，我就不多介绍。因为我迫不及待地想看看设置的效果怎么样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/06/QQ20150605222420.png&quot; alt=&quot;QQ20150605222420&quot;&gt;&lt;/p&gt;
&lt;p&gt;效果还是不错的嘛，设置的搜索引擎名称等都生效了，挺好玩的。&lt;/p&gt;
&lt;h2&gt;转&lt;/h2&gt;
&lt;p&gt;自定义搜索引擎无非就是通过现有的标准，网站向浏览器传达了自己是搜索引擎、传达了自己的特征和用法，而浏览器则根据这些信息把网站添加到搜索引擎列表中，并对它们启用特殊的交互体验（比如输入域名就可以按tab进入搜索功能、可以设置成默认搜索引擎等）。&lt;/p&gt;
&lt;p&gt;但我的疑问是，一开始我可是什么也没有干呀，那么chrome是怎么知道我的网站有搜索功能，并把它添加到了搜索引擎列表中的呢？&lt;/p&gt;
&lt;p&gt;在chrome的这篇文档中，我找到了答案：&lt;a href=&quot;http://dev.chromium.org/tab-to-search&quot;&gt;传送门&lt;/a&gt;（英文，需梯子）。&lt;/p&gt;
&lt;p&gt;原来在使用chrome访问一个网站时，chrome会先查看有没有定义OpenSearch。如果没有的话，它会在网页中找有没有这样一个表单：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;表单以GET方式提交（POST不可以）；&lt;/li&gt;
&lt;li&gt;表单的提交url为HTTP协议的（HTTPS不可以）；&lt;/li&gt;
&lt;li&gt;表单没有附加onSubmit事件（确保提交过程不被用户代码干涉）；&lt;/li&gt;
&lt;li&gt;表单中仅包含一个input输入框，而且类型为text（其他类型的都不可以，多余的控件也都不可以）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果有这样一个表单，chrome会认为这是一个搜索框，并根据这个表单的信息推断出这个网站的搜索方法。在我的网站中，恰恰有这样的表单：&lt;/p&gt;
&lt;pre class=&quot;lang:xhtml decode:true&quot;&gt;&amp;lt;form role=&quot;search&quot; method=&quot;get&quot; id=&quot;searchform&quot; class=&quot;searchform&quot; action=&quot;http://www.zhouhua.info/&quot;&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;label class=&quot;screen-reader-text&quot; for=&quot;s&quot;&amp;gt;搜索：&amp;lt;/label&amp;gt;
    &amp;lt;input type=&quot;text&quot; value=&quot;&quot; name=&quot;s&quot; id=&quot;s&quot;&amp;gt;
    &amp;lt;input type=&quot;submit&quot; id=&quot;searchsubmit&quot; value=&quot;搜索&quot;&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/form&amp;gt;&lt;/pre&gt;
&lt;p&gt;这个表单提供的信息和&lt;/p&gt;
&lt;pre class=&quot;lang:xhtml decode:1 inline:1 &quot; &gt;&amp;lt;Url type=&quot;text/html&quot; method=&quot;get&quot; template=&quot;http://zhouhua.info/?s={searchTerms}&quot;/&amp;gt;&lt;/pre&gt;
&lt;p&gt; 是等价的。但并不能提供更多的信息了，所以一开始，chrome直接是拿网站的域名当成是搜索引擎的名字。&lt;/p&gt;
&lt;p&gt;对于chrome的这个设计，我持保留意见，毕竟存在一定的误判率。&lt;/p&gt;
&lt;p&gt;在chrome的文档中，最后一句话提到了添加自定义引擎的第三种方法，使用AddSearchProvider这个API。虽然这个文档中只提到了一个词，但并不妨碍我们获取更多信息，MSDN和MDN上都有文档。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/aa744112.aspx&quot;&gt;跳到MSDN&lt;/a&gt; 、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Adding_search_engines_from_web_pages&quot;&gt;跳到MDN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MDN的文档中有一个示例程序还是值得学习一下，它对AddSearchProvider做了兼容性的提升：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;function installSearchEngine() {
 if (window.external &amp;amp;&amp;amp; (&quot;AddSearchProvider&quot; in window.external)) {
   // Firefox 2 and IE 7, OpenSearch
   window.external.AddSearchProvider(&quot;http://example.com/search-plugin.xml&quot;);
 } else if (window.sidebar &amp;amp;&amp;amp; (&quot;addSearchEngine&quot; in window.sidebar)) {
   // Firefox &amp;lt;= 1.5, Sherlock
   window.sidebar.addSearchEngine(&quot;http://example.com/search-plugin.src&quot;,
                                  &quot;http://example.com/search-icon.png&quot;,
                                  &quot;Search Plugin&quot;, &quot;&quot;);
 } else {
   // No search engine support (IE 6, Opera, etc).
   alert(&quot;No search engine support&quot;);
 }
}&lt;/pre&gt;
&lt;h2&gt;合&lt;/h2&gt;
&lt;p&gt;不得不说，chrome对表单功能进行猜测，并以此提升用户体验确定给到我惊喜。但深入思考之后，我却不认为这是一个好的idea，至少对于搜索行为的猜测。&lt;/p&gt;
&lt;p&gt;回到OpenSearch上，总体而言，这个功能实现起来相当容易，除去chrome的自动探测不说，也算有两种通用的方法，开发量很小，而且对性能没什么影响。但实际上带的效果是因人而异的，至少对个人网站没什么用。我觉得并不是这个功能不好用，而是人们根本想不到用，这个使用习惯并没有建立。试想一下，如果你想在网站中搜索，以下两种搜索方式，你更习惯哪种：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/06/QQ20150605231843.png&quot; alt=&quot;QQ20150605231843&quot;&gt;&lt;/p&gt;
&lt;p&gt;我想更多人习惯直接用网页上提供的搜索功能。而且很多网站都将搜索功能fixed定位在页面上，访问便携。&lt;/p&gt;
&lt;p&gt;对于OpenSearch，我的观点是，它对于小网站其实是很鸡肋的；对于资讯信息类的大网站而言，还是有一定的价值，能稍许提升用户体验。好就好在开发量很小，大家都可以尝试尝试。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[小心别落入正则回溯陷阱]]></title><description><![CDATA[不知才哪儿看来的： 如果你有一个问题，你想到可以用正则来解决，那么你有两个问题了。 我觉得正则表达式实在是一种人难以理解的语言，比xml…]]></description><link>https://www.zhouhua.info//2015/trap/</link><guid isPermaLink="false">https://www.zhouhua.info//2015/trap/</guid><pubDate>Tue, 02 Jun 2015 00:52:15 GMT</pubDate><content:encoded>&lt;p&gt;不知才哪儿看来的：&lt;/p&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你有一个问题，你想到可以用正则来解决，那么你有两个问题了。&lt;/p&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我觉得正则表达式实在是一种人难以理解的语言，比xml还要逆天。不过它真的很好用。正则表达式的坑在于，看到一个正则，我们很难直观地知道它要做什么；写了一个正则，我们也很难直观地想像机器是怎么处理的。因而常常出现想不到或者没想到的问题。今天我们谈谈一个严重影响性能的问题，我称之为回溯陷阱，或者叫灾难性回溯（Catastrophic Backtracking）。&lt;/p&gt;
&lt;h2&gt;回溯&lt;/h2&gt;
&lt;p&gt; 对于正则而言，回溯并不是必需的，这跟具体的正则引擎有关。简单地说，正则引擎分为NFA和DFA。这东西难懂且无聊，我就挑重点说。DFA（确定型有穷自动机），从匹配文本入手，从左到右，每个字符不会匹配两次，它的时间复杂度是多项式的，所以通常情况下，它的速度更快，但支持的特性很少，不支持捕获组、各种引用等等；而NFA（非确定型有穷自动机）则是从正则表达式入手，不断读入字符，尝试是否匹配当前正则，不匹配则吐出字符重新尝试，通常它的速度比较慢，最优时间复杂度为多项式的，最差情况为指数级的。但NFA支持更多的特性，因而绝大多数编程场景下（包括js），我们面对的是NFA。&lt;/p&gt;
&lt;p&gt;NFA匹配的过程就是吃入字符，尝试匹配，如果通过，再吃入尝试；如果不通过，就吐出，回到上一个状态，因为同一个字符串在正则中可能存在一种状态不同转化路径，这时正则引擎换一个转化状态进行尝试，如果通过，继续吃入字符，否则继续吐出字符，回到再上一个状态。这种尝试不成功就返回上一状态的过程，我们称为回溯。正则匹配的性能好坏，就看回溯的情况，回溯越多，性能越差。&lt;/p&gt;
&lt;p&gt;为了说清楚这个问题，我们做一个实验，用&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;/a(acd|bsc|bcd)/&lt;/pre&gt;
&lt;p&gt; 这个正则来对“abcd”这个字符串进行匹配。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/06/QQ20150601221148.png&quot; alt=&quot;QQ20150601221148&quot;&gt;&lt;/p&gt;
&lt;p&gt;截图上方是正则表达式，右侧是要匹配的文本，左侧是匹配的过程。&lt;/p&gt;
&lt;p&gt;可以看到，匹配这4个字母花了8步，分别看看这8步都在干什么。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步：从正则表达式第一个字符a开始，吃进“abcd”的第一个字符，也是a，匹配成功！&lt;/li&gt;
&lt;li&gt;第二步：这时正则表达式遇到了分支，后面有三种匹配可能，分别是acd、bsc、bcd。先选择第一个路径acd，吃入“abcd”的第二个字符，是b，匹配不成功。这时就需要进行一次回溯了（backtrack），把吃进来的最后一个字符b还回去，同时放弃第一个路径，选择第二个路径bsc；&lt;/li&gt;
&lt;li&gt;第三步：第二个路径bsc中，第一个字符是b，吃进“abcd”中的第二个字符，也是b，匹配成功！&lt;/li&gt;
&lt;li&gt;第四步：第二个路径bsc中，下一个字符是s，吃进“abcd”中的第三个字符是c，匹配失败，又要进行回溯了。把刚刚吃进的c和b还回去，回到第二步的状态，并选择第三个路径bcd；&lt;/li&gt;
&lt;li&gt;第五步~第七步：依次匹配bcd和“abcd”中的剩余字符，均匹配成功。&lt;/li&gt;
&lt;li&gt;第八步：完成匹配。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从这个并不复杂的例子中，光b这个字母就匹配了三次，可见回溯在正则表达式中相当普遍。&lt;/p&gt;
&lt;h2&gt;量词嵌套&lt;/h2&gt;
&lt;p&gt;考虑这样一个正则&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;/(a*)*b/&lt;/pre&gt;
&lt;p&gt; ，用它来匹配”aaaaaaaaaa”（10个a组成的字符串）。看起来不复杂呀，实验一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/06/QQ20150601224618.png&quot; alt=&quot;QQ20150601224618&quot;&gt;&lt;/p&gt;
&lt;p&gt;哦，天哪，竟然花费了6143步才完成！如果再加上一个a呢，变成11个a组成的字符串会怎么样？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/06/QQ20150601224802.png&quot; alt=&quot;QQ20150601224802&quot;&gt;&lt;/p&gt;
&lt;p&gt;变成12287步了，翻了一倍。事实就是这样，当出现以上这种量词嵌套时，如果遭遇最坏情况（最后一个字符才能确实匹配不成功），那么这时正则引擎陷入灾难性回溯，时间复杂度为指数级）。&lt;/p&gt;
&lt;p&gt;如果你试着再嵌套一层，9个a组成的字符串就能突破100万步了……&lt;/p&gt;
&lt;h2&gt;其他情况&lt;/h2&gt;
&lt;p&gt;很多时候，并不是上面所述的那么极端的情况，更多的可能是对一个复杂的子句加量词，而这个子句中本身就含有量词；或者子句中有比较复杂的分组。这些情况实际应用中很可能会出现，虽然达不到夸张的指数级复杂度，但对性能依然是不小的挑战。&lt;/p&gt;
&lt;p&gt;有一个例子我觉得比较有趣，对于性能优化这个问题，也有参考价值。什么例子呢？用正则表达式匹配一个数字是否为质数。呃……这有点跳跃，看似风马牛不相及，但还真能做到。我们就简单一点，不考虑1。首先，把数字转成字符串，是几就写几个1。比如5就转成5个1组成的字符串11111。用来匹配的正则是&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;/^(11+)\1+$/&lt;/pre&gt;
&lt;p&gt; ，如果匹配通过，则是合数；不通过说明是质数。这个原理并不复杂，我不多说了。同样还有一些用正则测试二元一次方程整数解的问题，原理也类似。&lt;/p&gt;
&lt;p&gt;这个例子其实没什么用，因为好玩所以印象深刻。那对于我们有什么参考价值呢？就是别写这么费性能的正则！这个例子中，看起来没有量词嵌套等情况，但与其他问题类似的，这里对引用值加了量词，而这个引用词并不确定，回溯仍然会很多。所以我们除了要注意量词嵌套、复杂子表达式加量词或分组加量词这些情况外，还要注意引用加量词，这点是我没见别人提到过的。&lt;/p&gt;
&lt;h2&gt;一些解决手段&lt;/h2&gt;
&lt;h3&gt;量词运算&lt;/h3&gt;
&lt;p&gt;对于量词嵌套的情况，一些简单的运算可以消除嵌套：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;(a*)* &amp;lt;==&amp;gt; (a+)* &amp;lt;==&amp;gt; (a*)+ &amp;lt;==&amp;gt; a*
(a+)+ &amp;lt;==&amp;gt; a+&lt;/pre&gt;
&lt;p&gt;很简单，不多说。&lt;/p&gt;
&lt;h3&gt;占有优先量词（Possessive Quantifiers）&lt;/h3&gt;
&lt;p&gt;这个有点意思，可惜javascript还不支持，我说简单说说。用法很简单，在量词的后面再加上一个+。类似&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;/a++b/&lt;/pre&gt;
&lt;p&gt; ，那么这和&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;/a+b/&lt;/pre&gt;
&lt;p&gt; 有什么区别呢？占有优先量词并不保存回溯状态，换言之，前者不能回溯。如果匹配成功，没什么区别；如果最后b匹配不成功，那么前者不会进行回溯，而是直接匹配失败，后者会再进行回溯。&lt;/p&gt;
&lt;h3&gt;固化分组（或原子分组，Atomic Grouping）&lt;/h3&gt;
&lt;p&gt;这个更有意思，它控制一个这个字串整体不回溯。用法是这样的&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;/(?&amp;gt;abc)/&lt;/pre&gt;
&lt;p&gt; 。嗯，不幸的是javascript依然不支持。不过用其他语言的时候一定要对这个特性保持关注，本身它的兼容性要比占有优先量词要高（比c#支持原子分组不支持占有优先量词），另外它完全可以模拟出占有优先量词的功能，用法也更灵活。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://html-js.com/article/2846&quot;&gt;http://html-js.com/article/2846&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.regular-expressions.info/catastrophic.html&quot;&gt;http://www.regular-expressions.info/catastrophic.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.regular-expressions.info/possessive.html&quot;&gt;http://www.regular-expressions.info/possessive.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.regular-expressions.info/atomic.html&quot;&gt;http://www.regular-expressions.info/atomic.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; &lt;/p&gt;</content:encoded></item><item><title><![CDATA[“===”也有不靠谱的时候]]></title><description><![CDATA[自古js多奇葩，语言层面上有许多坑，入坑多了也就习惯了。那就再多一个坑吧。 javascript在判断两个值是否相等时，有两种方式  和  。这两者的区别我就不多说了，随便一本js…]]></description><link>https://www.zhouhua.info//2015/equal/</link><guid isPermaLink="false">https://www.zhouhua.info//2015/equal/</guid><pubDate>Fri, 08 May 2015 20:12:30 GMT</pubDate><content:encoded>&lt;p&gt;自古js多奇葩，语言层面上有许多坑，入坑多了也就习惯了。那就再多一个坑吧。&lt;/p&gt;
&lt;p&gt;javascript在判断两个值是否相等时，有两种方式&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;==&lt;/pre&gt;
&lt;p&gt; 和&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;===&lt;/pre&gt;
&lt;p&gt; 。这两者的区别我就不多说了，随便一本js书上都有，总之一般情形下我们有这样的结论：&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;==&lt;/pre&gt;
&lt;p&gt; 省事，但结果混乱，很多情形下近乎伪科学，不建议使用，很多人更是视其为洪水猛兽，避之不及（它的坑太多，我写不完，不写了）；&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;===&lt;/pre&gt;
&lt;p&gt; 很严谨，在绝大多数情形下，应该使用。这个结论我是很认同的，并且尽量这么做。但是，javascript作为一门任性的语言，不打打脸怎么好玩呢。那么一起来愉快地玩坏&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;===&lt;/pre&gt;
&lt;p&gt; 吧[icon name=“smile-o” class=&quot;&quot;]。&lt;/p&gt;
&lt;p&gt;要玩坏&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;===&lt;/pre&gt;
&lt;p&gt; ，只需要用到0。没错，就是数字0。在javascript中，数字都是以浮点数的形式参与运算，其编码规则遵循&lt;a href=&quot;http://baike.baidu.com/view/1698149.htm&quot;&gt;IEEE_754&lt;/a&gt;标准（0.2+0.1不等于0.3这个问题怪它！）。重点也不是这个标准，重点是按照这个标准，数字编码会有一位符号位表示正负，所以对于任何数字，非正即负。那么问题来了，0呢？答案是0也是有正负的。通常我们看到的，它义的0都是+0，但在javascript中-0也是存在的。而在实际运算中，某些场景下，计算结果会产生+0和-0的差异；同样+0和-0参与计算时，可能会导致不同的结果。但在直观感受上，很明显+0和-0应该是相等的才对，于是javascript在语言层面上想消除这种差异，所以：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/05/QQ20150508115353.png&quot; alt=&quot;QQ20150508115353&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;看起来很合理，虽然有点奇怪。但是再看这样的运算：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/05/QQ20150508115038.png&quot; alt=&quot;QQ20150508115038&quot;&gt;&lt;/p&gt;
&lt;p&gt;这不科学，明明判定为完全相同的值，进行相同的运算后，结果会不相等。对于开发者而言，我们并不能在任何场景下信任&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;===&lt;/pre&gt;
&lt;p&gt; ，它也有不靠谱的时候。&lt;/p&gt;
&lt;p&gt;应对这种“不科学”的情形也很简单：&lt;/p&gt;&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;function isEqual(a, b){
    if (a !== b) return false;
    return a !== 0 || 1 / a === 1 / b;
}&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;2015年5月14日补充：&lt;/p&gt;
&lt;p&gt;强调一下本文的重点吧，我从来没想质疑正负Infinity不相等的问题，我想分享的要点是：&lt;strong&gt;在js中，+0 === -0，但它们并不是完全相等的。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;2015年5月26日补充：&lt;/p&gt;
&lt;p&gt;头一回回复评论比正文还长……集中整理一下吧。&lt;/p&gt;
&lt;h2&gt;关于IEEE_754标准&lt;/h2&gt;
&lt;p&gt;这是一个使用二进制表示浮点数的方案，应用很广泛。它规定了一位符号位表示正负，0也不例外，这是负0产生的原因。这是带符号位的浮点数表示方案的通病，当然，不带符号位的方案就可以避免这个问题。不过这个问题并不严重，通常程序语言并不希望开发者知道负0的存在，直接在语言层面上规定正0和负0相等，这才是+0===-0的本质原因。&lt;/p&gt;
&lt;p&gt;我说负0的问题并不严重，是因为其使用场景少，出bug机率低。说到不严重，肯定有严重的问题，那就是浮点数精度的问题，数值是精确的、连续的；而数值编码是离散的，很多时候不准确的。毕竟32位也好、64位也好，能表现的浮点数是有限的。从0.1、0.2到0.9，真正能精确表达的只有0.5，其他的数字都是近似值。你可以自己尝试一下，不管js、java还是c++，浮点数运算从来不可靠，比如0.2+0.1并不等于0.3。如果你有过c++或者java编程经验，很可能接触过一些奇葩的代码来处理浮点数比较，比如定义一个精度0.002f（假设），如果abs(floatA-floatB)&amp;#x3C;0.002f，则认为两者相等。很反人类，但没办法。编程语言有错吗？没有，但现实就是要妥协。&lt;/p&gt;
&lt;h2&gt;关于负0&lt;/h2&gt;
&lt;p&gt;负0在数学上并没有意义，0是无符号的。但如果一个数值趋向于0，那么它是有符号的，可以为负。但对于这种情况，IEEE&lt;em&gt;754标准并没有定义。所以实际开发场景中，如果一个数值趋向于0，那么它就是0，此时，负0就有意义了，它可能代表的是趋向于0的负数。本质上这还是IEEE&lt;/em&gt;754精度，或者表达范围的问题。但当负0有了具体意义的时候，再说+0===-0，我觉得有待商榷的。&lt;/p&gt;
&lt;h2&gt;负0常见吗&lt;/h2&gt;
&lt;p&gt;首先我要说负0不常见，但绝不是大家想的通常不可能出现。其实一些常见的、简单的场景下就有可能出现-0。比如&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;Math.ceil(-0.1)&lt;/pre&gt;
&lt;p&gt; 、&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;Math.round(-0.1)&lt;/pre&gt;
&lt;p&gt; ；还有不常见的&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;Math.atan2(-1, Infinity)&lt;/pre&gt;
&lt;p&gt; 等。由正负0而产生不同计算结果的操作相对会更多一点，比如文章中的举例的倒数运算。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality&lt;em&gt;comparisons&lt;/em&gt;and_sameness&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;javascript与===运算&lt;/h2&gt;
&lt;p&gt;通常情况下，===在js中，表示判断类型和值是否都完全相等。都说通常了，肯定有反例。很多熟悉js的人都知道这样一个知识点，NaN!==NaN。所以我们常常可以看到这样的代码：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true &quot;&gt;function isNaN (num){
    return num !== num;
}&lt;/pre&gt;
&lt;p&gt;这就是编程语言为了满足直观的理解而操纵运算符的结果。+0和-0同样是这样，它们的编码并不同，但却判定它们相等。&lt;/p&gt;
&lt;p&gt;对于以上两个点，EmacScript 6中加入了Object.is方法来处理：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;Object.defineProperty(Object, &apos;is&apos;, {
  value: function(x, y) {
    if (x === y) {
      // 0 === -0, but they are not identical
      return x !== 0 || 1 / x === 1 / y;
    }

    // NaN !== NaN, but they are identical.
    // NaNs are the only non-reflexive value, i.e., if x !== x,
    // then x is a NaN.
    // isNaN is broken: it converts its argument to number, so
    // isNaN(&quot;foo&quot;) =&amp;gt; true
    return x !== x &amp;amp;&amp;amp; y !== y;
  },
  configurable: true,
  enumerable: false,
  writable: true
});&lt;/pre&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://wiki.ecmascript.org/doku.php?id=harmony:egal&quot;&gt;http://wiki.ecmascript.org/doku.php?id=harmony:egal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于负0的问题，EmacScript 5中同样加入了isNegative0来处理-0。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.wirfs-brock.com/allen/posts/128&quot;&gt;http://www.wirfs-brock.com/allen/posts/128&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不仅如此，一些工具类库中也加入了类似的处理，如underscore的isEqual方法。&lt;/p&gt;
&lt;h2&gt;So…&lt;/h2&gt;
&lt;p&gt;对于绝大部分开发场景而言，-0根本没有存在感；但我把这个点分享出来，让更多的人知道有-0这个东西，让更多的人知道可能存在看似相同的输入，经过相同的计算，产生完全不同结果的可能，避免他们遭遇奇怪的bug。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[谈谈正则表达式中的“.”]]></title><description><![CDATA[好久没更新内容了，今天分享一个小的知识点，一个正则表达式方面的很容易被人忽视的坑。 我们知道，正则表达式中，可以用  表示任意单个字符，但在underscore和jquery…]]></description><link>https://www.zhouhua.info//2015/dot/</link><guid isPermaLink="false">https://www.zhouhua.info//2015/dot/</guid><pubDate>Thu, 07 May 2015 23:57:29 GMT</pubDate><content:encoded>&lt;p&gt;好久没更新内容了，今天分享一个小的知识点，一个正则表达式方面的很容易被人忽视的坑。&lt;/p&gt;&lt;/p&gt;
&lt;p&gt;我们知道，正则表达式中，可以用&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;.&lt;/pre&gt;
&lt;p&gt; 表示任意单个字符，但在underscore和jquery的源代码中，我们可以看到，这些著名类库的代码中，经常并不是用&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;.&lt;/pre&gt;
&lt;p&gt; 来表示任意字符，而是使用&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;[\w\W]&lt;/pre&gt;
&lt;p&gt; 或者&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;[\s\S]&lt;/pre&gt;
&lt;p&gt; 。乍一看，好像表达的含义是一样的，可是为什么放着简单的方法不用，而去多绕个圈子？今天就简单说说这个问题。&lt;/p&gt;
&lt;p&gt;首先我们必须要正确理解&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;.&lt;/pre&gt;
&lt;p&gt; 的含义。其实说它表示任意单个字符，可能会让人产生误解，必须要强调一下，这个“任意单个字符”不包括控制换行的字符，也就是不包含&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;\n&lt;/pre&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;\r&lt;/pre&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;\u2028&lt;/pre&gt;
&lt;p&gt; 或&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;\u2029&lt;/pre&gt;
&lt;p&gt; 这几个字符。而&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;\W&lt;/pre&gt;
&lt;p&gt; 和&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;\s&lt;/pre&gt;
&lt;p&gt; 中是能够包含这些字符的。那个这两种写法的差异也就很清晰了，就是能否匹配到几个换行控制符的差异。&lt;/p&gt;
&lt;p&gt;那么在什么时候我们需要考虑这几个换行控制符呢？当要处理的字符串可能包含换行时。这样的情景太多了，处理html字符串、处理template、nodejs读取文本等等。&lt;/p&gt;
&lt;p&gt;提及多行文本的场景，我们很容易想到正则表达式的&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;m&lt;/pre&gt;
&lt;p&gt; 模式（多行模式）。那么多行模式对我们今天讨论的问题有影响吗？我不是很确定。为什么不确定呢？有些人信誓旦旦地声称单行模式下&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;.&lt;/pre&gt;
&lt;p&gt; 的含义与多行模式下不同，单选模式下等同于&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;[\w\W]&lt;/pre&gt;
&lt;p&gt; 或者&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;[\s\S]&lt;/pre&gt;
&lt;p&gt; ，而多行模式下会排除换行控制符。但据我试验，以及参考MDN的说法，这是不对的。的确有很多语言的正则表达式会有上述特性，但在javascript中我没有看到，不知道会不会有浏览器方面的差异。那么多行模式对于javascript而言影响的是什么呢？我认为仅仅是改变了&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;^&lt;/pre&gt;
&lt;p&gt; 和&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;$&lt;/pre&gt;
&lt;p&gt; 标识的含义：单行模式下，分别表示整个字符串的开始的结尾；多行模式下表示每一行的开始和结尾。而不管多行模式还是单行模式，我认为&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;.&lt;/pre&gt;
&lt;p&gt; 都是不包含换行控制字符的，等价于&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;[^\n\r\u2028\u2029]&lt;/pre&gt;
&lt;p&gt; 。&lt;/p&gt;
&lt;p&gt;再多延伸一点点，对于&lt;strong&gt;现代浏览器&lt;/strong&gt;，可以直接用&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;[^]&lt;/pre&gt;
&lt;p&gt;来匹配任意字符的。&lt;/p&gt;
&lt;p&gt;例子程序不想写了，有兴趣的可以自己试验一下，分别用&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;/.&amp;#42;/g&lt;/pre&gt;
&lt;p&gt; 、&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;/^.&amp;#42;$/g&lt;/pre&gt;
&lt;p&gt; 、&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;/.&amp;#42;/gm&lt;/pre&gt;
&lt;p&gt; 、&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;/^.&amp;#42;$/gm&lt;/pre&gt;
&lt;p&gt; 来匹配一下&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;&quot;abc\nedf&quot;&lt;/pre&gt;
&lt;p&gt; ，其中道理不言自明。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[干货！一步步实现自己的表单验证器]]></title><description><![CDATA[表单验证的需求简直太常见了。“ 所有用户的输入都是不可信的 ”这个思想指导我们在设计表单的时候，一定要进行用户输入的验证。对于用户体验而言，越早的反馈则越佳，所以表单验证的工作应该尽可能地在前端就进行（当然，前端对于后端而言也是输入端，所以后端仍然需要进行检验）。简单的表单验证完全可以给input…]]></description><link>https://www.zhouhua.info//2015/validation/</link><guid isPermaLink="false">https://www.zhouhua.info//2015/validation/</guid><pubDate>Wed, 15 Apr 2015 17:21:57 GMT</pubDate><content:encoded>&lt;p&gt;表单验证的需求简直太常见了。“&lt;strong&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;所有用户的输入都是不可信的&lt;/span&gt;&lt;/strong&gt;”这个思想指导我们在设计表单的时候，一定要进行用户输入的验证。对于用户体验而言，越早的反馈则越佳，所以表单验证的工作应该尽可能地在前端就进行（当然，前端对于后端而言也是输入端，所以后端仍然需要进行检验）。简单的表单验证完全可以给input绑定几个change事件来进行。但表单一复杂，或者相似验证规则一多，这种编码的方式就很难管理事件了。这时候，我们通常需要使用一些库来帮助我们处理表单验证的工作。前端表单验证的库太多了，随便一搜：&lt;a href=&quot;https://www.baidu.com/s?ie=UTF-8&amp;#x26;wd=%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81&quot;&gt;表单验证-百度搜索&lt;/a&gt;。&lt;/p&gt;&lt;/p&gt;
&lt;p&gt;那……为什么还要自己实现一个呢？因为去年工作中遇到了比较复杂的验证逻辑，选一个别人的库一是要学习api，二是维护起来困难，要符合自己的页面风格也不是那么轻松；再加上表单验证器并不复杂，于是就打算自己写一个。所以这个表单验证器并不算那么地通用，不过我觉得传播思路和方法更重要，要想修修改改变成一个通用的库也很容易，只是没那么重要罢了（其实是懒……）。&lt;/p&gt;
&lt;h2&gt;依赖&lt;/h2&gt;
&lt;p&gt;jquery + bootstrap。jquery看来是缺不了，bootstrap没那么重要，对代码稍做修改就可以取消依赖。&lt;/p&gt;
&lt;h2&gt;能做什么&lt;/h2&gt;
&lt;p&gt;我期望这个表单验证器直接在html代码中指定好需要采用什么样的规则，不需要用javascript进行多余的配置；允许暂时跳过验证；允许扩展验证规则；提供验证难过、验证失败、警告三种验证结果；允许手动触发验证等等。&lt;/p&gt;
&lt;p&gt;一个典型的bootstrap风格的表单项应该长这个样子：&lt;/p&gt;
&lt;pre class=&quot;lang:xhtml mark:5 decode:true&quot;&gt;&amp;lt;div class=&quot;form-group&quot;&amp;gt;
    &amp;lt;label class=&quot;col-xs-2 control-label&quot;&amp;gt;手机号码
        &amp;lt;span class=&quot;request&quot;&amp;gt;*&amp;lt;/span&amp;gt;：&amp;lt;/label&amp;gt;
    &amp;lt;div class=&quot;col-xs-6&quot;&amp;gt;
        &amp;lt;input class=&quot;form-control&quot; name=&quot;mobile&quot; type=&quot;text&quot; data-validate-disable=&quot;true&quot; data-validate=&quot;request:notrim mobile&quot; /&amp;gt;
        &amp;lt;p class=&quot;text-info&quot;&amp;gt;请输入真实手机号码。&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;help-block col-xs-4&quot;&amp;gt;&amp;amp;nbsp;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/pre&gt;
&lt;p&gt; 重点看第5行，对于一个普通的input组件，我加了两个属性，&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;data-validate-disable&lt;/pre&gt;
&lt;p&gt; 有值表示表单验证时，会跳过这个input组件；&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;data-validate&lt;/pre&gt;
&lt;p&gt; 则存放如果要验证的话，将采用什么样的验证规则。这个例子中表示要验证这个input组件是否为空、是否为手机号码这两个规则。注意，在&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;request&lt;/pre&gt;
&lt;p&gt; 的后面我还加了一点内容，这是我想传递给验证规则的参数，比如这里我期望告诉验证器，如果input值只有空格，也认为是有值的。相似的，我们可以定义一个规则&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;min&lt;/pre&gt;
&lt;p&gt; 来处理最少几个字符，并在html中把这个设定值传递进来，就像这样：&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;data-validate=&quot;min:10&quot;&lt;/pre&gt;
&lt;p&gt; 。我也期望一个验证规则允许多个参数传递，参数与参数之间用逗号隔开。&lt;/p&gt;
&lt;p&gt;看起来很有意思，那就开始动手吧。&lt;/p&gt;
&lt;h2&gt;先写个jquery插件吧&lt;/h2&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;(function ($) {
    $.fn.validation = function () {
        return this.each(function () {
            var $this = $(this);
            if (!$this.is(&apos;:input&apos;)) {
                $this = $this.find(&apos;:input&apos;);
            }
            $this.off(&apos;blur.zh select.zh focus.zh&apos;)
                .on(&apos;blur.zh select.zh&apos;, validate)
                .on(&apos;focus.zh&apos;, clear);
        });
    };
}(jQuery));&lt;/pre&gt;
&lt;p&gt; 给jquery对象添加一个&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;validation&lt;/pre&gt;
&lt;p&gt; 方法，用法很简单：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;$(Selector).validation()&lt;/pre&gt;
&lt;p&gt; 。支持链式调用。&lt;em&gt;Selector&lt;/em&gt;比较自由，如果是&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;:input&lt;/pre&gt;
&lt;p&gt; 元素，则直接给这些元素初始化验证器；否则找出它们所有的&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;:input&lt;/pre&gt;
&lt;p&gt; 子元素，给这些子元素初始化验证器。什么意思呢？就以上面的html片断为例，你可以任性地使用如下任意一种方式初始化验证器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;$(&apos;[name=mobile]&apos;).validation(); // 选择:input&lt;/pre&gt; 
&lt;/li&gt;
&lt;li&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;$(&apos;.form-group&apos;).validation(); // 选择普通节点，对所有:input子元素生效&lt;/pre&gt; 
&lt;/li&gt;
&lt;li&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;$(&apos;body&apos;).validation(); // 对页面中所有的:input元素生效&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再说说所谓的初始化，其实就是绑定事件。那么要绑定什么事件呢？主观上，对于一个输入框，当我们输入好了，焦点离开时，应该就进行输入内容的验证，并给出验证结果。如果验证失败，会有提示信息，但这些提示信息应该在重新获得焦点时清除，否则当用户在修正输入的时候还一直提示上次的错误信息，会让用户无所适从。那么针对以上的情况，我们需要在失去焦点（&lt;em&gt;blur&lt;/em&gt;）和获得焦点（&lt;em&gt;focus&lt;/em&gt;）时分别绑定验证的方法（&lt;em&gt;validate&lt;/em&gt;）和清除错误信息的方法（&lt;em&gt;clear&lt;/em&gt;）。另外针对checkbox、radiobox、select等控件，最好也给select事件绑定验证方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么不使用更通用change事件来绑定验证方法呢？原因有二：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我觉得有些场景需要用javascript载入默认值或历史输入。这些内容应该延后验证（不是不验证），不然刚打开页面就是表单验证错误让人很难受。所以change事件不合适。&lt;/li&gt;
&lt;li&gt;由于获得焦点会清空错误消息，如果没有修改内容，直接失去焦点，这时不会触发change事件，导致不会再验证，表现为错误信息丢失。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;那下面就来具体看看&lt;em&gt;validate&lt;/em&gt;和&lt;em&gt;clear&lt;/em&gt;两个方法。&lt;/p&gt;
&lt;h2&gt;清除错误消息及验证状态设置&lt;/h2&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;function clear() {
    var $this = $(this);
    var $parent = $this.closest(&apos;.form-group&apos;);
    if (!$parent.attr(&apos;data-for&apos;) || 
        $parent.attr(&apos;data-for&apos;) === $this.prop(&apos;name&apos;)) {
        $parent.attr(&apos;data-for&apos;, null).removeClass(&apos;has-error waiting has-warning&apos;)
            .find(&apos;.help-block&apos;).text(&apos;&apos;);
    }
}

function successHandler() {
    var $parent = this.closest(&apos;.form-group&apos;);
    if (!$parent.is(&apos;.has-warning&apos;)) {
        clear.call(this);
    }
}

function failHandler(msg) {
    var $parent = this.closest(&apos;.form-group&apos;);
    $parent.removeClass(&apos;has-warning waiting&apos;).addClass(&apos;has-error&apos;).
        attr(&apos;data-for&apos;, this.prop(&apos;name&apos;)).find(&apos;.help-block&apos;).text(msg);
}

function warningHandler(msg) {
    var $parent = this.closest(&apos;.form-group&apos;);
    $parent.removeClass(&apos;waiting&apos;).addClass(&apos;has-warning&apos;).
        attr(&apos;data-for&apos;, this.prop(&apos;name&apos;)).find(&apos;.help-block&apos;).text(msg);
}&lt;/pre&gt;
&lt;p&gt; 这一段一起说，因为这部分内容是dom操作相关的，与bootstrap强相关，如果你不用bootstrap，那就尽情地替换掉吧（估计改几个类名就行了）。这几个函数的用途从名字上就可以看出。clear上面已经提到过，清空验证信息；另外三个分别处理验证通过、验证失败和警告时的信息展示。简单是简单，但这里有两个问题需要额外考虑一下。&lt;/p&gt;
&lt;p&gt;第一个是验证信息优先级的问题：&lt;/p&gt;
&lt;p&gt;一个输入项可能同时有多个验证规则要匹配，可能有些验证规则通过，有些失败，有些警告。在具体处理时，我觉得比较合理的流程是：如果出现验证失败，则立刻停止后续验证，直接提示错误信息；如果警告，则提示警告信息，并继续后续规则验证；如果验证成功，理论上不需要做任何处理，直接进行下一步验证，但谨慎起见，还是做一下清空错误信息的工作，但要注意不可以清空掉警告信息（错误信息不用管，因为一产生错误信息，验证也就停止了，不会再触发验证成功了）。&lt;/p&gt;
&lt;p&gt;另一个问题是同一个表单单元中有多个输入控件的问题，就像这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/04/QQ20150415121912.png&quot; alt=&quot;QQ20150415121912&quot;&gt;&lt;/p&gt;
&lt;p&gt;几个控件共用了一个错误信息展示文本，我觉得如果某一个控件输入内容有误，必须再次修改这个控件内容才能清空错误信息，修改别的控件时，这个错误信息应该保留。所以在清除错误信息时，我们额外需要知道这个错误信息是由哪个控件引起的。在上面的示例中，我们在处理验证错误和警告时，把引起问题的控件的&lt;em&gt;name&lt;/em&gt;记录到表单单元的&lt;em&gt;data-for&lt;/em&gt;属性中了。到需要清空的时候再比对一下&lt;em&gt;data-for&lt;/em&gt;和当前控件的&lt;em&gt;name&lt;/em&gt;是不是一致，不一致就不清空错误信息。&lt;/p&gt;
&lt;h2&gt;处理验证流程&lt;/h2&gt;
&lt;p&gt;我们给输入控件的&lt;em&gt;blur&lt;/em&gt;和&lt;em&gt;select&lt;/em&gt;事件绑定了&lt;em&gt;validate&lt;/em&gt;方法，那么这个validate方法如何实现呢？&lt;/p&gt;
&lt;pre class=&quot;lang:js mark:3-5,17,20-30 decode:true&quot;&gt;function validate() {
    var $this = $(this);
    var success = new $.Callbacks();
    var fail = new $.Callbacks();
    var warning = new $.Callbacks();
    var $parent = $this.closest(&apos;.form-group&apos;);
    success.add(function (value) {
        successHandler.call($this, value);
    });
    fail.add(function (value) {
        failHandler.call($this, value);
    });
    warning.add(function (value) {
        warningHandler.call($this, value);
    });
    clear.call($this);
    if ($this.is(&apos;:disabled&apos;) || $this.is(&apos;[data-validate-disable]&apos;)) {
        return;
    }
    if ($this.attr(&apos;data-validate&apos;)) {
        var conditions = ($this.attr(&apos;data-validate&apos;) || &apos;&apos;).split(/\s+/g);
        for (var i in
            conditions) {
            var condition = conditions[i];
            $parent.addClass(&apos;waiting&apos;);
            if (!pickStrategy(condition.split(/[:,]/g), $this, success, fail, warning)) {
                break;
            }
        }
    }
}&lt;/pre&gt;
&lt;p&gt; 先看这段代码的前一部分，我定义了三个$.Callbacks对象，分别用以处理不同验证结果的响应。从效果上，不用$.Callbacks对象，直接传递函数引用也是可行的，我是想把dom操作和验证逻辑分离开，用类似事件触发的异步形式来处理验证逻辑。&lt;/p&gt;
&lt;p&gt;再看第17行，它规定了两种情形不执行验证，一种是控件被禁用，另一种是控件中存在&lt;em&gt;data-validate-disable&lt;/em&gt;属性。这个不用多解释了。&lt;/p&gt;
&lt;p&gt;重点看20~30行，这段是关键。第21行中，我们把&lt;em&gt;data-validate&lt;/em&gt;中的内容按空白（空格、tab、换行）切割到一个数组&lt;em&gt;conditions&lt;/em&gt;中，&lt;em&gt;conditions&lt;/em&gt;中的每一项都是一条需要验证的规则。那么很自然地，遍历这个数组。再看第26行，引入了一个新的方法&lt;em&gt;pickStrategy&lt;/em&gt;，很明显它是对这条规则进行验证。先别管它的实现，看看它接收的参数。还记得前面我们说要允许用&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;rule:param1,param2&lt;/pre&gt;
&lt;p&gt; 的形式给验证规则传入参数吗？&lt;em&gt;pickStrategy&lt;/em&gt;拿到的第一个参数就是&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;[rule, param1, param2]&lt;/pre&gt;
&lt;p&gt; ，通过&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;condition.spit(/[:,]/g)&lt;/pre&gt;
&lt;p&gt; 解析出。第二个参数是当前处理的控件的jquery对象，后面三个分别是验证成功、失败、警告三种情形的回调对象。如果验证失败，&lt;em&gt;pickStrategy&lt;/em&gt;应该返回&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;false&lt;/pre&gt;
&lt;p&gt; ，同时中止验证，否则验证下一条规则。&lt;/p&gt;
&lt;h2&gt;策略模式&lt;/h2&gt;
&lt;p&gt;下面就要来说&lt;em&gt;pickStrategy&lt;/em&gt;方法了，不过先要补充一点背景知识——策略模式。策略模式是一种设计模式。&lt;/p&gt;
&lt;p&gt;设计模式是搞软件工程的人常常挂在嘴边的词汇，表示对设计的复用。当然前端开发在工程化的进程上每家公司情况各异，我估计绝大多数公司的前端开发并不考虑工程上的问题，只考虑完成需求。因而对于没有OO编程开发背景的前端开发而言，设计模式可能是陌生的，甚至程序设计（别紧张，没有在说程序编写）本身就是陌生的。由于工程化的忽略和javascript语言本身的优点（很多模式没必要实现）和缺点（很多模式无法实现），前端开发中很少提设计模式。那么前端开发者怎么理解设计模式呢？设计模式就是一系统问题（场景）的通用解决思路。比如有人觉得jquery的链式调用很好用，能很大程度降低工作量，于是在别的地方也用函数&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;return this;&lt;/pre&gt;
&lt;p&gt; 的方式构造支持链式调用的函数，这就可以认为是一个模式（谈不上设计模式）。&lt;/p&gt;
&lt;p&gt;那策略模式是为了解决什么问题，或应对什么场景的呢？如果干一件事、完成一个任务可以有不同的策略，不同的算法来完成，这些策略、算法应该具有相同的输入和输出，但可以使用不同的资源（即不care中间实现差异）。具体要采用什么策略和方法则在程序运行时依据条件选择。举个例子？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/04/QQ20150415155218.png&quot; alt=&quot;QQ20150415155218&quot;&gt;&lt;/p&gt;
&lt;p&gt; 压缩文件，你可以选择不同的算法，但它们拥有相同的输入和输出。&lt;/p&gt;
&lt;p&gt;那么我们做表单验证跟策略模式有什么关系呢？我们完全可以把每个验证规则看作是一个策略，我们支持的所有的策略放在一起，取个高大上的名字叫“策略池”。当我们想验证一个规则的时候，只需要去策略池中取出这个策略跑一下，不需要在一个很大的函数里面跑一堆if…else，或者switch…case。另外如果有新的规则加进来，只要把它塞到策略池中，无需更改已有的代码，&lt;strong&gt;实现验证规则和验证流程解耦&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;先实现一个策略池吧：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true  &quot;&gt;$.validation.strategy = {};&lt;/pre&gt;
&lt;p&gt; 太棒了，一句代码就完事了，爱死javascript了！&lt;/p&gt;
&lt;p&gt;再回到&lt;em&gt;pickStrategy&lt;/em&gt;方法，看看怎么从这个策略池中拿到我们需要的验证规则：&lt;/p&gt;
&lt;pre class=&quot;lang:js mark:3,5 decode:true&quot;&gt;function pickStrategy(tokens, scope, success, fail, warning) {
    var name = tokens.shift();
    var strategy = $.validation.strategy[name];
    if (strategy) {
        return strategy.call(scope, tokens, success, fail, warning);
    }
    else {
        success.fire();
        return true;
    }
}&lt;/pre&gt;
&lt;p&gt; 先说这个&lt;em&gt;token&lt;/em&gt;，还记得它是什么吗？如果要验证的规则是“min:5”，那么&lt;em&gt;token&lt;/em&gt;就是&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;[&apos;min&apos;, &apos;5&apos;]&lt;/pre&gt;
&lt;p&gt; 这个数组。第2行取出这个数组的第一项&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;&apos;min&apos;&lt;/pre&gt;
&lt;p&gt; ，再从策略池中取出这个验证规则。如果没有这个规则，则跳过这次验证，认为此次通过；如果有这个规则，则执行这个规则（见第5行），需要注意一下第5行的&lt;em&gt;token&lt;/em&gt;已经发生变化了，除去规则名称，只剩下参数了，延续前面的例子，这里&lt;em&gt;token&lt;/em&gt;应该是&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;[&apos;5&apos;]&lt;/pre&gt;
&lt;p&gt; 。&lt;/p&gt;
&lt;p&gt;现在我们的策略池是空的，那可不行，先试着写一个验证“min”规则的方法吧：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;$.validation.strategy.min = function (condition, success, fail) {
    if (this.val() === &apos;&apos;) {
        success.fire();
        return true;
    }
    var length = +(condition &amp;amp;&amp;amp; condition[0]);
    if (length) {
        if (this.val().length &amp;gt;= length) {
            success.fire();
            return true;
        }
        else {
            fail.fire(&apos;请至少输入&apos; + length + &apos;个字！&apos;);
            return false;
        }
    }
    else {
        success.fire();
        return true;
    }
}&lt;/pre&gt;
&lt;p&gt; 这个方法内，&lt;em&gt;this&lt;/em&gt;指向当前验证的控件的jquery对象，第1个参数是额外带给验证规则的参数；第2个参数是验证成功的回调，使用时需要配合&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;return true;&lt;/pre&gt;
&lt;p&gt; （见9、10行）；第3个参数是验证失败的回调，使用是需要配合&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;return false;&lt;/pre&gt;
&lt;p&gt; （见13、14行）；第4个参数是警告的回调，需要配合&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;return true;&lt;/pre&gt;
&lt;p&gt; ，这个验证中没用到。&lt;/p&gt;
&lt;p&gt;起始的几个验证方法也可以直接写在策略池中，我写了几个，供大家参考（代码比较长，展开需谨慎。不想展开？你可能要错过身份证验证、邮箱验证、url验证等一堆干货了！）：&lt;/p&gt;
&lt;pre class=&quot;minimize:true lang:js decode:true &quot;&gt;$.validation.constants = {
    &apos;request&apos;: /./,
    &apos;trimLeft&apos;: /^\s+/,
    &apos;trimRight&apos;: /\s+$/,
    &apos;trim&apos;: /(^\s+)|(\s+$)/g,
    &apos;number&apos;: /^-?\d+(,\d{3,4})*(\.\d+)?$/,
    &apos;purenumber&apos;: /^\d+$/,
    &apos;shenfenzheng&apos;: /^\d{17}[\dx]$/i,
    &apos;taibaozheng&apos;: /^\d{8}(\d{2})?$/,
    &apos;zhizhao&apos;: /^\d{15}$/,
    &apos;mobile&apos;: /^1[345789]\d{9}$/,
    &apos;telephone&apos;: /^\d{7,8}([ +-]\d+)?$/,
    &apos;email&apos;: /^[a-z0-9.\-_+]+@[a-z0-9\-_]+(.[a-z0-9\-_]+)+$/i,
    &apos;url&apos;: /^(https?:\/\/)?(([\d]{1,3}\.){3}[\d]{1,3}|([\d\w_!~*\\&apos;()-]+\.)*([\d\w][\d\w-]{0,61})?[\d\w]\.[\w]{2,6})(:[\d]{1,4})?((\/?)|(\/[\d\w_!~*\\&apos;().;?:@&amp;amp;=+$,%#-]+)+\/?)$/
};

$.validation.strategy = {
    &apos;request&apos;: function (condition, success, fail) {
        if (this.is(&quot;[type=checkbox]&quot;) || this.is(&quot;[type=radio]&quot;)) {
            var name = this.attr(&quot;name&quot;);
            if (name) {
                if ($(&quot;[name=&quot; + name + &quot;]:checked&quot;).length) {
                    success.fire();
                    return true;
                }
                else {
                    fail.fire(&apos;不能为空！&apos;);
                    return false;
                }
            }
            else {
                success.fire();
                return true;
            }
        }
        else {
            if (condition &amp;amp;&amp;amp; condition[0]) {
                switch (condition[0].toLowerCase()) {
                    case &apos;notrim&apos;:
                        break;
                    case &apos;trimleft&apos;:
                        this.val(this.val().replace($.validation.constants.trimLeft, &apos;&apos;));
                        break;
                    case &apos;trimright&apos;:
                        this.val(this.val().replace($.validation.constants.trimRight, &apos;&apos;));
                        break;
                    default:
                        this.val(this.val().replace($.validation.constants.trim, &apos;&apos;));
                        break;
                }
            }
            if ($.validation.constants.request.test(this.val())) {
                success.fire();
                return true;
            }
            fail.fire(&apos;不能为空！&apos;);
            return false;
        }
    },
    &apos;min&apos;: function (condition, success, fail) {
        if (this.val() === &apos;&apos;) {
            success.fire();
            return true;
        }
        var length = +(condition &amp;amp;&amp;amp; condition[0]);
        if (length) {
            if (this.val().length &amp;gt;= length) {
                success.fire();
                return true;
            }
            else {
                fail.fire(&apos;请至少输入&apos; + length + &apos;个字！&apos;);
                return false;
            }
        }
        else {
            success.fire();
            return true;
        }
    },
    &apos;max&apos;: function (condition, success, fail) {
        var length = +(condition &amp;amp;&amp;amp; condition[0]);
        if (length) {
            if (this.val().length &amp;lt;= length) {
                success.fire();
                return true;
            }
            else {
                fail.fire(&apos;不能超过&apos; + length + &apos;个字！&apos;);
                return false;
            }
        }
        else {
            success.fire();
            return true;
        }
    },
    &apos;number&apos;: function (condition, success, fail) {
        var value = this.val();
        if (value === &apos;&apos;) {
            success.fire();
            return true;
        }
        condition = condition || [];
        if (!$.validation.constants.number.test(value)) {
            fail.fire(&apos;请输入数字！&apos;);
            return false;
        }
        for (var i in
            condition) {
            var c = condition[i].toLowerCase();
            if (c === &apos;pure&apos;) {
                if (!$.validation.constants.purenumber.test(value)) {
                    fail.fire(&apos;请输入0~9组成的数字！&apos;);
                    return false;
                }
            }
            else if (/^\d+[~-]\d+$/.test(c)) {
                var match = c.match(/\d+/g);
                var length = value.length;
                if (length &amp;lt; +match[0]) {
                    fail.fire(&apos;请至少输入&apos; + match[0] + &apos;位数字！&apos;);
                    return false;
                }
                if (length &amp;gt; +match[1]) {
                    fail.fire(&apos;最多只能输入&apos; + match[1] + &apos;位数字！&apos;);
                    return false;
                }
            }
            else if (/^\d+$/.test(c)) {
                if (+c !== value.length) {
                    fail.fire(&apos;请输入&apos; + c + &apos;位数字！&apos;);
                    return false;
                }
            }
            success.fire();
            return true;
        }
    },
    &apos;mobile&apos;: function (condition, success, fail) {
        var value = this.val();
        if (value === &apos;&apos;) {
            success.fire();
            return true;
        }
        if (!$.validation.constants.mobile.test(value)) {
            fail.fire(&apos;手机号码输入有误，请检查后重新输入！&apos;);
            return false;
        }
        success.fire();
        return true;
    },
    &apos;url&apos;: function (condition, success, fail) {
        var value = this.val();
        if (value === &apos;&apos;) {
            success.fire();
            return true;
        }
        if (!$.validation.constants.url.test(value.toLowerCase())) {
            fail.fire(&apos;请输入正确的网址！如http://www.baidu.com&apos;);
            return false;
        }
        success.fire();
        return true;
    },
    &apos;email&apos;: function (condition, success, fail) {
        var value = this.val();
        if (value === &apos;&apos;) {
            success.fire();
            return true;
        }
        if (!$.validation.constants.email.test(value)) {
            fail.fire(&apos;电子邮箱格式错误，请检查后重新输入！&apos;);
            return false;
        }
        success.fire();
        return true;
    },
    &apos;telephone&apos;: function (condition, success, fail) {
        var value = this.val();
        if (value === &apos;&apos;) {
            success.fire();
            return true;
        }
        if (!$.validation.constants.telephone.test(value)) {
            fail.fire(&apos;电话号码输入有误，请检查后重新输入！！&apos;);
            return false;
        }
        success.fire();
        return true;
    },
    &apos;shenfenzheng&apos;: function (condition, success, fail) {
        var value = this.val();
        if (value === &apos;&apos;) {
            success.fire();
            return true;
        }
        value = value.toLowerCase();
        if ($.validation.constants.shenfenzheng.test(value)) {
            var numbers = value.toLowerCase().split(&apos;&apos;);
            // 验证地区
            var aCity = {
                11: &apos;北京&apos;,
                12: &apos;天津&apos;,
                13: &apos;河北&apos;,
                14: &apos;山西&apos;,
                15: &apos;内蒙古&apos;,
                21: &apos;辽宁&apos;,
                22: &apos;吉林&apos;,
                23: &apos;黑龙江&apos;,
                31: &apos;上海&apos;,
                32: &apos;江苏&apos;,
                33: &apos;浙江&apos;,
                34: &apos;安徽&apos;,
                35: &apos;福建&apos;,
                36: &apos;江西&apos;,
                37: &apos;山东&apos;,
                41: &apos;河南&apos;,
                42: &apos;湖北&apos;,
                43: &apos;湖南&apos;,
                44: &apos;广东&apos;,
                45: &apos;广西&apos;,
                46: &apos;海南&apos;,
                50: &apos;重庆&apos;,
                51: &apos;四川&apos;,
                52: &apos;贵州&apos;,
                53: &apos;云南&apos;,
                54: &apos;西藏&apos;,
                61: &apos;陕西&apos;,
                62: &apos;甘肃&apos;,
                63: &apos;青海&apos;,
                64: &apos;宁夏&apos;,
                65: &apos;新疆&apos;,
                71: &apos;台湾&apos;,
                81: &apos;香港&apos;,
                82: &apos;澳门&apos;,
                91: &apos;国外&apos;
            };
            if (!aCity[numbers[0] + numbers[1]]) {
                fail.fire(&apos;身份证格式有误，请检查后重新输入！&apos;);
                return false;
            }
            var wi = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
            var check = [&apos;1&apos;, &apos;0&apos;, &apos;x&apos;, &apos;9&apos;, &apos;8&apos;, &apos;7&apos;, &apos;6&apos;, &apos;5&apos;, &apos;4&apos;, &apos;3&apos;, &apos;2&apos;];
            var _sum = 0;
            for (var i = 0; i &amp;lt; 17; i++) {
                _sum += +numbers[i] * +wi[i];
            }
            if (numbers[17] != check[_sum % 11]) {
                fail.fire(&apos;身份证格式有误，请检查后重新输入！&apos;);
                return false;
            }
            success.fire();
            return true;
        }
        else {
            fail.fire(&apos;请输入18位身份证！&apos;);
            return false;
        }
    },
    &apos;taibaozheng&apos;: function (condition, success, fail) {
        var value = this.val();
        if (value === &apos;&apos;) {
            success.fire();
            return true;
        }
        if (!$.validation.constants.taibaozheng.test(value)) {
            fail.fire(&apos;台胞证格式有误，请检查后重新输入！&apos;);
            return false;
        }
        success.fire();
        return true;
    },
    &apos;zhizhao&apos;: function (condition, success, fail) {
        var value = this.val();
        if (value === &apos;&apos;) {
            success.fire();
            return true;
        }
        if ($.validation.constants.zhizhao.test(value)) {
            var p = 10;
            var s;
            var a;
            var numbers = value.split(&apos;&apos;);
            for (var i = 0; i &amp;lt; 15; i++) {
                a = +numbers[i];
                s = (p % 11) + a;
                p = (s % 10) * 2;
                if (p === 0) {
                    p = 20;
                }
            }
            if (s % 10 !== 1) {
                fail.fire(&apos;工商营业执照输入有误，请检查后重新输入！&apos;);
                return false;
            }
            success.fire();
            return true;
        }
        else {
            fail.fire(&apos;请输入15位工商营业执照！&apos;);
            return false;
        }
    }
};&lt;/pre&gt;
&lt;h2&gt;添加验证规则&lt;/h2&gt;
&lt;p&gt;说好的支持自定义验证规则呢？放心，不会少的，而且超简单：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true &quot;&gt;$.validation = function (condition, process) {
    $.validation.strategy[condition] = process;
};&lt;/pre&gt;
&lt;p&gt; 加个静态方法搞定。&lt;/p&gt;
&lt;h2&gt;手动发起验证&lt;/h2&gt;
&lt;p&gt;有些场景下需要手动check一下表单内容才放心吧：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true &quot;&gt;$.fn.exec = function () {
    return this.each(function () {
        var $this = $(this);
        if (!$this.is(&apos;:input&apos;)) {
            $this = $this.find(&apos;:input&apos;);
        }
        $this.blur();
    });
};&lt;/pre&gt;
&lt;p&gt; 原理很简单，对:input子元素触发一次blur事件。&lt;/p&gt;
&lt;h2&gt;还有一些是我没有做的&lt;/h2&gt;
&lt;p&gt;都不是很复杂，因为我的业务场景不关注这些，所以就懒过去了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;没做通用的ajax验证
现在对于ajax的验证，可以这样做：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true &quot;&gt;$.validation(&apos;ajax_xx&apos;,function(c, s, f) {
$.post(&apos;some_url&apos;,function(data){
    if (data.success) {
        s.fire();
    }else{
        f.fire(&apos;xxxxxxxx&apos;);
    }
});
});&lt;/pre&gt;
&lt;p&gt; 表单提交前，除了检查有没有.has-error的元素找到填写出错项，还要检查有没有.wait元素，如果有的话都不能立刻提交。
如果要有一个通用的ajax验证机制，可以自行扩展&lt;em&gt;$.validation&lt;/em&gt;方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没做验证失败时表单提交阻断
正如上一条中说的，表单提交前，需要检查.has-error和.wait元素，可以自行扩展&lt;em&gt;$.fn.validation&lt;/em&gt;方法，添加form的submit事件绑定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有为handle验证状态的dom操作提供接口
不想做，bootstrap挺好的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有测试用例
不打算给这些代码添加逻辑了，不想写测试用例。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;下载&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.zhouhua.info/wp-content/uploads/2015/04/validation.js&quot;&gt;validation.js&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[巧妙判断一个单词是否有重复字母]]></title><description><![CDATA[今天上午刷到一道题，大体是写一个方法判断一个单词中是否有重复的字母（或者说一个字符串中是否有重复的字符）。我的思路是一个字符一个字符地遍历，如果发现有重复的停止： 这种简单的场景下谈性能没什么意义，两次循环速度并不慢（  也认为是一次循环，但由于是native…]]></description><link>https://www.zhouhua.info//2015/isisogram/</link><guid isPermaLink="false">https://www.zhouhua.info//2015/isisogram/</guid><pubDate>Tue, 07 Apr 2015 15:10:10 GMT</pubDate><content:encoded>&lt;p&gt;今天上午刷到一道题，大体是写一个方法判断一个单词中是否有重复的字母（或者说一个字符串中是否有重复的字符）。我的思路是一个字符一个字符地遍历，如果发现有重复的停止：&lt;/p&gt;&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;function isIsogram(str) {
  str = str.toLowerCase();

  for (var i = 0; i &amp;lt; str.length; i++) {
    if (str.indexOf(str.charAt(i), i + 1) &amp;gt;= 0) {
      return false;
    }
  }

  return true;
}&lt;/pre&gt;
&lt;p&gt;这种简单的场景下谈性能没什么意义，两次循环速度并不慢（&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;str.indexOf()&lt;/pre&gt;
&lt;p&gt; 也认为是一次循环，但由于是native的行为，速度很快）。&lt;/p&gt;
&lt;p&gt;后来我看到了别的用正则的实现，虽然很简单，但一开始我确实没住这方面想：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true &quot;&gt;function isIsogram2(str) {
  return !/(.).*\1/i.test(str);
}&lt;/pre&gt;
&lt;p&gt; 或者：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true &quot;&gt;function isIsogram2(str) {
  return !/^.*(.).*\1/i.test(str);
}&lt;/pre&gt;
&lt;p&gt; 这两个其实没什么区别，前者优先查找字符串尾端，后者优先查找字符串前端。这个正则比较好理解，不多解释，比较让我惊讶的这个匹配的性能。因为判断一个字符串是否有重复字符这样的任务太简单，正因为太简单，所以代表目标字符串的规律性太小。如果用正则必然带来大量尝试和回溯，其实主观上会让人觉得性能很不好。不过好不好不是随便想一想就行的，还是要验证一下。决定性能到底是好是坏，当然看最坏情况下，两个算法的执行时间。构造这样一个单词：&lt;em&gt;qwertyuiopas&lt;/em&gt;，没有字母重复，意味着两种算法都要跑完整的循环。&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;console.time(&quot;loop&quot;);
for(var i=0; i&amp;lt;400000; i++){
    isIsogram(&quot;qwertyuiopas&quot;);
}
console.timeEnd(&quot;loop&quot;);

console.time(&quot;regexp&quot;);
for(var i=0; i&amp;lt;400000; i++){
    isIsogram2(&quot;qwertyuiopas&quot;);
}
console.timeEnd(&quot;regexp&quot;);&lt;/pre&gt;
&lt;p&gt; 看看运行结果：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.zhouhua.info/wp-content/uploads/2015/04/QQ20150407160509.png&quot;&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/04/QQ20150407160509.png&quot; alt=&quot;QQ20150407160509&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;amazing! 这个实验证实了一个问题：javascript对正则确实有优化，使用正则的效率非常高。当然这句话也可以反过来理解，javascript中的字符串操作、循环太慢了。那么，对于正则还等什么呢，赶快用起来吧。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[聊聊rel=noreferrer的事]]></title><description><![CDATA[背景 在一个页面A中，点击一个链接，浏览器会跳转到页面B。那么如何描述A和B的关系呢？我们把A定义为B的refer/referrer/referer（由于历史的原因，你看到上面这几个词都可以认为是同一个意思，下面统一描述为referrer）。通俗地说，A是B…]]></description><link>https://www.zhouhua.info//2015/noreferrer/</link><guid isPermaLink="false">https://www.zhouhua.info//2015/noreferrer/</guid><pubDate>Tue, 31 Mar 2015 17:47:49 GMT</pubDate><content:encoded>&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;在一个页面A中，点击一个链接，浏览器会跳转到页面B。那么如何描述A和B的关系呢？我们把A定义为B的refer/referrer/referer（由于历史的原因，你看到上面这几个词都可以认为是同一个意思，下面统一描述为referrer）。通俗地说，A是B的来源页面/引荐页面。从技术实现上，你从浏览器起发出的任何请求（不准确，先这么理解吧），例如打开新页面、请求静态资源、ajax、请求后端api等等，都会在请求头部添加&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;Referer&lt;/pre&gt;
&lt;p&gt; 字段。也许你会发现这个词拼错了，少了个r，但你不可以把它当成错误，虽然最初确实是个错误，但由于在它成为http事实标准前，没有人去纠正这个错误，于是就形成了现在局面。看看具体的例子，在百度上搜索QQ，然后打开腾讯的页面，我们看看它的请求头是什么样的：&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/03/20150330201952.png&quot; alt=&quot;20150330201952&quot;&gt;&lt;/p&gt;&lt;/p&gt;
&lt;p&gt;也可以通过&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;document.referrer&lt;/pre&gt;
&lt;p&gt; 来获取当前页面的referrer地址。&lt;/p&gt;
&lt;p&gt;这个referrer常常被人忽视，但其实用处还是很大的。比如通过referer，我们能知道网站的流量从何而来，从而可以更有针对性的做SEO；我们能知道后端提供的api是否被自己站点以外的页面调用（referrer可以伪造，这种判断方式并不安全）；我们能够知道静态资源是否被他们盗用（图片防盗链的原理）等等。&lt;/p&gt;
&lt;p&gt;其实referrer这个东西，我们从来都不用担心不会用它，因为浏览器已经帮你实现得好好的。那我们今天要聊什么呢？聊如何干掉这个玩意儿。&lt;/p&gt;
&lt;h2&gt;起因&lt;/h2&gt;
&lt;p&gt;有这个需求是因为工作中有一些页面需要跳转到某网站（新开页面），但这个网站链接链过去会报400错误，如下图。从浏览器输入地址，则没有问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/03/20150330204257.png&quot; alt=&quot;20150330204257&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果链接链过去的时候不带referrer信息，则网页能够正常打开。&lt;/p&gt;
&lt;p&gt;那该如何是好呢？&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;到网上搜索了一下，打开网页而不带referrer信息，大概有以下几种方式：&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;从https跳转到http页面&lt;/dt&gt;
&lt;dd&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;受浏览器实现制约，不确定因素很大&lt;/span&gt;&lt;/dd&gt;
&lt;dt&gt;直接在浏览器中输入url&lt;/dt&gt;
&lt;dd&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;浏览器行为，不可控&lt;/span&gt;&lt;/dd&gt;
&lt;dt&gt;点击浏览器“主页”或者从收藏夹访问&lt;/dt&gt;
&lt;dd&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;浏览器行为，不可控&lt;/span&gt;&lt;/dd&gt;
&lt;dt&gt;使用location.replace()或修改location.href&lt;/dt&gt;
&lt;dd&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;待验证&lt;/span&gt;&lt;/dd&gt;
&lt;dt&gt;使用window.open()打开页面&lt;/dt&gt;
&lt;dd&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;不靠谱&lt;/span&gt;&lt;/dd&gt;
&lt;dt&gt;使用服务器中转一下，302到目标页面&lt;/dt&gt;
&lt;dd&gt;&lt;span style=&quot;color: #008000;&quot;&gt;可行，但麻烦&lt;/span&gt;&lt;/dd&gt;
&lt;dt&gt;使用&amp;lt;mete http-equiv=&quot;refresh&quot;&amp;gt;转向&lt;/dt&gt;
&lt;dd&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;待验证&lt;/span&gt;&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;上面标红字的方式直接放弃了。由于我的首要需求是在新窗口打开页面，所以其他的方式也没给我什么启示。不过打开新窗口还是给我一些启发。我们可以打开一个空页面，再由这个空页面跳转到目标页面。由于空页面没有url，所以目标页面也就不存在referrer。于是方法一到方法四诞生了：&lt;/p&gt;
&lt;h2&gt;方法一：&lt;/h2&gt;
&lt;p&gt;使用window.open新开页面，并插入一段javascript，用来重定向到目标页面：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;var url = &quot;http://www.baidu.com/&quot;
window.open(&apos;javascript:window.name;&apos;, &apos;&amp;lt;script&amp;gt;location.replace(&quot;&apos;+url+&apos;&quot;)&amp;lt;\/script&amp;gt;&apos;);&lt;/pre&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;**chrome**&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;**firefox**&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;**≥ IE10**&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;**≤ IE9**&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;[icon name=&quot;check-circle&quot; class=&quot;fa-2x&quot;]&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;[icon name=&quot;minus-circle&quot; class=&quot;fa-2x&quot;]&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;[icon name=&quot;minus-circle&quot; class=&quot;fa-2x&quot;]&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;[icon name=&quot;times-circle&quot; class=&quot;fa-2x&quot;]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt; chrome中一切正常；firefox和IE10、11能跳转，但referrer还是传递过去了；IE9及更低版本IE则无法跳转。&lt;/p&gt;
&lt;h2&gt;方法二：&lt;/h2&gt;
&lt;p&gt;通过指定data:text/html来强制浏览器打开一个指定空页面：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;var url = &quot;http://www.baidu.com/&quot;
window.open(&apos;data:text/html,&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;script&amp;gt;location.replace(&quot;&apos; + url + &apos;&quot;)&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&apos;);&lt;/pre&gt;
&lt;p&gt;当然也可以直接写在a标签的href属性里。&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;**chrome**&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;**firefox**&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;**IE**&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;[icon name=&quot;check-circle&quot; class=&quot;fa-2x&quot;]&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;[icon name=&quot;minus-circle&quot; class=&quot;fa-2x&quot;]&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;[icon name=&quot;times-circle&quot; class=&quot;fa-2x&quot;]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt; chrome中一切正常；firefox能跳转，但referrer还是传递过去了；IE9则无法跳转。&lt;/p&gt;
&lt;h2&gt;方法三：&lt;/h2&gt;
&lt;p&gt;类似于&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;href=&quot;javascript:void(0);&quot;&lt;/pre&gt;
&lt;p&gt; ，一段javascript也是能够当成页面打开的。于是有：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;var url = &quot;http://www.baidu.com/&quot;
window.open(&apos;javascript:location.replace(&quot;&apos; + url + &apos;&quot;)&apos;);&lt;/pre&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;**chrome**&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;**firefox**&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;**IE**&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;[icon name=&quot;check-circle&quot; class=&quot;fa-2x&quot;]&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;[icon name=&quot;minus-circle&quot; class=&quot;fa-2x&quot;]&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;[icon name=&quot;minus-circle&quot; class=&quot;fa-2x&quot;]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt; chrome中一切正常；firefox的IE能跳转，但referrer还是传递过去了。&lt;/p&gt;
&lt;h2&gt;方法四：&lt;/h2&gt;
&lt;p&gt;类似方法二，也是新打开一个页面，不过不是通过javascript跳转，而是通过&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;&amp;lt;mete http-equiv=&quot;refresh&quot;&amp;gt;&lt;/pre&gt;
&lt;p&gt; 跳转：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;var url = &quot;http://www.baidu.com/&quot;
window.open(&apos;data:text/html,&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;meta http-equiv=&quot;Refresh&quot; content=&quot;0;&apos; + url + &apos;&quot;/&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&apos;);&lt;/pre&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;**chrome**&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;**firefox**&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;**IE**&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;[icon name=&quot;check-circle&quot; class=&quot;fa-2x&quot;]&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;[icon name=&quot;check-circle&quot; class=&quot;fa-2x&quot;]&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;[icon name=&quot;times-circle&quot; class=&quot;fa-2x&quot;]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt; chrome和firefox中一切正常；IE不能跳转。&lt;/p&gt;
&lt;p&gt;目前为止，所有方法在IE面前都跪了。不过参照firefox唯一成功过的那次，我们不妨对方法一和方法四来个合体：&lt;/p&gt;
&lt;h2&gt;方法五：&lt;/h2&gt;
&lt;p&gt;综合方法一和方法四，用&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;window.open()&lt;/pre&gt;
&lt;p&gt; 新打开一个页面，不过不是通过javascript跳转，而是通过&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;&amp;lt;mete http-equiv=&quot;refresh&quot;&amp;gt;&lt;/pre&gt;
&lt;p&gt; 跳转：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;var url = &quot;http://www.baidu.com/&quot;;
var win = window.open(null, &apos;_blank&apos;);
var doc = win.document;
doc.clear();
doc.write(&apos;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;meta http-equiv=&quot;Refresh&quot; content=&quot;0; URL=&apos; + url + &apos;&quot;/&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&apos;);
doc.close();&lt;/pre&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;**chrome**&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;**firefox**&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;**IE**&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;[icon name=&quot;minus-circle&quot; class=&quot;fa-2x&quot;]&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;[icon name=&quot;check-circle&quot; class=&quot;fa-2x&quot;]&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;[icon name=&quot;check-circle&quot; class=&quot;fa-2x&quot;]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt; 这次chrome跳转是依然携带referrer信息，而firefox和IE中一切正常。&lt;/p&gt;
&lt;p&gt;这五种方式都是试图通过javascript构造一个假的空页面，然后再改变页面url实现的。但兼容性却不怎么好。其实呢，兼容性的问题主要出在构建一个假页面的时候，各个浏览器的实现差异太大。那如果不构建假页面，而是真的有这么一个空页面呢（谢谢国耀的思路和实现）？我们再来试试：&lt;/p&gt;
&lt;h2&gt;方法六：&lt;/h2&gt;
&lt;p&gt;先来创建一个空页面，假设是bridge.html：&lt;/p&gt;
&lt;pre class=&quot;lang:xhtml decode:true&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head lang=&quot;en&quot;&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;script&amp;gt;
    var url = location.search.replace(&apos;?url=&apos;, &apos;&apos;);
    location.replace(decodeURI(url));
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/pre&gt;
&lt;p&gt;要跳转到目标页面，先跳转到bridge.html：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;var url = &quot;http://baidu.com&quot;;
window.open(&apos;bridge.html?url=&apos; + encodeUri(url));&lt;/pre&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;**chrome**&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;**firefox**&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;**IE**&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;[icon name=&quot;check-circle&quot; class=&quot;fa-2x&quot;]&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;[icon name=&quot;check-circle&quot; class=&quot;fa-2x&quot;]&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;[icon name=&quot;check-circle&quot; class=&quot;fa-2x&quot;]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt; 这个方法在几个浏览器中都有不错的表现。不足的是它需要额外添加一个文件，跟服务器的路由、rewrite规则相关，有一定的潜在额外工作需要做。&lt;/p&gt;
&lt;p&gt;说了这么多，其实我们要做的事情，html5中已经规定过了，那就是使用rel=“noreferrer”。&lt;/p&gt;
&lt;h2&gt;方法七：&lt;/h2&gt;
&lt;p&gt;这是最简易直观的实现方式，如果一个a标签设置了rel=“noreferrer”，那么就表示点击这个链接时不要传递referrer信息。（注意，这个html5标准中和referrer是正确的拼法）&lt;/p&gt;
&lt;pre class=&quot;lang:xhtml decode:true&quot;&gt;&amp;lt;a href=&quot;http://baidu.com&quot; target=&quot;_blank&quot; rel=&quot;noreferrer&quot;&amp;gt;跳转&amp;lt;/a&amp;gt;&lt;/pre&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;**chrome**&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;**firefox**&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;**IE**&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;[icon name=&quot;check-circle&quot; class=&quot;fa-2x&quot;]&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;[icon name=&quot;check-circle&quot; class=&quot;fa-2x&quot;]&lt;/td&gt;
&lt;td style=&quot;text-align: center; vertical-align: middle;&quot;&gt;[icon name=&quot;minus-circle&quot; class=&quot;fa-2x&quot;]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt; chrome和firefox中一切正常；IE不理会rel属性。既然是h5的属性值，存在兼容性问题也是意料之中，不过IE11还不支持我也是醉了。&lt;/p&gt;
&lt;h2&gt;方法八：&lt;/h2&gt;
&lt;p&gt;上面我们曾提及可以通过后端服务转发请求，实现referrer的隐藏。实现原理很简单，服务器是能够控制请求header字段的。当然，最好的情况是不需要我们自己写这样一个中转服务。&lt;/p&gt;
&lt;p&gt;有两个公共的页面可以帮助我们完成这一工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;google&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;var url = &quot;http://www.baidu.com&quot;;
window.open(&apos;http://www.google.com/url?q=&apos; + encodeURIComponent(url));&lt;/pre&gt;
&lt;p&gt; 2. &lt;a href=&quot;http://www.no-referer.de&quot;&gt;http://www.no-referer.de&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true &quot;&gt;var url = &quot;http://www.baidu.com&quot;;
window.open(&apos;http://www.no-referer.de/&apos; + url);&lt;/pre&gt;
&lt;p&gt; 国内google不能正常访问，可以试试下面那个服务。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;如果我们想不添加其他辅助页面，实现不带referrer的跳转，可以选择的方式很多，很多方法有着兼容性的问题。对于特定浏览器，有多种方法可选时，我们也应该保证以性能最好的方式跳转。不过不要担心，已经有人封装了这个兼容问题：&lt;a href=&quot;https://github.com/knu/noreferrer&quot;&gt;noreferrer.js&lt;/a&gt;。使用这个jquery库，你只需要给a标签使用rel=“noreferrer”就可以了，兼容问题全交给它了。当然，其内部实现离不开上文我们探讨的几种方法。&lt;/p&gt;
&lt;p&gt;但是这个类库存在几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不支持jquery 1.8+版本（依赖$.browser的缘故）；&lt;/li&gt;
&lt;li&gt;不支持IE 11（IE 11由于userAgent发生变化，老版本jquery不会把它认为是msie）；&lt;/li&gt;
&lt;li&gt;google的跳转在国内无法使用；&lt;/li&gt;
&lt;li&gt;不支持动态创建的a标签，或者ajax请求回来的html片断中的a标签&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;针对这几个问题，我做了小修改，需要的可以下载使用。&lt;a href=&quot;http://zhouhua.qiniudn.com//wp-content/uploads/2015/03/zh_noreferrer.js&quot;&gt;下载新的noreferrer.js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个版本无脑地把$.browser的代码重新跑了一遍，添加了对IE 11的识别。把google的地址替换成no-referer.de。最重要的是添加$.noreferrerReg()方法，动态创建a标签后可以运行一下。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[判断回文字符串的新方法]]></title><description><![CDATA[当年去携程面试时，刘大师问了一个判断回文字符串（类似于123454321）的方法，我是有备而来，刷刷就写了：  So easy。不过刘大师不喜欢这种geek范的东西，只好老老实实又写了一份循环版的……C…]]></description><link>https://www.zhouhua.info//2015/palindromic/</link><guid isPermaLink="false">https://www.zhouhua.info//2015/palindromic/</guid><pubDate>Thu, 26 Mar 2015 15:14:04 GMT</pubDate><content:encoded>&lt;p&gt;当年去携程面试时，刘大师问了一个判断回文字符串（类似于123454321）的方法，我是有备而来，刷刷就写了：&lt;/p&gt;&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true &quot;&gt;function test(str) {
    return str.split(&apos;&apos;).reverse().join(&apos;&apos;) === str;
}&lt;/pre&gt;
&lt;p&gt; So easy。不过刘大师不喜欢这种geek范的东西，只好老老实实又写了一份循环版的……C++语言的……伪代码。还好当年不是技术面。&lt;/p&gt;
&lt;p&gt;不过今天呢，我要尝试用第三种方法，当然必须是javascript，来解决这个问题！&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;function test(str) {
    var length = str.length;
    var regArrCenter = length % 2 === 0 ? [] : [&apos;.&apos;];
    var regArrLeft = [&apos;^&apos;];
    var regArrRight = [&apos;$&apos;];
    for (var i = 1; i &amp;lt;= length / 2; i++) {
        regArrLeft.push(&apos;(.)&apos;);
        regArrRight.unshift(&apos;\\&apos; + i);
    }
    var regStr = regArrLeft.concat(regArrCenter, regArrRight).join(&apos;&apos;);
    var reg = new RegExp(regStr);
    return reg.test(str);
}&lt;/pre&gt;
&lt;p&gt;这个方法是通过回文字符串规律，构造正则表达式完成的，这个思路还是比较偏的。怎么说呢，有规律的地方就有正则。性能没考虑，估计跟循环法差不多，慢于数组操作。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[更优雅地绘制阴影]]></title><description><![CDATA[Box-shadow虽然是一个css3的属性，但由于浏览器支持不错，且用它来营造一种立体感、层次感着实方便，这让它成为了互联网上随处可见的css…]]></description><link>https://www.zhouhua.info//2015/shadow/</link><guid isPermaLink="false">https://www.zhouhua.info//2015/shadow/</guid><pubDate>Tue, 24 Mar 2015 18:12:43 GMT</pubDate><content:encoded>&lt;p&gt;Box-shadow虽然是一个css3的属性，但由于浏览器支持不错，且用它来营造一种立体感、层次感着实方便，这让它成为了互联网上随处可见的css3特效。不过我感觉想写好阴影不是一件容易的事情。至少我常常摸索半天，写出来的阴影却总让人很难受。 上周在知乎上看到了一个问答，很受启发：&lt;a href=&quot;http://www.zhihu.com/question/28865209&quot;&gt;如何理解 Material Design 中卡片的两层阴影&lt;/a&gt;，于是特意去看了Meterial Design的设计准则（&lt;a href=&quot;http://design.1sters.com/material_design/layout/layout-principles.html&quot;&gt;中文翻译&lt;/a&gt;），觉得其中的一些设计思想和细节追求很值得我们去借签。&lt;/p&gt;
&lt;p&gt;本文标题是“更优雅地绘制阴影”，但其实我并不懂“优雅”是什么，只是觉得别人的做法比我的好，比我的优雅。那么就来看看别人是怎么理解阴影的。&lt;/p&gt;
&lt;p&gt;Meterial Design把App的部件、面板、模态框等都抽象成了卡片。对于一个个上面，除了有x/y轴坐标的定义，还增加了z轴。处于不同层级的卡片，有着相对独立的交互逻辑。可以说，卡片和层级就是一个app页面的交互隐喻。而层次的视觉定义就是通过阴影来完成。下面搬运两张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/03/layout-principles-dimensionality-shadows-01_large_mdpi.png&quot; alt=&quot;layout-principles-dimensionality-shadows-01_large_mdpi&quot;&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/03/layout-principles-dimensionality-shadows-08_large_mdpi.png&quot; alt=&quot;layout-principles-dimensionality-shadows-08_large_mdpi&quot;&gt;&lt;/p&gt;
&lt;p&gt;以上的阴影定义虽然是AI的格式，但很容易就能转换成前端的语言：&lt;/p&gt;
&lt;pre class=&quot;lang:css decode:true&quot;&gt;.z-index-1{
    box-shadow: 0 1px 1.5px rgba(0,0,0,0.12), 0 1px 1px rgba(0,0,0,0.24);
}
.z-index-2{
    box-shadow: 0 3px 3px 0 rgba(0,0,0,0.16), 0 3px 3px 0 rgba(0,0,0,0.23);
}
.z-index-3{
    box-shadow: 0 10px 10px rgba(0,0,0,0.19), 0 6px 3px rgba(0,0,0,0.23);
}
.z-index-4{
    box-shadow: 0 14px 14px rgba(0,0,0,0.25), 0 10px 5px rgba(0,0,0,0.22);
}
.z-index-5{
    box-shadow: 0 19px 19px rgba(0,0,0,0.30), 0 15px 6px rgba(0,0,0,0.22);
}&lt;/pre&gt;
&lt;p&gt;看看效果：&lt;/p&gt;
&lt;div class=&quot;box-container&quot;&gt;
&lt;div class=&quot;box z-index-1&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;box z-index-2&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;box z-index-3&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;box z-index-4&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;box z-index-5&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;嗯，确实比我自己实现的感觉要优雅。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;先插几句话，&lt;pre class=&quot;lang:css highlight:0 decode:1 inline:1 &quot; &gt;box-shadow&lt;/pre&gt; 属性很有意思，它允许有若干重属性值，效果是相互叠加。张鑫旭有一篇博客谈这个问题（&lt;a href=&quot;http://www.zhangxinxu.com/wordpress/2013/11/css-css3-box-shadow-%E7%9B%92%E9%98%B4%E5%BD%B1-%E5%9B%BE%E5%BD%A2%E7%94%9F%E6%88%90%E6%8A%80%E6%9C%AF/&quot;&gt;传送门&lt;/a&gt;），写得很好，大家可以参考一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样的阴影效果大家自行感受，我觉得不管怎么样，好过我自己编造、瞎调出来的。但为什么要使用双重阴影？官方解释是用两个光源来模拟现实场景，一个是关键光，一个是环境光，所以会产生两个阴影。另外&lt;a href=&quot;http://www.zhihu.com/question/28865209/answer/42385558&quot;&gt;@jordanfc迟方的回答&lt;/a&gt;很棒，但很多是结论性的东西，我们需要更多一点思考。&lt;/p&gt;
&lt;h2&gt;思考一：box-shadow绘制阴影时，参照光源到底是什么样子的？&lt;/h2&gt;
&lt;p&gt;先说明：本文重点探究外阴影的阴影浓度和blur参数之间的关系，认为光源距离物体的距离远大于物体尺寸，忽略spread参数。首先考虑在box-shadow中，阴影颜色允许有半透明色，例如rgba(0, 0, 0, 0.6)，这其实代表了存在了40%的均匀分布的环境光，这部分光我们可以不作考虑，因为它相当于常量，对整个阴影衰减的模型没有影响，同样，阴影的颜色也没有影响，可以不考虑。对于上面的阴影色彩，我们探究的是，阴影浓度是如何从0.6（仅仅定义了衰变的起点）到0的。&lt;/p&gt;
&lt;p&gt;在网页中，对一个元素定义阴影后，我们发现，这个元素各个方向上的阴影是相同的。这说明什么呢？如果一个人站在这个阴影里，我们在元素外面画一个框，框与元素边界的距离是固定的，那么这个人在这个框的任何一个地方，看到的光源面积是相等的。所以我们能得出一个结论，光源应该是一个面光源，且形状与元素的形状是匹配的。为什么说是匹配，因为除了元素是圆形外，其他形状，我还想象不出光源应该是什么样。有可能对于绝大多数情况，能产生box-shadow属性效果的光源，在现实生活中根本不存在。（Kidding me?）&lt;/p&gt;
&lt;h2&gt;思考二：如果这样的光源存在，更真实的阴影是什么样的&lt;/h2&gt;
&lt;p&gt;我们看一个物体的阴影，只会直观地感受阴影的形态是否合理，并不会逆推光源是否合理，因为现实中的光照情形太多复杂，有太多的不确定。那么如果上述的光源客观存在，那么阴影是什么样的呢？&lt;/p&gt;
&lt;p&gt;阴影的浓度和这个位置所能看到的光源面积反相关，这个应该不用解释。光源的形态不好确定，我们不妨降低一个维度，考虑一维情形下的规律：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/03/light.png&quot; alt=&quot;light&quot;&gt;&lt;/p&gt;
&lt;p&gt;假设阴影模糊半径为Blur，观察点距离物体的垂直投影边界为x（0&amp;#x3C;=x&amp;#x3C;=Blur），降维到一维情形下，光源长度为L，能照到观察点的光源长度为l，那么有：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/03/png.png&quot; alt=&quot;png&quot;&gt;&lt;/p&gt;
&lt;p&gt;推广到二维，假设光源面积为S，能照到观察点的光源面积为s，则有（不定积分，有一定的憶测成份）&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/03/p.png&quot; alt=&quot;p&quot;&gt;&lt;/p&gt;
&lt;p&gt;a、b、c为常数，S也是常数，所以简化一下：&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/03/simple.png&quot; alt=&quot;simple&quot;&gt;&lt;/p&gt;
&lt;p&gt;A、B为常数，A+B=1。当x=0时，s=0，这时阴影最浓，为0pacity；当x=Blur时，s=S，这时阴影消失。那么任意x时，阴影浓度o为：&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/03/pic1.png&quot; alt=&quot;pic1&quot;&gt;&lt;/p&gt;
&lt;p&gt;由以上两式，可以解出：&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/03/new_opacity.png&quot; alt=&quot;new_opacity&quot;&gt;我写到这里已经写不下去了，因为我算出来的结果跟@jordanfc迟方的回答中给出的图像是反的。贴上@jordanfc迟方的图：&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/03/b2a27b46cb71d4a86cd55ec3486e2e8b_b.png&quot; alt=&quot;b2a27b46cb71d4a86cd55ec3486e2e8b_b&quot;&gt;&lt;/p&gt;
&lt;p&gt;他给出的是一个凹函数图像，我解出来的是一个凸函数，我又对图像没什么研究，是我错了吗？不知道。不过他对于阴影叠加的解释应该是错的。&lt;/p&gt;
&lt;h2&gt;思考三：多重阴影怎么叠加&lt;/h2&gt;
&lt;p&gt;先看看@jordanfc迟方的理解：&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/03/QQ%E6%88%AA%E5%9B%BE20150324155612.png&quot; alt=&quot;QQ截图20150324155612&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/03/QQ%E6%88%AA%E5%9B%BE20150324155813.png&quot; alt=&quot;QQ截图20150324155813&quot;&gt;似乎能自圆其说，但是对吗？&lt;/p&gt;
&lt;p&gt;考虑两个阴影的叠加，我们混合的都是xx%的黑色，所以这种情况下，无需考虑rgb通道，只考虑alpha通道即可。在上一篇文章&lt;a href=&quot;http://www.zhouhua.info/2015/03/23/color/&quot;&gt;《带Alpha通道的色彩叠加问题》&lt;/a&gt;中，我们详细推导了透明度混合的方法，现在就用起来！&lt;/p&gt;
&lt;p&gt;在Meterial Design中的阴影加入y轴偏移，不妨先处理没有y轴偏移的情况。就以数据比较简单的z-depth-2来进行计算。首先分别写出两个阴影的衰变函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/03/O1.png&quot; alt=&quot;O1&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/03/O2.png&quot; alt=&quot;O2&quot;&gt;&lt;/p&gt;
&lt;p&gt;由 &lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/03/render-12.gif&quot; alt=&quot;render (1)&quot;&gt; 我们可以推导出：&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/03/o.png&quot; alt=&quot;o&quot;&gt;&lt;/p&gt;
&lt;p&gt;是一个凸函数，跟我推导的结果很类似。既然有方程了，不妨把图像画出来看看：&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/03/QQ%E6%88%AA%E5%9B%BE20150324165351.png&quot; alt=&quot;QQ截图20150324165351&quot;&gt;&lt;/p&gt;
&lt;p&gt;混合后有阴影曲线曲率很小，但看得出跟@jordanfc迟方所描述的完全不一样。我们可以简单验证一下。由于混合后的曲线曲率很小，可以忽略，我们就把这个二次曲线当成一条直线，方程为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/03/04.png&quot; alt=&quot;04&quot;&gt;&lt;/p&gt;
&lt;p&gt;翻译成css就是&lt;/p&gt;
&lt;pre class=&quot;lang:css decode:true &quot;&gt;box-shadow: 0 3px 3px 0 rgba(0,0,0,0.3532);&lt;/pre&gt;
&lt;p&gt; 对比看一下效果，能看出有差异吗？&lt;/p&gt;
&lt;div class=&quot;box-container&quot;&gt;
&lt;div class=&quot;box z-index-2&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;box z-index-2-single&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如果加上了x、y偏移效果会怎么样呢？其实很简单，只要把刚刚的O1(x)和O2(x)改成分段函数，这样计算混合阴影会复杂很多。最后就以z-depth=4的阴影图像给本文收个尾吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/03/QQ%E6%88%AA%E5%9B%BE20150324173902.png&quot; alt=&quot;QQ截图20150324173902&quot;&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[带Alpha通道的色彩叠加问题]]></title><description><![CDATA[css3的rgba色彩模式、png/gif图片的alpha通道、canvas的rgba色彩模式、css3的阴影、css3的opacity属性等等，这些应用在网页中，有意无意间，我们的页面多了许多半透明的效果。我们知道，在没有alpha…]]></description><link>https://www.zhouhua.info//2015/color/</link><guid isPermaLink="false">https://www.zhouhua.info//2015/color/</guid><pubDate>Mon, 23 Mar 2015 17:05:23 GMT</pubDate><content:encoded>&lt;p&gt;css3的rgba色彩模式、png/gif图片的alpha通道、canvas的rgba色彩模式、css3的阴影、css3的opacity属性等等，这些应用在网页中，有意无意间，我们的页面多了许多半透明的效果。我们知道，在没有alpha通道的情况下，两个颜色叠加，上层的颜色会直接覆盖下层的颜色，但有了alpha通道，一切就没有这么简单了。今天，我们就要探讨一下，网页中，&lt;em&gt;rgba(r&lt;sub&gt;1&lt;/sub&gt;, g&lt;sub&gt;1&lt;/sub&gt;, b&lt;sub&gt;1&lt;/sub&gt;, a&lt;sub&gt;1&lt;/sub&gt;) + rgba(r&lt;sub&gt;2&lt;/sub&gt;, g&lt;sub&gt;2&lt;/sub&gt;, b&lt;sub&gt;2&lt;/sub&gt;, a&lt;sub&gt;2&lt;/sub&gt;)&lt;/em&gt;会得到什么。&lt;/p&gt;
&lt;p&gt;为表述方便，不妨假设最后我们得到的色彩是&lt;em&gt;rgba(r, g, b, a)&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;先考虑透明度。一个色彩透明度&lt;em&gt;opacity&lt;/em&gt;介于0到1之间，&lt;em&gt;opacity=0&lt;/em&gt;表示完全透明，&lt;em&gt;opacity=1&lt;/em&gt;表示不透明。把要叠加上来的色彩想象成一块玻璃，如果这块玻璃的透明度是0.2，意味着它允许透过80%的光线，阻挡20%的光线。&lt;/p&gt;
&lt;p&gt;好，现在想象有两块玻璃，透明度分别是&lt;em&gt;a&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt;和&lt;em&gt;a&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt;，那么光线的通过率分别为&lt;em&gt;1-a&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt;和&lt;em&gt;1-a&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt;。所以可以认为，光线穿过第一块玻璃后，剩余&lt;em&gt;1-a&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt;；再通过第二块玻璃后，还有&lt;em&gt;(1-a1)(1-a&lt;sub&gt;2&lt;/sub&gt;)&lt;/em&gt;，这就是两块玻璃的综合透光率，相应的，透明度就是&lt;em&gt;1-(1-a&lt;sub&gt;1&lt;/sub&gt;)(1-a&lt;sub&gt;2&lt;/sub&gt;)&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;所以我们能得到第一个结论：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/03/render-11.gif&quot; alt=&quot;render (1)&quot;&gt;，即&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/03/render-12.gif&quot; alt=&quot;render (1)&quot;&gt;&lt;/p&gt;
&lt;p&gt;接下来考虑rgb各分量，它们的计算方法是一样的，我们仅以r通道为例，进行推导。还是想象一块半透明的玻璃，它本身是红色的，但由于它允许其他光线透过，所以玻璃本身的颜色会变淡。人们实际感受到的颜色，只是玻璃原本的颜色乘以透明度的结果。&lt;/p&gt;
&lt;p&gt;如果有两块玻璃呢，它们的红色浓度分别是&lt;em&gt;r&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt;和&lt;em&gt;r&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt;，透明度分别是&lt;em&gt;a&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt;和&lt;em&gt;a&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt;。那么第一块玻璃让人感受到的红色浓度为&lt;em&gt;r&lt;sub&gt;1&lt;/sub&gt;a&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt;，第二块玻璃让人感受到的红色浓度为&lt;em&gt;r&lt;sub&gt;2&lt;/sub&gt;a&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt;，第一块玻璃的红色色彩穿过第二块玻璃，并与第二块的红色叠加在一起的颜色浓度就是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/03/render-13.gif&quot; alt=&quot;render (1)&quot;&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们再把两块玻璃合起来，当成一块玻璃，这个整体的红色浓度为r，透明度为&lt;em&gt;a&lt;/em&gt;。这个&lt;em&gt;a&lt;/em&gt;我们之前已经推导过了，是&lt;em&gt;a&lt;sub&gt;1&lt;/sub&gt;+a&lt;sub&gt;2&lt;/sub&gt;-a&lt;sub&gt;1&lt;/sub&gt;a&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt;。那么，我们有：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/03/render-14.gif&quot; alt=&quot;render (1)&quot;&gt;&lt;/p&gt;
&lt;p&gt;由这两个等式，我们可以得出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/03/render-1.gif&quot; alt=&quot;render (1)&quot;&gt;&lt;/p&gt;
&lt;p&gt; g和b两个分量上也是如此，在此从略。从推导出来的等式上，我们能直接得出一个结论：颜色叠加的运算，不具备交换率、结合率，也就是说，叠加的顺序很重要。&lt;/p&gt;
&lt;p&gt;最后来验证一下吧：&lt;/p&gt;
&lt;h2&gt;canvas&lt;/h2&gt;
&lt;p&gt;rgba(235, 152, 80, 0.6)+rgba(234, 97, 124, 0.8)&lt;/p&gt;
&lt;div class=&quot;container-color&quot;&gt;
    &lt;canvas data-color=&quot;235,152,80,0.6&quot; width=&quot;200&quot; height=&quot;100&quot; class=&quot;leftSample&quot;&gt;&lt;/canvas&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-none&quot;&gt;&lt;code&gt;&lt;canvas data-color=&quot;234,97,124,0.8&quot; width=&quot;200&quot; height=&quot;100&quot; class=&quot;rightSample&quot;&gt;&lt;/canvas&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;rgba(234, 104, 118, 0.92)&lt;/p&gt;
&lt;div class=&quot;container-color&quot;&gt;
    &lt;canvas data-color=&quot;234,104,118,0.92&quot; width=&quot;300&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;
&lt;h2&gt;background&lt;/h2&gt;
&lt;p&gt;rgba(235, 152, 80, 0.6)+rgba(234, 97, 124, 0.8)&lt;/p&gt;
&lt;div class=&quot;container-color&quot;&gt;
&lt;div data-color=&quot;235,152,80,0.6&quot; width=&quot;200&quot; height=&quot;100&quot; class=&quot;leftSample backgroundSample&quot;&gt;&lt;/div&gt;
&lt;div data-color=&quot;234,97,124,0.8&quot; width=&quot;200&quot; height=&quot;100&quot; class=&quot;rightSample backgroundSample&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;rgba(234, 104, 118, 0.92)&lt;/p&gt;
&lt;div class=&quot;container-color&quot;&gt;
&lt;div data-color=&quot;234,104,118,0.92&quot; class=&quot;backgroundSample&quot;&gt;&lt;/div&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[在nodejs中使用多线程编程]]></title><description><![CDATA[在以前的博文 别说不可能，nodejs中实现sleep 中，我向大家介绍了nodejs addon的用法。今天的主题还是addon，继续挖掘c/c++的能力，弥补nodejs的弱点。 我曾多次提到过nodejs的性能问题。其实就语言本身而言，nodejs…]]></description><link>https://www.zhouhua.info//2015/thread/</link><guid isPermaLink="false">https://www.zhouhua.info//2015/thread/</guid><pubDate>Mon, 16 Mar 2015 15:29:53 GMT</pubDate><content:encoded>&lt;p&gt;在以前的博文&lt;a href=&quot;http://www.zhouhua.info/2015/03/04/sleep/&quot;&gt;别说不可能，nodejs中实现sleep&lt;/a&gt;中，我向大家介绍了nodejs addon的用法。今天的主题还是addon，继续挖掘c/c++的能力，弥补nodejs的弱点。&lt;/p&gt;&lt;/p&gt;
&lt;p&gt;我曾多次提到过nodejs的性能问题。其实就语言本身而言，nodejs的性能还是很高的，虽然不及大多部静态语言，但差距也并不大；相对其他动态语言而言，速度优势非常明显。但为什么我们常常说nodejs不能胜任CPU密集型场景呢？因为由于其单线程特性，对于CPU密集型场景，它并不能充分利用CPU。计算机科学中有一个著名的&lt;strong&gt;Amdahl定律&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/03/render.gif&quot; alt=&quot;render&quot;&gt;&lt;/p&gt;
&lt;p&gt;假设总工作量W，可以分解为两个部分：只能串行计算的&lt;em&gt;W&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt;和允许并行计算的&lt;em&gt;W&lt;sub&gt;p&lt;/sub&gt;&lt;/em&gt;。那么，在p个CPU并行计算的情况下，性能上能够带来&lt;em&gt;speedup&lt;/em&gt;倍的提升。Amdahl定律描述了并行能做到的和不能做到的。它是一种理想情况，实际情况会复杂得多。比如并发很可能会引起资源的争夺，需要增加各种锁，从而常常让并行处于等待状态；并发还会额外带来操作系统对线程调度切换的时间开销，增加&lt;em&gt;W&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt;。不过，当一项任务中，&lt;em&gt;W&lt;sub&gt;p&lt;/sub&gt;&lt;/em&gt;比&lt;em&gt;W&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt;大得多，并且有多个CPU核心可供使用时，并行带来的性能提升是相当可观的。&lt;/p&gt;
&lt;p&gt;好，回到nodejs上。我们设想一个计算场景：计算4000000内的质数数目。这个场景编程实现的时候，以除法运算为主，不涉及内存、对象等操作，理论上能够确保让nodejs以相对较快的速度运行，不会落后c太多，便于对比。&lt;/p&gt;
&lt;p&gt;javascript寻找质数的方法已经在&lt;a href=&quot;http://www.zhouhua.info/2015/02/25/zhishu&quot;&gt;这篇博客&lt;/a&gt;中提供了，直接抄过来：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot; title=&quot;javascript验证质数&quot;&gt;function zhishu_js(num) {
    if (num == 1) {
        return false;
    }
    if (num == 2) {
        return true;
    }
    for (var i = 2; i &amp;lt;= Math.sqrt(num); i++) {
        if (num % i == 0) {
            return false;
        }
    }
    return true;
}&lt;/pre&gt;
&lt;p&gt;再写一个c语言版本的：&lt;/p&gt;
&lt;pre class=&quot;lang:c decode:true&quot; title=&quot;c验证质数&quot;&gt;#include &amp;lt;math.h&amp;gt;

bool zhishu(int num){
    if (num == 1) {
        return false;
    }
    if (num == 2) {
        return true;
    }
    for (int i = 2; i &amp;lt;= sqrt(num); i++) {
        if (num % i == 0) {
            return false;
        }
    }
    return true;
};&lt;/pre&gt;
&lt;p&gt;在nodejs中，我们用一个从1到4000000的循环来检索质数；c语言中，我们设置若干个线程，定义count为4000000，每个线程做如下操作要：如果count大于0，则取出count的值，并计算是否为质数，同时将count减1。根据这个思路，javascript版本的很容易写：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;var count = 0;

for (j = 1; j &amp;lt; 4000000; j++) {
    if(zhishu(j)){
        count++;
    }
}&lt;/pre&gt;
&lt;p&gt;关键难点就是c语言的多线程编程。早期c/c++并没有考虑并行计算的需求，所以标准库中并没有提供多线程支持。而不同的操作系统通常实现也是有区别的。为了避免这种麻烦，我们采用pthread来处理线程。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sourceware.org/pthreads-win32/&quot;&gt;下载pthread最新版本&lt;/a&gt;。由于我对gyp不熟，link依赖lib搞了半天没搞定，最后我的方式是，直接把pthread的源代码放到了项目目录下，并在binding.gyp中把pthread.c添加到源代码列表中，在编译项目的时候把pthread也编译一次。修改后的binding.gyp是这样的：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true &quot; title=&quot;binding.gyp&quot;&gt;{
  &quot;targets&quot;: [
    {
      &quot;target_name&quot;: &quot;hello&quot;,
      &quot;sources&quot;: [ &quot;hello.cc&quot;,&quot;pthreads/pthread.c&quot; ],
      &quot;include_dirs&quot;: [
        &quot;&amp;lt;!(node -e \&quot;require(&apos;nan&apos;)\&quot;)&quot;,
        &quot;pthreads&quot;
      ],
      &quot;libraries&quot;: [&quot;Ws2_32.lib&quot;]
    }
  ]
}&lt;/pre&gt;
&lt;p&gt; 当然了，我这种方法很麻烦，如果你们只添加pthread中lib和include目录的引用，并且不出现依赖问题，那是最好的，就没有必要用我的方法来做。&lt;/p&gt;
&lt;p&gt;那么接下来就进入C/C++多线程的一切了，定义一个线程处理函数：&lt;/p&gt;
&lt;pre class=&quot;lang:c decode:true&quot; title=&quot;C语言线程的实现&quot;&gt;pthread_mutex_t lock;

void *thread_p(void *null){
    int num, x=0;
    do{
        pthread_mutex_lock(&amp;amp;lock);
        num=count--;
        pthread_mutex_unlock(&amp;amp;lock);
        if(num&amp;gt;0){
            if(zhishu(num))x++;
        }else{
            break;
        }
    }while(true);
    std::cout&amp;lt;&amp;lt;&apos; &apos;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&apos; &apos;;
    pthread_exit(NULL);
        return null;
}&lt;/pre&gt;
&lt;p&gt; 在线程与线程之间，对于&lt;em&gt;count&lt;/em&gt;这个变量是相互竞争的，我们需要确保同时只能有一个线程操作&lt;em&gt;count&lt;/em&gt;变量。我们通过&lt;/p&gt;
&lt;pre class=&quot;lang:c decode:1 inline:1 &quot; &gt;pthread_mutex_t lock;&lt;/pre&gt;
&lt;p&gt; 添加一个互斥锁。当执行&lt;/p&gt;
&lt;pre class=&quot;lang:c decode:1 inline:1 &quot; &gt;pthread_mutex_lock(&amp;amp;lock);&lt;/pre&gt;
&lt;p&gt; 时，线程检查lock锁的情况，如果已锁定，则等待、重复检查，阻塞后续代码运行；如果锁已释放，则锁定，并执行后续代码。相应的，&lt;/p&gt;
&lt;pre class=&quot;lang:c decode:1 inline:1 &quot; &gt;pthread_mutex_unlock(&amp;amp;lock);&lt;/pre&gt;
&lt;p&gt; 就是解除锁状态。&lt;/p&gt;
&lt;p&gt;由于编译器在编译的同时，进行编译优化，如果一个语句没有明确做什么事情，对其他语句的执行也没有影响时，会被编译器优化掉。在上面的代码中，我加入了统计质数数量的代码，如果不加的话，像这样的代码：&lt;/p&gt;
&lt;pre class=&quot;lang:c decode:true  &quot;&gt;for (int j = 0; j &amp;lt; 4000000; j++) {
    zhishu(j);
}&lt;/pre&gt;
&lt;p&gt; 是会直接被编译器跳过的，实际不会运行。&lt;/p&gt;
&lt;p&gt;添加addon的写法已经介绍过了，我们实现从javascript接收一个参数，表示线程数，然后在c中创建指定数量的线程完成质数检索。完整代码：&lt;/p&gt;
&lt;pre class=&quot;lang:c++ decode:true&quot; title=&quot;hello.cc&quot;&gt;#include &amp;lt;nan.h&amp;gt;
#include &amp;lt;math.h&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &quot;pthreads\pthread.h&quot;
#define MAX_THREAD 100
using namespace v8;

int count=4000000;
pthread_t tid[MAX_THREAD];
pthread_mutex_t lock;

void *thread_p(void *null){
    int num, x=0;
    do{
        pthread_mutex_lock(&amp;amp;lock);
        num=count--;
        pthread_mutex_unlock(&amp;amp;lock);
        if(num&amp;gt;0){
            if(zhishu(num))x++;
        }else{
            break;
        }
    }while(true);
    std::cout&amp;lt;&amp;lt;&apos; &apos;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&apos; &apos;;
    pthread_exit(NULL);
    return null;
}

NAN_METHOD(Zhishu){
    NanScope();
    pthread_mutex_init(&amp;amp;lock,NULL);
    double arg0=args[0]-&amp;gt;NumberValue();
    int c=0;
    for (int j = 0; j &amp;lt; arg0 &amp;amp;&amp;amp; j&amp;lt;MAX_THREAD; j++) {
        pthread_create(&amp;amp;tid[j],NULL,thread_p,NULL);
    }
    for (int j = 0; j &amp;lt; arg0 &amp;amp;&amp;amp; j&amp;lt;MAX_THREAD; j++) {
        pthread_join(tid[j],NULL);
    }
    NanReturnUndefined();
}

void Init(Handle&amp;lt;Object&amp;gt; exports){
    exports-&amp;gt;Set(NanSymbol(&quot;zhishu&quot;), FunctionTemplate::New(Zhishu)-&amp;gt;GetFunction());
}

NODE_MODULE(hello, Init);&lt;/pre&gt;
&lt;p&gt; phread&lt;em&gt;create可以创建线程，默认是joinable的，这个时候子线程受制于主线程；phread&lt;/em&gt;join阻塞住主线程，等待子线程join，直到子线程退出。如果子线程已退出，则phread&lt;em&gt;join不会做任何事。所以对所有的线程都执行thread&lt;/em&gt;join，可以保证所有的线程退出后才会例主线程继续进行。&lt;/p&gt;
&lt;p&gt;完善一下nodejs脚本：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot; title=&quot;index.js&quot;&gt;var zhishu_c=require(&apos;./build/Release/hello.node&apos;).zhishu;
function zhishu(num) {
    if (num == 1) {
        return false;
    }
    if (num == 2) {
        return true;
    }
    for (var i = 2; i &amp;lt;= Math.sqrt(num); i++) {
        if (num % i == 0) {
            return false;
        }
    }
    return true;
}

console.time(&quot;c&quot;);
    zhishu_c(100);
console.timeEnd(&quot;c&quot;);

console.time(&quot;js&quot;);
var count=0;
for (j = 1; j &amp;lt; 4000000; j++) {
    if(zhishu(j)){
        count++;
    }
}
console.log(count);
console.timeEnd(&quot;js&quot;);&lt;/pre&gt;
&lt;p&gt; 看一下测试结果：&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;线程数&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C/C++(ms)&lt;/td&gt;
&lt;td&gt;1935&lt;/td&gt;
&lt;td&gt;1242&lt;/td&gt;
&lt;td&gt;1041&lt;/td&gt;
&lt;td&gt;940&lt;/td&gt;
&lt;td&gt;1021&lt;/td&gt;
&lt;td&gt;1016&lt;/td&gt;
&lt;td&gt;1038&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Nodejs(ms)&lt;/td&gt;
&lt;td&gt;3494&lt;/td&gt;
&lt;td&gt;3132&lt;/td&gt;
&lt;td&gt;3136&lt;/td&gt;
&lt;td&gt;3232&lt;/td&gt;
&lt;td&gt;3203&lt;/td&gt;
&lt;td&gt;3469&lt;/td&gt;
&lt;td&gt;3360&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;提速度率&lt;/td&gt;
&lt;td&gt;181%&lt;/td&gt;
&lt;td&gt;252%&lt;/td&gt;
&lt;td&gt;302%&lt;/td&gt;
&lt;td&gt;344%&lt;/td&gt;
&lt;td&gt;314%&lt;/td&gt;
&lt;td&gt;341%&lt;/td&gt;
&lt;td&gt;324%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt; 单线程时，虽然C/C++的运行速度是nodejs的181%，但这个成绩我们认为在动态语言中，还是非常不错的。双线程时速度提升最明显，那是因为我的电脑是双核四线程CPU，这个时候已经可能在使用两个核心在进行处理。4线程时速度达到最大，此时应该是双核四线程能达到的极限，当线程再增加时，并不能再提升速度了。上述Amdahl定律中，&lt;em&gt;p&lt;/em&gt;已达上限4。再增加线程，会增加操作系统进程调度的时间，增加锁的时间，尽管同时也能增加对CPU时间的竞争，但总体而言，&lt;em&gt;W&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt;的增加更加明显，性能是下降的。如果在一台空闲的机器上做这个实验，数据应该会更好一点。&lt;/p&gt;
&lt;p&gt;从这个实验中，我们可以得出这样的结论，对于CPU密集型的运算，交给静态语言去做，效率会提高很多，如果计算中较多涉及内存、字符串、数组、递归等操作（以后再验证），性能提升更为惊人。同时，合理地利用多线程能有效地提高处理效率，但并不是线程越多越好，要根据机器的情况合理配置。&lt;/p&gt;
&lt;p&gt;对于nodejs本身，的确是不擅长处理CPU密集的任务，但有了本文的经验，我想，想克服这个障碍，并非什么不可能的事情。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[学写jquery缓动函数]]></title><description><![CDATA[问题引入：实现如下效果 两个方块的追逐效果，使用css3，实现起来没什么难度： 用到了css3的animate属性，不是很复杂。不过出于兼容性的考虑，我们决定使用jquery的animate方法来重新实现。 简单粗暴地多次使用$.animate…]]></description><link>https://www.zhouhua.info//2015/easing/</link><guid isPermaLink="false">https://www.zhouhua.info//2015/easing/</guid><pubDate>Tue, 10 Mar 2015 16:31:50 GMT</pubDate><content:encoded>&lt;p&gt;问题引入：实现如下效果&lt;/p&gt;
&lt;div id=&quot;container&quot;&gt;
&lt;div id=&quot;first&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;second&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;两个方块的追逐效果，使用css3，实现起来没什么难度：&lt;/p&gt;
&lt;pre class=&quot;lang:xhtml decode:true &quot; title=&quot;HTML结构&quot;&gt;&lt;div id=&quot;container&quot;&gt;
    &lt;div id=&quot;first&quot;&gt;&lt;/div&gt;
    &lt;div id=&quot;second&quot;&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/pre&gt;
&lt;pre class=&quot;lang:css decode:true&quot; title=&quot;CSS&quot;&gt;#container{
  position: relative;
  width: 320px;
  height: 320px;
  border:1px solid #ccc;
}

@-webkit-keyframes run{
  0% {
    left:0;
    top:0;
  }
  25% {
    left:220px;
    top:0;
  }
  50% {
    left:220px;
    top:220px;
  }
  75% {
    left:0;
    top:220px;
  }
  100% {
    left:0;
    top:0;
  }
}
@keyframes run{
  0% {
    left:0;
    top:0;
  }
  25% {
    left:220px;
    top:0;
  }
  50% {
    left:220px;
    top:220px;
  }
  75% {
    left:0;
    top:220px;
  }
  100% {
    left:0;
    top:0;
  }
}

#first{
  width: 100px;
  height: 100px;
  background: orange;
  position: absolute;
  -webkit-animation: run 1.6s 0.8s infinite;
  animation: run 1.6s 0.8s infinite;
}

#second{
  width: 100px;
  height: 100px;
  background: red;
  position: absolute;
  -webkit-animation: run 1.6s infinite;
  animation: run 1.6s infinite;
}&lt;/pre&gt;
&lt;p&gt;用到了css3的animate属性，不是很复杂。不过出于兼容性的考虑，我们决定使用jquery的animate方法来重新实现。&lt;/p&gt;
&lt;h2&gt;简单粗暴地多次使用$.animate&lt;/h2&gt;
&lt;p&gt;可以看到，每个方块的运动都可以分解成四步，每一步都是向一个方向运动。于是如果要用$.animate来实现，可以在一个循环里，依次调用四遍$.animate来实现：&lt;/p&gt;
&lt;pre class=&quot;lang:css decode:true &quot; title=&quot;CSS&quot; &gt;#container{
  position: relative;
  width: 320px;
  height: 320px;
  border:1px solid #ccc;
}

#first{
  width: 100px;
  height: 100px;
  background: orange;
  position: absolute;
  left: 0;
  top: 0;
}

#second{
  width: 100px;
  height: 100px;
  background: red;
  position: absolute;
  right:0;
  bottom:0;
}&lt;/pre&gt;
&lt;pre class=&quot;lang:js decode:true &quot; title=&quot;javascript&quot; &gt;    var $first=$(&apos;#first&apos;);
    var $second=$(&apos;#second&apos;);

    (function firstMove(){
        $first.animate({
            &quot;left&quot;:220,
            &quot;top&quot;: 0,
        },400,&quot;linear&quot;,function(){
            $first.animate({
                &quot;left&quot;:220,
                &quot;top&quot;:220
            },400,&quot;linear&quot;,function(){
                $first.animate({
                    &quot;left&quot;:0,
                    &quot;top&quot;:220
                },400,&quot;linear&quot;,function(){
                    $first.animate({
                        &quot;left&quot;:0,
                        &quot;top&quot;:0
                    },400,&quot;linear&quot;,function(){
                        firstMove();
                    });
                });
            });
        });
    })();

    (function secondMove(){
        $second.animate({
            &quot;right&quot;:220,
            &quot;bottom&quot;:0
        },400,&quot;linear&quot;,function(){
            $second.animate({
                &quot;right&quot;:220,
                &quot;bottom&quot;:220
            },400,&quot;linear&quot;,function(){
                $second.animate({
                    &quot;right&quot;:0,
                    &quot;bottom&quot;:220
                },400,&quot;linear&quot;,function(){
                    $second.animate({
                        &quot;right&quot;:0,
                        &quot;bottom&quot;:0
                    },400,&quot;linear&quot;,function(){
                        secondMove();
                    });
                });
            });
        });
    })();&lt;/pre&gt;
&lt;p&gt;这种实现简单粗暴。我写的这段代码回调链太深了，不好看。有比我更熟悉jquery的朋友不使用complete回调，而是直接$.animate().animate()这样的调用链，效果一样，代码会短很多。不过jquery代码美化优化什么的不是今天的重点。重点是什么？学习缓动函数。&lt;/p&gt;
&lt;h2&gt;缓动函数（animation easing）&lt;/h2&gt;
&lt;p&gt;缓动函数是用来描述动画效果，在jquery中，实现了两种，分别是&lt;/p&gt;
&lt;pre class=&quot;inline:true decode:1 &quot; &gt;linear&lt;/pre&gt;
&lt;p&gt;和&lt;/p&gt;
&lt;pre class=&quot;inline:true decode:1 &quot; &gt;swing&lt;/pre&gt;
&lt;p&gt;。&lt;/p&gt;
&lt;pre class=&quot;inline:true decode:1 &quot; &gt;linear&lt;/pre&gt;
&lt;p&gt;效果就是没有效果，动画速度是均匀的，呈线性变化。&lt;/p&gt;
&lt;pre class=&quot;inline:true decode:1 &quot; &gt;swing&lt;/pre&gt;
&lt;p&gt;呢，动画效果呈线慢-快-慢的变化。&lt;/p&gt;
&lt;pre class=&quot;inline:true decode:1 &quot; &gt;swing&lt;/pre&gt;
&lt;p&gt;也是$.animate的默认动画效果。&lt;/p&gt;
&lt;p&gt;或许仅仅这么说还是难以让人理解缓动函数在干什么，那就参考一下下面来自jquery ui的例子：&lt;/p&gt;
&lt;iframe style=&quot;width:100%;height:600px;&quot; src=&quot;http://jqueryui.com/resources/demos/effect/easing.html&quot; class=&quot;demo-frame&quot;&gt;&lt;/iframe&gt;
&lt;p&gt;或者参考&lt;a href=&quot;http://gsgd.co.uk/sandbox/jquery/easing/&quot;&gt;jquery easing plugin&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;回到jquery ui提供的各个缓动函数示意图上，对于任意一张示意图，横向表示时间，纵向表示动画变化量。当斜率越大时，表示此时动画速率越快。&lt;/p&gt;
&lt;p&gt;我们定义几个变量和常量来标记一下：动画起始变化量为&lt;em&gt;begin&lt;/em&gt;，为方便计算，定义为常数0；动画结束和起始时的变化差值（总变化量）&lt;em&gt;change&lt;/em&gt;，为方便计算，定义为常数1；动画持续时间&lt;em&gt;duration&lt;/em&gt;；动画已进行时间&lt;em&gt;currentTime&lt;/em&gt;；动画进行的进度&lt;em&gt;progress&lt;/em&gt;，它等同于&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;currentTime / duration&lt;/pre&gt;
&lt;p&gt;；当前变化量&lt;em&gt;eased&lt;/em&gt;，jquery中这样定义：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true &quot; title=&quot;easing定义&quot; &gt;eased = easingFunction(progress, currentTime, begin=0, change=1, duration);&lt;/pre&gt;
&lt;p&gt;从上面的效果中随便挑一个出来看看是如何实现的吧：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true &quot; title=&quot;easeOutBounce的实现&quot; &gt;function easeOutBounce(progress, currentTime, begin, change, duration) {
    if ((currentTime/=duration) &lt; (1/2.75)) {
        return change*(7.5625*currentTime*currentTime) + begin;
    } else if (currentTime &lt; (2/2.75)) {
        return change*(7.5625*(currentTime-=(1.5/2.75))*currentTime + .75) + begin;
    } else if (currentTime &lt; (2.5/2.75)) {
        return change*(7.5625*(currentTime-=(2.25/2.75))*currentTime + .9375) + begin;
    } else {
        return change*(7.5625*(currentTime-=(2.625/2.75))*currentTime + .984375) + begin;
    }
}&lt;/pre&gt;
&lt;p&gt;说到这儿，我想该插一点相关话题。熟悉css3的朋友会知道，css3的动画也有缓动函数，不过换了个名字，叫&lt;em&gt;timing function&lt;/em&gt;。在transition中是transition-timing-function，在animate里是animate-timing-function。主要支持的动画有ease、linear、ease-in、ease-out、ease-in-out等。那如果想要的动画不在浏览器默认支持的列表中怎么办？css3也是支持自定义timing-function的，不过不同于jquery的easing function，timing function并不是描述特定时间下的动画量，而是直接描述上面我们看到的曲线图。timing function允许使用三次贝塞尔曲线方程描述动画曲线。三次贝塞尔方程接受4个点的参数：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true &quot; title=&quot;三次贝塞尔方程&quot; &gt;cubic-bezier(P0, P1, P2, P3)&lt;/pre&gt;
&lt;p&gt;但在css的timing function场景下，P0点就是(0, 0)，P3点就是(1, 1)。于是变量就只剩下两个点的坐标，调用方式就变成了：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;cubic-bezier(P1x, P1y, P2x, P2y)&lt;/pre&gt;
&lt;p&gt;。在W3C的规范中，定义了这四个点的纵横坐标都需要在0和1之间，这也就意味着无论怎么变化，曲线上所有的点都必须在这个1*1的正方形内，对比上面jquery ui easing的曲线图，我们可以确认像elastic这类的效果，使用timing-function就无能为力了。&lt;/p&gt;
&lt;p&gt;想多了解一下css3的timing function，不妨到&lt;a href=&quot;http://cubic-bezier.com/&quot;&gt;这个网站&lt;/a&gt;上自己动手试验一下。&lt;/p&gt;
&lt;h2&gt;编写easing function&lt;/h2&gt;
&lt;p&gt;说了半天的timing function，终于又回到easing function上来了。自己动手写easing function，那自由度，无边无际。从上面的介绍中，我们往往会有这样一个错觉，progress=0时，eased=0；progress=1时，eased=1。timing function中，因为P0和P3是定死的，所以这条一定成立，但在easing function中，其实并没有这个限制。&lt;/p&gt;
&lt;p&gt;什么意思？以我们开篇的动画为例，我们看一个方块从左上角运动一圈的轨迹。先说水平方向上，progress&amp;#x3C;0.25时，left属性从0px变成220px；0.25&amp;#x3C;=progress&amp;#x3C;0.5时，left保持220px；0.5&amp;#x3C;=progress&amp;#x3C;0.75时，left属性从220px变成0px；0.75&amp;#x3C;=progress&amp;#x3C;1时，left保持0px。再看竖直方向上，progress&amp;#x3C;0.25时，top保持0px；0.25&amp;#x3C;=progress&amp;#x3C;0.5时，top从0px变成220px；0.5&amp;#x3C;=progress&amp;#x3C;0.75时，top保持220px；0.75&amp;#x3C;=progress&amp;#x3C;1时，top从220px变成0px。那么这个过程反映成easing function就是：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true &quot; title=&quot;自定义easing函数&quot; &gt;function horizontal(progress) {
    if (progress &amp;lt; 0.25) {
        return progress * 4;
    }
    else if (progress &amp;lt; 0.5) {
        return 1;
    }
    else if (progress &amp;lt; 0.75) {
        return (0.75 - progress) * 4;
    }
    return 0;
}
function vertical(progress) {
    if (progress &amp;lt; 0.25) {
        return 0;
    }
    else if (progress &amp;lt; 0.5) {
        return (progress - 0.25) * 4;
    }
    else if (progress &amp;lt; 0.75) {
        return 1;
    }
    return (1 - progress) * 4;
}&lt;/pre&gt;
&lt;p&gt;接下来扩展jquery的easing效果库：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true &quot; &gt;$.extend($.easing,
        {
            &quot;vertical&quot;: vertical,
            &quot;horizontal&quot;: horizontal
        });&lt;/pre&gt;
&lt;p&gt;在$.animate中就可以像linear或者swing那样使用了：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true &quot; &gt;(function firstMove(){
    $first.animate({
        &quot;left&quot;:220,
        &quot;top&quot;:220
    },{
        duration: 1600,
        specialEasing: {
            left: &apos;horizontal&apos;,
            top: &apos;vertical&apos;
        },
        complete: function() {
            firstMove();
        }
    });
})();
(function secondMove(){
    $second.animate({
        &quot;left&quot;:0,
        &quot;top&quot;:0
    },{
        duration: 1600,
        specialEasing: {
            left: &apos;horizontal&apos;,
            top: &apos;vertical&apos;
        },
        complete: function() {
            secondMove();
        }
    });
})();&lt;/pre&gt;
&lt;p&gt;我们通过specialEasing这个参数为水平方向和竖直方向指定了不同的动画效果。当然了，在这个场景中，自己写缓动函数并没有降低整体的复杂度，毕竟这个缓动函数逻辑太碎，理解起来肯定比四个animate连起来的方式复杂。但我希望能给大家带来一些思路上的启示，为以后可能遇到的问题积累经验。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[别说不可能，nodejs中实现sleep]]></title><description><![CDATA[nodejs最让人不爽的就是其单线程特性，很多事情没法做，对CPU密集型的场景，性能也不够强劲。很长一段时间，我想在javascript语言框架下寻求一些解决方案，解决无法操作线程、性能差的问题。曾经最让我印象深刻的方案是 fibers ，不过fibers…]]></description><link>https://www.zhouhua.info//2015/sleep/</link><guid isPermaLink="false">https://www.zhouhua.info//2015/sleep/</guid><pubDate>Wed, 04 Mar 2015 15:34:22 GMT</pubDate><content:encoded>&lt;p&gt;nodejs最让人不爽的就是其单线程特性，很多事情没法做，对CPU密集型的场景，性能也不够强劲。很长一段时间，我想在javascript语言框架下寻求一些解决方案，解决无法操作线程、性能差的问题。曾经最让我印象深刻的方案是&lt;a href=&quot;http://www.zhouhua.info/2014/03/13/fibers/&quot;&gt;fibers&lt;/a&gt;，不过fibers也好，其他方案也好，在线程操作上还是很别扭，太过依赖辅助线程，本末倒置；就fiber而言，javascript固有的低性能问题并不能解决；最别扭的是在javascript语言框架下，线程间的消息传递常常很受限制，经常无法真正地共享对象。&lt;/p&gt;&lt;/p&gt;
&lt;p&gt;nodejs的addon方式无疑是极好的，具有极强的灵活性、完备的功能和原生代码的性能。简单说就是让nodejs直接调用c/c++模块，是一种javascript和native的混合开发模式。好东西呀，为什么不用呢？addon应该算是一个大话题，今天我也不想太深入说这个，我自己的实践也不是很多。那就实现一个sleep函数，就当是抛砖引玉吧。&lt;/p&gt;
&lt;h2&gt;sleep&lt;/h2&gt;
&lt;p&gt;为什么javascript实现不了真正的sleep？sleep方法是通过向操作系统内核注册一个信号，指定时间后发送唤醒信号，而线程本身则挂起。本质上当线程&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;sleep(1000)&lt;/pre&gt;
&lt;p&gt; 代表告诉操作系统：1000ms内不要给我分配CPU时间。所以sleep能保证线程挂起时不再占用CPU资源。而javascript是单线程运行，本身取消了线程的概念，自然没有办法将主线程挂起中断。&lt;/p&gt;
&lt;p&gt;也有人会尝试用javascript方法要实现sleep，例如这样：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot; title=&quot;javascript实现sleep&quot;&gt;function sleep(sleepTime) {
    for(var start = +new Date; +new Date - start &amp;lt;= sleepTime; ) { } 
}&lt;/pre&gt;
&lt;p&gt; 这是采用空循环阻塞住主进程的运行来实现sleep，明显跟真正的sleep相去甚远。&lt;/p&gt;
&lt;p&gt;那么如果实现一个真正的sleep呢？&lt;/p&gt;
&lt;h2&gt;环境准备&lt;/h2&gt;
&lt;h3&gt;开发环境&lt;/h3&gt;
&lt;p&gt;之前我的一些博客已经说过，这里从略：node.js+npm、python 2.7、visual studio/ x-code。&lt;/p&gt;
&lt;h3&gt; 编译工具&lt;/h3&gt;
&lt;p&gt;编译工具需要采用node-gyp，较新版本的nodejs自带此库，如果没有自带node-gyp，请执行：&lt;/p&gt;
&lt;pre class=&quot;lang:batch decode:true &quot;&gt;npm install -g node-gyp&lt;/pre&gt;
&lt;p&gt; gyp特性我没有精力去研究，如果你比较熟悉gcc等其他编译器，不排除gyp会有不兼容之处，而且编译选项和开关也是不尽相同。建议针对nodejs重新编写c++代码，如果确实有模块需要复用，可以考虑先用熟悉的gcc编译成动态链接库，再编写少量代码来使用动态链接库，再把这部分代码用gyp编译出来供nodejs使用。&lt;/p&gt;
&lt;p&gt;进入项目文件夹，执行&lt;/p&gt;
&lt;pre class=&quot;lang:batch decode:1 inline:1 &quot; &gt;npm init&lt;/pre&gt;
&lt;p&gt; 初始化项目。为了让nodejs知道我们想制作addon，我们需要在package.json中添加：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true &quot;&gt;&quot;gyp-file&quot;: true&lt;/pre&gt;
&lt;p&gt; 如果使用过gcc，那么你一定记得makefile。类似的，gyp也是通过一个文件来描述编译配置，这个文件为binding.gyp，它是一个我们非常熟悉的json文件。gyp不是我们探讨的重点，所以binding.gyp也不会深入探究，我们只关注最重要的一些配置项。以下是一份简单但完整的binding.gyp文件示例：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;{
  &quot;targets&quot;: [
    {
      &quot;target_name&quot;: &quot;hello&quot;,
      &quot;sources&quot;: [ &quot;hello.cc&quot; ],
      &quot;include_dirs&quot;: [
        &quot;&amp;lt;!(node -e \&quot;require(&apos;nan&apos;)\&quot;)&quot;
      ]
    }
  ]
}&lt;/pre&gt;
&lt;p&gt; 就看看这里面涉及的三个配置项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;target_name：表示输出出来的模块名。&lt;/li&gt;
&lt;li&gt;sources：表示需要编译的源代码路径，这是一个数组。&lt;/li&gt;
&lt;li&gt;include&lt;em&gt;dirs：表示编译过程中要用到的目录，这些目录中的头文件可以在预编译指令&lt;pre class=&quot;lang:c++ decode:1 inline:1 &quot; &gt;#include&lt;/pre&gt; 搜索到。在这里使用了一个比较特殊的写法，没有把路径用字符串常量给出，而是运行一个命令&lt;pre class=&quot;lang:batch decode:1 inline:1 &quot; &gt;node -e “require(‘nan’)”&lt;/pre&gt; ，nan库后面再说，先看看这个命令输出什么：&lt;pre class=&quot;lang:sh decode:1 inline:1 &quot; &gt;node&lt;/em&gt;modules\nan&lt;/pre&gt; ，原来这句命令的意思是返回nan库的路径。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;C++编码&lt;/h2&gt;
&lt;p&gt; OK，既然已经配置了源代码是hello.cc，那就建立一个这样的文件。有一个问题需要提前提醒大家，我们所写的c++模块最终是要被v8引擎使用，所以api、写法等受到v8引擎的制约。而不同版本的nodejs其实采用的v8引擎的版本也不尽相同，这也就意味着很难用一套c++代码满足不同版本的nodejs（指编译过程，编译完成后跨版本应该能够使用，没有验证过。github不能上传二进制类库，所以github上开源会有麻烦。npm可以直接上传二进制类库，跳过编译步骤，所以问题相对较小）。&lt;/p&gt;
&lt;h3&gt;node 0.11及以上版本：&lt;/h3&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;#include &amp;lt;node.h&amp;gt;
#include &amp;lt;v8.h&amp;gt;

using namespace v8;

void SleepFunc(const v8::FunctionCallbackInfo&amp;lt;Value&amp;gt;&amp;amp; args) {
  Isolate* isolate = Isolate::GetCurrent();
  HandleScope scope(isolate);
  double arg0 = args[0] -&amp;gt; NumberValue();
  Sleep(arg0);
}

void Init(Handle&amp;lt;Object&amp;gt; exports) {
  Isolate* isolate = Isolate::GetCurrent();
  exports-&amp;gt;Set(String::NewFromUtf8(isolate, &quot;sleep&quot;),
      FunctionTemplate::New(isolate, SleepFunc)-&amp;gt;GetFunction());
}

NODE_MODULE(hello, Init);&lt;/pre&gt;
&lt;h3&gt;node 0.10及以下版本：&lt;/h3&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;#include &amp;lt;node.h&amp;gt;
#include &amp;lt;v8.h&amp;gt;

using namespace v8;

Handle&amp;lt;Value&amp;gt; SleepFun(const Arguments&amp;amp; args) {
  HandleScope scope;  
  double arg0 = args[0] -&amp;gt; NumberValue();
  Sleep(arg0);
  return scope.Close(Undefined());
}

void Init(Handle&amp;lt;Object&amp;gt; exports) {
  exports-&amp;gt;Set(String::NewSymbol(&quot;sleep&quot;),
      FunctionTemplate::New(SleepFun)-&amp;gt;GetFunction());
}

NODE_MODULE(hello, Init);&lt;/pre&gt;
&lt;p&gt; 可以看出，变化还是相当大的，如果能屏蔽这些差异就太好了，有办法了？我写这么多还不就是想告诉你有办法。是时候请出nan库了。&lt;/p&gt;
&lt;h3&gt;nan&lt;/h3&gt;
&lt;p&gt;还记得在binding.gyp中，我们引入nan库的路径，就是要在这里用。nan库是干嘛的呢？它提供了一层抽象，屏蔽了nodejs 0.8、nodejs 0.10、nodejs 0.12、io.js之前addon的语法差异。赞！&lt;/p&gt;
&lt;p&gt;先安装：&lt;/p&gt;
&lt;pre class=&quot;lang:batch decode:1 inline:1 &quot; &gt;npm install --save nan&lt;/pre&gt;
&lt;p&gt; ，看看同样的功能，用了nan后如何实现：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;#include &amp;lt;nan.h&amp;gt;
using namespace v8;

NAN_METHOD(Sleep){
    NanScope();
    double arg0=args[0]-&amp;gt;NumberValue();
    Sleep(arg0);
    NanReturnUndefined();
}

void Init(Handle&amp;lt;Object&amp;gt; exports){
    exports-&amp;gt;Set(NanSymbol(&quot;sleep&quot;), FunctionTemplate::New(Sleep)-&amp;gt;GetFunction());
}

NODE_MODULE(hello, Init);&lt;/pre&gt;
&lt;p&gt; 你需要了解的就是nan这套东西，至于v8的那一套就可以不用关注。&lt;/p&gt;
&lt;p&gt;从下往上看：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;NODE_MODULE(hello, Init);&lt;/pre&gt;
&lt;p&gt; 这句定义addon的入口。注意第一个参数要与我们在binding.gyp中target_name一项一致。第二个参数就是addon的入口函数。&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true &quot;&gt;void Init(Handle&amp;lt;Object&amp;gt; exports){
    exports-&amp;gt;Set(NanSymbol(&quot;sleep&quot;), FunctionTemplate::New(Sleep)-&amp;gt;GetFunction());
}&lt;/pre&gt;
&lt;p&gt; 这段代码就是addon的入口方法。它接收两个参数，分别是exports和module。上面的示例省略了第二个参数。如果模块提供一个对象，可以像示例中那个，直接给exports指定要提供的key-value；如果特殊一点，仅提供一个数值，或一个函数，则需要用到第二个参数，类似于&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;NODE_SET_METHOD(module, &quot;exports&quot;, foo);&lt;/pre&gt;
&lt;p&gt; 。这个示例中是表示要输出这样一个模块：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true &quot;&gt;{
    &quot;sleep&quot;: Sleep
}&lt;/pre&gt;
&lt;p&gt; Sleep是一个函数，下来就来看看Sleep的定义：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;NAN_METHOD(Sleep){
    NanScope();
    double arg0=args[0]-&amp;gt;NumberValue();
    Sleep(arg0);
    NanReturnUndefined();
}&lt;/pre&gt;
&lt;p&gt; 其实就是读取javascript传入的参数，转成double型，再调用c++的sleep方法。&lt;/p&gt;
&lt;h2&gt;编译addon&lt;/h2&gt;
&lt;p&gt;下面就要开始编译这个模块了。首先执行&lt;/p&gt;
&lt;pre class=&quot;lang:batch decode:1 inline:1 &quot; &gt;node-gyp configure&lt;/pre&gt;
&lt;p&gt; 来进行构建前准备工作，它会生成一个build文件夹和一些文件。接下来运行&lt;/p&gt;
&lt;pre class=&quot;lang:batch decode:1 inline:1 &quot; &gt;node-gyp build&lt;/pre&gt;
&lt;p&gt; 就可以开始编译了。在这个示例中，最终会在/build/Release/目录下生成一个hello.node文件，这就是最终能被javascript引用的addon模块了。&lt;/p&gt;
&lt;p&gt;如果后续对c++代码有修改，就不用再运行&lt;/p&gt;
&lt;pre class=&quot;lang:batch decode:1 inline:1 &quot; &gt;node-gyp configure&lt;/pre&gt;
&lt;p&gt; ，直接运行&lt;/p&gt;
&lt;pre class=&quot;lang:batch decode:1 inline:1 &quot; &gt;node-gyp build&lt;/pre&gt;
&lt;p&gt; 就好。&lt;/p&gt;
&lt;h2&gt;nodejs使用&lt;/h2&gt;
&lt;p&gt;建立一个index.js，看看怎么用这个模块吧：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;var sleep=require(&apos;./build/Release/hello.node&apos;).sleep;

console.log(new Date);
sleep(1000);
console.log(new Date);

// result
// Wed Mar 04 2015 14:55:18 GMT+0800 (中国标准时间) 
// Wed Mar 04 2015 14:55:19 GMT+0800 (中国标准时间)        &lt;/pre&gt;
&lt;p&gt; 很容易吧，跟普通的javascript函数的使用方式一模一样。&lt;/p&gt;
&lt;p&gt;至此本文想要分享的技术要点已经阐述完了。不过……究竟跟开篇提供的方法比起来有什么不一样？我不截图了，直接说明结果：&lt;/p&gt;
&lt;table style=&quot;height: 111px;&quot; width=&quot;624&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center;&quot;&gt; &lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;CPU占用（%）&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;内存占用（MB）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;c++ addon&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;6.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;javascript循环模拟&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;25&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;8.4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;由于addon方式采用的方法是线程挂起，理论上不会有CPU占用和内存变化，结果也是验证了这一点。再看javascript循环模拟sleep的方式，因为一直在跑循环，内存增加一点可以理解，没什么大不了；再看CPU占用25%，似乎还算过得去。真的是这样吗？揭露真相的时候到了。我测试的笔记本电脑的CPU是双核四线程，再结合25%的CPU占用……难道双核四线程中有一个线程就被这个sleep给占用了？其实我发现这期间并没有一个线程被锁死，不过这不是javascript的功劳，而是intel超线程的功劳。因为说是四线程，其实本质是两个处理核心只能是双线程，只是cpu做了一个时间片切割上的小把戏。例如核心cpu01分成了t0和t2，假设在n tick（调度周期）后的一个tick内，任务会分到t0，那么在再后面一个tick，任务会分到t2。所以从一个比较长的时间尺度（相对于调度周期），一个任务在t0和t2上运行的时间基本是相当的。于是呈现出来的情景是nodejs的进程没有占用t0或t2到100%，而是分别占用了50%上下。由于windows的进程调度相对比较复杂，所以CPU占用量上下浮动很大。可以这样预测，如果是双核双线程的CPU来处理这个脚本，CPU占用会上升到50%，并且一个核心卡死。如果是单核CPU来处理，CPU一下子会上升到100%。&lt;/p&gt;
&lt;p&gt;好像CPU这段说得有点多，超线程那些也是猜测，各位看看就好。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[必会CSS3技能：background-clip/background-origin]]></title><description><![CDATA[CSS3中新增了许多background类的属性。今天就来聊聊 background-clip 和 background-origin 。为什么把它们俩放一起说呢？因为它们俩很“默契”地拥有相同的属性值。 background-clip 先说 background-clip…]]></description><link>https://www.zhouhua.info//2015/background/</link><guid isPermaLink="false">https://www.zhouhua.info//2015/background/</guid><pubDate>Tue, 03 Mar 2015 11:46:54 GMT</pubDate><content:encoded>&lt;p&gt;CSS3中新增了许多background类的属性。今天就来聊聊&lt;strong&gt;background-clip&lt;/strong&gt;和&lt;strong&gt;background-origin&lt;/strong&gt;。为什么把它们俩放一起说呢？因为它们俩很“默契”地拥有相同的属性值。&lt;/p&gt;&lt;/p&gt;
&lt;h2&gt;background-clip&lt;/h2&gt;
&lt;p&gt;先说&lt;strong&gt;background-clip&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;lang:css decode:true&quot; title=&quot;语法&quot;&gt;background-clip: &amp;lt;border-box|padding-box|content-box|inherit&amp;gt;#&lt;/pre&gt;
&lt;p&gt; 可以看到它有三个属性值：&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;pre class=&quot;inline:true decode:1 &quot; &gt;border-box&lt;/pre&gt;&lt;/dt&gt;
&lt;dd&gt;background能够延伸到边框的外沿（但从Z轴方向上看，会被边框给盖住）。&lt;/dd&gt;
&lt;dt&gt;&lt;pre class=&quot;inline:true decode:1 &quot; &gt;padding-box&lt;/pre&gt;&lt;/dt&gt;
&lt;dd&gt;background能够延伸到内边框的外沿。&lt;/dd&gt;
&lt;dt&gt;&lt;pre class=&quot;inline:true decode:1 &quot; &gt;content-box&lt;/pre&gt;&lt;/dt&gt;
&lt;dd&gt;background裁剪到内容区域。&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;其实这个属性表现的就是一个盒子模型到底什么区域能显示背景。来看看效果：&lt;/p&gt;
&lt;pre class=&quot;lang:css decode:true&quot; title=&quot;代码示例&quot;&gt;.box{
    height: 100px;
    width: 200px;
    margin: 0 auto;
    padding: 20px;
    border: 20px dotted #222;
    background-image: url(http://zhouhua.qiniudn.com/test.jpg);
}&lt;/pre&gt;
&lt;div class=&quot;box&quot;&gt; &lt;/div&gt;
&lt;p&gt;background-clip:&lt;select id=&quot;clips&quot;&gt;&lt;/p&gt;
&lt;option value=&quot;border-box&quot;&gt;border-box&lt;/option&gt;
&lt;option value=&quot;padding-box&quot;&gt;padding-box&lt;/option&gt;
&lt;option value=&quot;content-box&quot;&gt;content-box&lt;/option&gt;
&lt;/select&gt;
&lt;p&gt;border-radius:&lt;input id=&quot;clipsRadius&quot; style=&quot;width: 30px;&quot; type=&quot;text&quot; value=&quot;0&quot; /&gt;px&lt;/p&gt;
&lt;p&gt;通过上面的演示，大家应该能比较直观的了解这个属性的作用。对于这个属性，还有几点想和大家说明一下。&lt;/p&gt;
&lt;p&gt;首先是如果存在&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;border-radius&lt;/pre&gt;
&lt;p&gt; 时，&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;background-clip&lt;/pre&gt;
&lt;p&gt; 的表现如何？圆角缺失处是否会渲染背景？大家可以试着调节一下圆角半径来体会一下。&lt;/p&gt;
&lt;p&gt;另外一个问题是取多个属性值的问题。MDN和一些CSS3的参考书籍上均指出&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;background-clip&lt;/pre&gt;
&lt;p&gt; 可以有多个属性值，大体类似&lt;span style=&quot;font-size: 12px; line-height: 19.2000007629395px; background-color: #d2eeca;&quot;&gt;font-family&lt;/span&gt; ，以逗号分隔。不过我稍微验证了一下，没能发现有什么用。&lt;/p&gt;
&lt;p&gt;最后一个问题是兼容性问题：&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;&lt;th&gt;特性&lt;/th&gt;&lt;th&gt;Chrome&lt;/th&gt;&lt;th&gt;Firefox (Gecko)&lt;/th&gt;&lt;th&gt;Internet Explorer&lt;/th&gt;&lt;th&gt;Opera&lt;/th&gt;&lt;th&gt;Safari&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;基本支持&lt;/td&gt;
&lt;td&gt;1.0&lt;/td&gt;
&lt;td&gt;4.0 (2.0) &lt;/td&gt;
&lt;td&gt;9.0 &lt;/td&gt;
&lt;td&gt;10.5&lt;/td&gt;
&lt;td&gt;3.0 (522) &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;pre class=&quot;inline:true decode:1 &quot; &gt;content-box&lt;/pre&gt;&lt;/td&gt;
&lt;td&gt;1.0&lt;/td&gt;
&lt;td&gt;4.0 (2.0) &lt;/td&gt;
&lt;td&gt;9.0 &lt;/td&gt;
&lt;td&gt;12.0 (或更早)&lt;/td&gt;
&lt;td&gt;3.0 (522) &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注：Firefox 3.6之前，支持的取值为padding | border，另外webkit带前缀时，支持border | padding | content这三个替代属性值。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;background-origin&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;background-clip&lt;/strong&gt;是描述背景裁切方式的属性，从字面意义上，我想大家也能猜到&lt;strong&gt;background-origin&lt;/strong&gt;是描述坐标原点相关的属性。&lt;/p&gt;
&lt;pre class=&quot;lang:css decode:true&quot; title=&quot;语法&quot;&gt;background-origin: &amp;lt;border-box|padding-box|content-box|inherit&amp;gt;#&lt;/pre&gt;
&lt;p&gt; 同样，它有三个属性值：&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;pre class=&quot;inline:true decode:1 &quot; &gt;border-box&lt;/pre&gt;&lt;/dt&gt;
&lt;dd&gt;background以border-box的左上角为起点开始渲染，或者说background-position的起始点为border-box的左上角。&lt;/dd&gt;
&lt;dt&gt;&lt;pre class=&quot;inline:true decode:1 &quot; &gt;padding-box&lt;/pre&gt;&lt;/dt&gt;
&lt;dd&gt;background以padding-box的左上角为起点开始渲染，或者说background-position的起始点为padding-box的左上角。&lt;/dd&gt;
&lt;dt&gt;&lt;pre class=&quot;inline:true decode:1 &quot; &gt;content-box&lt;/pre&gt;&lt;/dt&gt;
&lt;dd&gt;background以padding-box的左上角为起点开始渲染，或者说background-position的起始点为padding-box的左上角。&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;单看定义可能会有些让人一头雾水，还是通过实践来体会吧：&lt;/p&gt;
&lt;pre class=&quot;lang:css decode:true&quot; title=&quot;代码示例&quot;&gt;.box{
    height: 100px;
    width: 200px;
    margin: 0 auto;
    padding: 20px;
    border: 20px dotted #222;
    background-image: url(http://zhouhua.qiniudn.com/test.jpg);
}&lt;/pre&gt;
&lt;div class=&quot;box&quot;&gt; &lt;/div&gt;
&lt;p&gt;background-clip:&lt;select id=&quot;clips2&quot;&gt;&lt;/p&gt;
&lt;option value=&quot;border-box&quot;&gt;border-box&lt;/option&gt;
&lt;option value=&quot;padding-box&quot;&gt;padding-box&lt;/option&gt;
&lt;option value=&quot;content-box&quot;&gt;content-box&lt;/option&gt;
&lt;/select&gt;
&lt;p&gt;background-origin:&lt;select id=&quot;origins2&quot;&gt;&lt;/p&gt;
&lt;option value=&quot;border-box&quot;&gt;border-box&lt;/option&gt;
&lt;option value=&quot;padding-box&quot;&gt;padding-box&lt;/option&gt;
&lt;option value=&quot;content-box&quot;&gt;content-box&lt;/option&gt;
&lt;/select&gt;
&lt;p&gt;border-radius:&lt;input id=&quot;clipsRadius2&quot; style=&quot;width: 30px;&quot; type=&quot;text&quot; value=&quot;0&quot; /&gt;px&lt;/p&gt;
&lt;p&gt;background-position:&lt;input id=&quot;x&quot; style=&quot;width: 30px;&quot; type=&quot;text&quot; value=&quot;0&quot; /&gt;px &lt;input id=&quot;y&quot; style=&quot;width: 30px;&quot; type=&quot;text&quot; value=&quot;0&quot; /&gt;px&lt;/p&gt;
&lt;p&gt;background-attachment:&lt;select id=&quot;attachment&quot;&gt;&lt;/p&gt;
&lt;option value=&quot;fixed&quot;&gt;fixed&lt;/option&gt;
&lt;option value=&quot;scroll&quot;&gt;scroll&lt;/option&gt;
&lt;/select&gt;
&lt;p&gt;多尝试尝试，我想background-origin的作用还是比较容易感受理解的。同时，也注意体会background-position和background-origin属性的联系与区别。另外要提一点就是如果设置了background-attachment为fixed，则background-origin无效。&lt;/p&gt;
&lt;p&gt;MDN上指出&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;background-origin&lt;/pre&gt;
&lt;p&gt; 可以有多个属性值，我还是没试出效果。&lt;/p&gt;
&lt;p&gt;最后一个问题是兼容性问题：&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;&lt;th&gt;特性&lt;/th&gt;&lt;th&gt;Chrome&lt;/th&gt;&lt;th&gt;Firefox (Gecko)&lt;/th&gt;&lt;th&gt;Internet Explorer&lt;/th&gt;&lt;th&gt;Opera&lt;/th&gt;&lt;th&gt;Safari&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;基本支持&lt;/td&gt;
&lt;td&gt;1.0&lt;/td&gt;
&lt;td&gt;4.0 (2.0) &lt;/td&gt;
&lt;td&gt;9.0 &lt;/td&gt;
&lt;td&gt;10.5&lt;/td&gt;
&lt;td&gt;3.0 (522) &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;pre class=&quot;inline:true decode:1 &quot; &gt;content-box&lt;/pre&gt;&lt;/td&gt;
&lt;td&gt;1.0&lt;/td&gt;
&lt;td&gt;4.0 (2.0) &lt;/td&gt;
&lt;td&gt;9.0 &lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;3.0 (522) &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注：类似于background-clip，Firefox 3.6之前，支持的取值为padding | border，另外webkit带前缀时，支持border | padding | content这三个替代属性值。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;</content:encoded></item><item><title><![CDATA[phantomjs配合kindlegen，kindle看天涯不费力]]></title><description><![CDATA[前言 kindle看书挺舒服的，网页上看到大段文字就想搬到kindle里去。以前会用一些转寄的服务，网页上随手点个send to kindle，倒也方便。嗯……还是不要自欺欺人了，read it later === read it never。 后来固定用多看了，多看的推送和amazon…]]></description><link>https://www.zhouhua.info//2015/kindle/</link><guid isPermaLink="false">https://www.zhouhua.info//2015/kindle/</guid><pubDate>Fri, 27 Feb 2015 22:59:13 GMT</pubDate><content:encoded>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;kindle看书挺舒服的，网页上看到大段文字就想搬到kindle里去。以前会用一些转寄的服务，网页上随手点个send to kindle，倒也方便。嗯……还是不要自欺欺人了，read it later === read it never。&lt;/p&gt;&lt;/p&gt;
&lt;p&gt;后来固定用多看了，多看的推送和amazon的是一样的，只是没有转寄服务了，也就懒得推送网页了。其实不喜欢推送网页的最主要的原因还是体验差，阅读本来就应该是一页一页地读下去，而不是看个几分钟，退出，删除，选下一本。但……如果内容多一点的话，比如天涯上的长帖、小说，嗯，它们本来就应该在kindle上看。联上wifi用浏览器看？不适合我……原因：移动性弱，浏览器弱，支持wifi加密方式少，没买3G的，耗电惨。那怎么办？把帖子扒下来慢慢看！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;准备&lt;/h2&gt;
&lt;p&gt;如今的码农动不动就写个爬虫，爬这个爬那个。那我们……不行，前端从业者应该用一些“前端特色”的方式来解决这个问题。&lt;/p&gt;
&lt;h3&gt;武器一：phantomjs&lt;/h3&gt;
&lt;p&gt;无头浏览器，功能强大，绝对让你以最熟悉的方式分析网页。想知道怎么用，移步到&lt;a href=&quot;http://www.zhouhua.info/2014/03/19/phantomjs&quot; title=&quot;phantomjs使用说明&quot;&gt;phantomjs使用说明&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;武器二：kindlegen&lt;/h3&gt;
&lt;p&gt;amazon出品的电子书制作、转换工具，它能把HTML、XML、XHTML、ePub等格式的文档转换成mobi格式，功能强悍、使用简单。amazon不知何故禁止中国地区用户下载，不过通过下面这个链接还是可以下载到的：&lt;a href=&quot;https://kdp.amazon.com/help?topicId=A3IWA2TQYMZ5J6&quot;&gt;https://kdp.amazon.com/help?topicId=A3IWA2TQYMZ5J6&lt;/a&gt; 。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;动手&lt;/h2&gt;
&lt;p&gt;思路其实不复杂，就是把一个帖子分析一下，从第一页到最后一页，把每一页楼主发表的内容都抓出来，存放到一个html文件中。最后使用kindlegen把这个html转成mobi，大功告成。&lt;/p&gt;
&lt;p&gt;建立一个mobi.js文件，开始这次的phantomjs脚本之旅。&lt;/p&gt;
&lt;h3&gt;解析url&lt;/h3&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;[caption id=“attachment_244” align=“aligncenter” width=“879”]&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/02/QQ%E6%88%AA%E5%9B%BE20150227142735.png&quot; alt=&quot;天涯帖子url示意&quot;&gt; 天涯帖子url示意[/caption]&lt;/p&gt;
&lt;p&gt;一个普通的天涯帖子url长这个样式。标红的数字表示当前页码，如果样跳转到这个帖子的第5页，只需要把这个数字换成5就可以了。&lt;/p&gt;
&lt;p&gt;脚本开始之前，先要获取要采集的网址。假设我们执行：&lt;/p&gt;
&lt;pre class=&quot;lang:batch decode:true&quot;&gt;phantomjs mobi.js [url]&lt;/pre&gt;
&lt;p&gt; 那么如何在脚本中得到这个&lt;/p&gt;
&lt;pre class=&quot;inline:true decode:1 &quot; &gt;url&lt;/pre&gt;
&lt;p&gt;呢？&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot; title=&quot;获取参数&quot;&gt;var system = require(&apos;system&apos;);
var args = system.args;

if (args.length === 1) {
    console.log(&apos;请输入要采集的网址！&apos;);
    phantom.exit(-1);
}
var url = args[1];&lt;/pre&gt;
&lt;p&gt; 对于这个url，我们关注的焦点应该在页码处。关于这一点，我们很容易把url的后面一部分抽象成&lt;/p&gt;
&lt;pre class=&quot;lang:default decode:1 inline:1 &quot; &gt;-{Number}.shtml&lt;/pre&gt;
&lt;p&gt; ，写成正则表达式：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;/^(.+)-([0-9]+)\.shtml$/&lt;/pre&gt;
&lt;p&gt; 。好了，验证url的代码可以像这样：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;var scope = {
    content: &apos;&apos;, // 提取内容
    page: 1, // 当前页码
    counts: 0 // 总页码
};

var r = /^(.+)-([0-9]+)\.shtml$/;
var matches = url.match(r);
if (matches.length === 3) {
    spider(scope); // 后面讲
}
else {
    console.log(&apos;无法解析url&apos;);
    phantom.exit(-1);
}&lt;/pre&gt;
&lt;p&gt; 多说一句，这个正则有两个子模式，前一个会匹配出这个帖子特有的url信息，那么我们想跳转到第n页的话，可以这样拼出url：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot; title=&quot;拼出特定页码的url&quot;&gt;var url = matches[1] + &apos;-&apos; + n + &apos;.shtml&apos;;&lt;/pre&gt;
&lt;h3&gt;页面分析&lt;/h3&gt;
&lt;p&gt;上面的代码已经看到&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;spider()&lt;/pre&gt;
&lt;p&gt; 方法，这是个递归方法，从第一页递归到最后一页，每一层递归间通过&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;scope&lt;/pre&gt;
&lt;p&gt; 这个全局变量传递参数。下面看看到底怎么实现的。&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot; title=&quot;递归处理每页帖子&quot;&gt;var webPage = require(&apos;webpage&apos;);
var page = webPage.create();

function spider(scope) {
    var url = matches[1] + &apos;-&apos; + scope.page + &apos;.shtml&apos;;

    page.open(url, function (status) {
        if (status === &apos;success&apos;) {
            page.injectJs(&apos;jq.js&apos;);
            scope = page.evaluate(function (scope) {
                // 提取文章内容
                return scope;
            }, scope);

            if (scope.page === scope.counts) {
                writer(scope);
            }
            else {
                scope.page++;
                spider(scope);
            }
        }
        else {
            console.log(&apos;无法打开&apos; + url);
            phantom.exit(-1);
        }
    });
}&lt;/pre&gt;
&lt;p&gt; 上面这段代码流程是根据当前页码，生成要采集的url（上文已经解释过）。用phantomjs打开这个url。如果打开成功，则提取文章内容（具体做法下文再阐述）。提取完成后，如果现在已经是最后一页，则抓取工作结束，把提取的内容输出出来，否则当前页数加上1，重新执行&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;spider&lt;/pre&gt;
&lt;p&gt; 方法重复上述流程。&lt;/p&gt;
&lt;p&gt;这段代码逻辑并不复杂，但是用到phantomjs webPage模块的一些api，如果不熟悉，可以参考&lt;a href=&quot;http://www.zhouhua.info/2014/03/19/phantomjs&quot; title=&quot;phantomjs使用说明&quot;&gt;phantomjs使用&lt;/a&gt;。下面来说说具体如何提取需要的内容。&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true &quot; title=&quot;提取帖子内容&quot;&gt;scope = page.evaluate(function (scope) {
    var $ = jQuery;
    if (!scope.counts) {
        scope.counts = bbsGlobal.pageCount;
        scope.hostName = bbsGlobal.dashang.getName;
        scope.title=$(&apos;title&apos;).text();
    }

    var posts = $(&apos;[_host=&quot;&apos; + scope.hostName + &apos;&quot;]&apos;);
    posts.each(function () {
        var $this = $(this);
        scope.content += &apos;&amp;lt;div class=&quot;post-content&quot;&amp;gt;&apos; + $this.find(&apos;.bbs-content&apos;).html() +
            &apos;&amp;lt;/div&amp;gt;&amp;lt;br/&amp;gt;&amp;lt;hr/&amp;gt;&apos;;
    });
    return scope;
}, scope);&lt;/pre&gt;
&lt;p&gt; 使用phantomjs的&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;evaluate&lt;/pre&gt;
&lt;p&gt; 方法来给打开的网页插入一段我们自定义的javascript脚本，之前我们已经用js注入的方法把jquery引入了，当然，你需求的一切类库都可以自由引入。所以现在天涯的网页就像我们自己开发的网页一样，可以自由使用javascript来操作。这里呢，我继续把&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;scope&lt;/pre&gt;
&lt;p&gt; 这个变量作为page对象内注入脚本和外部phantomjs环境间通信的信使。注意，这个&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;scope&lt;/pre&gt;
&lt;p&gt; 一定要是一个可以序列化成JSON字符串的对象。&lt;/p&gt;
&lt;p&gt;OK，至此现在该分析网页本身的结构了。首先我在代码中发现一个全局变量&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;bbsGlobal&lt;/pre&gt;
&lt;p&gt; ，可以从中得到总页数和作者ID&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/02/QQ%E6%88%AA%E5%9B%BE201502271427351.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;于是，嗯，我就直接拿来用了。再看帖子结构，如下：&lt;img src=&quot;http://www.zhouhua.info/wp-content/uploads/2015/02/QQ%E6%88%AA%E5%9B%BE201502271427352.png&quot; alt=&quot;QQ截图20150227142735&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们可以直接用&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:1 inline:1 &quot; &gt;$(&apos;[_host=&quot;&apos; + scope.hostName + &apos;&quot;] .bbs-content&apos;)&lt;/pre&gt;
&lt;p&gt; 把正文节点都找出来，然后拼合在一起，完成！&lt;/p&gt;
&lt;h3&gt;输出HTML&lt;/h3&gt;
&lt;p&gt;上面在&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;spider&lt;/pre&gt;
&lt;p&gt; 方法内可以看到我调用了一个&lt;/p&gt;
&lt;pre class=&quot;lang:js highlight:0 decode:1 inline:1 &quot; &gt;writer&lt;/pre&gt;
&lt;p&gt; 方法，现在就看看这个方法是怎么实现的吧：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;var fs = require(&apos;fs&apos;);
var outputPath = &apos;output&apos;;

function writer(scope) {
    var html=&apos;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head lang=&quot;en&quot;&amp;gt;&amp;lt;title&amp;gt;&apos;+
        scope.title+
        &apos;&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&apos;+
        scope.content.replace(/&amp;lt;br\/&amp;gt;$/, &apos;&apos;)+
        &apos;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&apos;;
    var path=outputPath+&apos;/&apos;+scope.title.replace(/[ \\\/:,，\?？\-\.\+]/g,&apos;&apos;)+&apos;.html&apos;;
    fs.write(path,html,{
        charset:&apos;gb18030&apos;
    });
    // HTML转modi下文讲 
}&lt;/pre&gt;
&lt;p&gt; 用一个很简单的html把提取出来的内容包好，写到一个html文件中。两个注意点：一是这里是允许加入排版的，css是支持的，这部分我略过，有兴趣的可以自己摸索；另一点是如果出现乱码，请在保存html文件时就指定好文件编码，在html文件中指定&lt;/p&gt;
&lt;pre class=&quot;lang:xhtml decode:1 inline:1 &quot; &gt;&amp;lt;mate charset /&amp;gt;&lt;/pre&gt;
&lt;p&gt; 被验证是无效的，转换时不起作用。文件写入完成后，就进入转换格式的流程了。&lt;/p&gt;
&lt;h3&gt;转换mobi&lt;/h3&gt;
&lt;pre class=&quot;lang:js decode:true &quot;&gt;var process = require(&quot;child_process&quot;);
var child = process.spawn(&quot;./kindlegen.exe&quot;, [path]);

child.stderr.on(&quot;data&quot;, function (data) {
    console.log(&quot;spawnSTDERR:&quot;, JSON.stringify(data))
});

child.on(&quot;exit&quot;, function (code) {
    console.log(&apos;finish!&apos;);
    phantom.exit(-1);
});&lt;/pre&gt;
&lt;p&gt; 使用phantomjs的child_process模块调用kindlegen来转换，并捕获产生的错误信息。完成后，phantomjs脚本也完成。&lt;/p&gt;
&lt;p&gt;至此，大功告成。把生成的mobi文档拷到kindle里，enjoy吧。&lt;/p&gt;
&lt;h2&gt;补充&lt;/h2&gt;
&lt;p&gt;主要内容都说完了，还有一些不主要的。首先是样式和编码，这两个特别实用，是允许自定义的，前文已经有所提及，我不展开了。&lt;/p&gt;
&lt;p&gt;下面要说一点没提及的东西了。你如果真的按我前面说的去做，你会被这抓取速度逼疯——实在太慢了！于是你需要掌握新技能：只下载需要的，中断一切无关的请求。什么是无关请求呢？css、js、图片、广告、站长统计等等。怎么解？so easy:&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;page.onResourceRequested = function(requestData, request) {
    if ((/http:\/\/.+?\.css/gi).test(requestData[&apos;url&apos;])) {
        request.abort();
    }
    if ((/http:\/\/.*baidu/gi).test(requestData[&apos;url&apos;])) {
        request.abort();
    }
    if ((/http:\/\/.*jd/gi).test(requestData[&apos;url&apos;])) {
        request.abort();
    }
    if ((/http:\/\/.+?\.jpg/gi).test(requestData[&apos;url&apos;])) {
        request.abort();
    }
    if ((/http:\/\/.+?\.png/gi).test(requestData[&apos;url&apos;])) {
        request.abort();
    }
    if ((/http:\/\/.+?\.js/gi).test(requestData[&apos;url&apos;])) {
        request.abort();
    }
};&lt;/pre&gt;
&lt;p&gt; 把无关请求的特征找出来，直接在请求发起时，中断好了。&lt;/p&gt;
&lt;p&gt;等等……好像漏了什么。对，图片呢？mobi格式是访问不了天涯的图片的，我们不仅没有把图片下载下来，还把下载图片的请求给中止了。这……这只能留给感兴趣的同学自己完成了，我只能提示你注意天涯图片使用了懒加载，另外调用open方法时可能使得之前所有的request全部中断，不想每一页都等到图片下载完成才能处理下一页的话，建议另开线程处理图片下载。当然我是没兴趣研究这个，因为……不会。不过考虑抓取速度和kindle图片显示效果，这图片就算了。&lt;/p&gt;
&lt;p&gt;最后，放上&lt;a href=&quot;http://www.zhouhua.info/wp-content/uploads/2015/02/mobi.zip&quot;&gt;下载链接&lt;/a&gt;。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[长姿势]]></title><description><![CDATA[javascript 有一个鲜为人知的运算符，叫“趋向于”， 写作 — >  。可以声明一个变量 然后让它趋向于另一个数。 就会打印9,8,7,6,5,4,3,2,1,0 了 2333333 认真就输了]]></description><link>https://www.zhouhua.info//2015/joke/</link><guid isPermaLink="false">https://www.zhouhua.info//2015/joke/</guid><pubDate>Fri, 09 Jan 2015 13:07:36 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;javascript 有一个鲜为人知的运算符，叫“趋向于”， 写作 —&gt; 。可以声明一个变量 然后让它趋向于另一个数。&lt;/p&gt;&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;var x = 10;
while (x --&amp;gt; 0){
    console.log(x);
}&lt;/pre&gt;
&lt;p&gt;就会打印9,8,7,6,5,4,3,2,1,0 了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2333333 认真就输了&lt;/p&gt;</content:encoded></item><item><title><![CDATA[padding、margin纵向取值问题]]></title><description><![CDATA[今天要说一个很基础，但被我自己忽略至今的一个简单问题：padding、margin在纵向取值为百分数时，它们相对的是父元素的高度吗？ 这个问题之所以被忽略，是因为使用场景有限。因为在布局的时候，我们通常只关注宽度，流式布局、响应式布局中，我们常常会给padding…]]></description><link>https://www.zhouhua.info//2014/percent/</link><guid isPermaLink="false">https://www.zhouhua.info//2014/percent/</guid><pubDate>Tue, 23 Dec 2014 23:30:53 GMT</pubDate><content:encoded>&lt;p&gt;今天要说一个很基础，但被我自己忽略至今的一个简单问题：padding、margin在纵向取值为百分数时，它们相对的是父元素的高度吗？ 这个问题之所以被忽略，是因为使用场景有限。因为在布局的时候，我们通常只关注宽度，流式布局、响应式布局中，我们常常会给padding设置横向的百分比数值。但纵向上，我们通常还是倾向于设置固定值。回到问题本身，我一直以为在横向上参照父元素的宽度，那么在纵向上应该参照父元素的高度。这其实是不对的，都是参照父元素的宽度。验证很容易，我不做示例了，贴上MDN的资料：&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3&gt;Values&lt;/h3&gt;
&lt;p&gt;Specifies one, two, three or four of the following values:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&amp;lt;length&amp;gt;&lt;/dt&gt;
&lt;dd&gt;Specifies a non-negative fixed width. See [**&amp;lt;length&amp;gt;**](https://developer.mozilla.org/en-US/docs/Web/CSS/length) for details.&lt;/dd&gt;
&lt;dt&gt;&amp;lt;percentage&amp;gt;&lt;/dt&gt;
&lt;dd&gt;With respect to the** width **of the containing block.&lt;/dd&gt;
&lt;/dl&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;One&lt;/strong&gt; single value applies to &lt;em&gt;all 4 sides&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Two&lt;/strong&gt; values apply to &lt;strong&gt;1.&lt;/strong&gt; &lt;em&gt;top and bottom&lt;/em&gt; and &lt;strong&gt;2.&lt;/strong&gt; to the &lt;em&gt;left and right&lt;/em&gt; side&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Three&lt;/strong&gt; values apply to &lt;strong&gt;1.&lt;/strong&gt; &lt;em&gt;top&lt;/em&gt;, &lt;strong&gt;2.&lt;/strong&gt; &lt;em&gt;right and left&lt;/em&gt; and &lt;strong&gt;3.&lt;/strong&gt; to the &lt;em&gt;bottom&lt;/em&gt; side&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Four&lt;/strong&gt; values apply to &lt;strong&gt;1.&lt;/strong&gt; &lt;em&gt;top&lt;/em&gt;, &lt;strong&gt;2.&lt;/strong&gt; &lt;em&gt;right&lt;/em&gt;, &lt;strong&gt;3.&lt;/strong&gt; &lt;em&gt;bottom&lt;/em&gt; and &lt;strong&gt;4.&lt;/strong&gt; to the &lt;em&gt;left&lt;/em&gt; side&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/padding&quot; title=&quot;MDN padding&quot;&gt;MDN padding&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/margin&quot; title=&quot;MDN margin&quot;&gt;MDN margin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[canvas元素的宽高]]></title><description><![CDATA[设置一个元素的尺寸，推荐的做法是通过css设置其  width  和  height 。不过今天我们说说一个特例： canvas 。本文内容比较简单，我不做示例。 常见的设置 元素尺寸有两种方法。 给 canvas 元素设置属性，例如： 2 .  给 canvas…]]></description><link>https://www.zhouhua.info//2014/canvassize/</link><guid isPermaLink="false">https://www.zhouhua.info//2014/canvassize/</guid><pubDate>Tue, 23 Dec 2014 22:56:06 GMT</pubDate><content:encoded>&lt;p&gt;设置一个元素的尺寸，推荐的做法是通过css设置其 &lt;code&gt;width&lt;/code&gt; 和 &lt;code&gt;height&lt;/code&gt;。不过今天我们说说一个特例：&lt;strong&gt;&lt;code&gt;canvas&lt;/code&gt;&lt;/strong&gt;。本文内容比较简单，我不做示例。&lt;/p&gt;
&lt;p&gt;常见的设置&lt;/p&gt;
&lt;pre class=&quot;inline:true decode:1 &quot; &gt;canvas&lt;/pre&gt;
&lt;p&gt;元素尺寸有两种方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;给&lt;pre class=&quot;inline:true decode:1 &quot; &gt;canvas&lt;/pre&gt;元素设置属性，例如：&lt;/p&gt;
&lt;pre class=&quot;lang:xhtml decode:true &quot;&gt;&lt;canvas width=&quot;400&quot; height=&quot;400&quot;&gt;
&lt;/canvas&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2. 给&lt;pre class=&quot;inline:true decode:1 &quot; &gt;canvas&lt;/pre&gt;对象设置属性，例如：&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot;&gt;var canvas = document.getElementById(&apos;canvas&apos;);
canvas.width = 400;
canvas.height = 400;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不过如果你采用css来控制：&lt;/p&gt;
&lt;pre class=&quot;lang:css decode:true&quot;&gt;canvas{
    width:400px;
    height:400px;
}&lt;/pre&gt;
&lt;p&gt;则会发现&lt;/p&gt;
&lt;pre class=&quot;inline:true decode:1 &quot; &gt;canvas&lt;/pre&gt;
&lt;p&gt;画出的图形变形了。为什么会这样？原来不同于其他元素，你只能通过前两种方式设置&lt;/p&gt;
&lt;pre class=&quot;inline:true decode:1 &quot; &gt;canvas&lt;/pre&gt;
&lt;p&gt;的尺寸，因为&lt;/p&gt;
&lt;pre class=&quot;inline:true decode:1 &quot; &gt;canvas&lt;/pre&gt;
&lt;p&gt;是基于像素点渲染的，它的渲染可以说完全依赖于&lt;/p&gt;
&lt;pre class=&quot;inline:true decode:1 &quot; &gt;imageData&lt;/pre&gt;
&lt;p&gt;，如果不通过&lt;/p&gt;
&lt;pre class=&quot;inline:true decode:1 &quot; &gt;canvas&lt;/pre&gt;
&lt;p&gt;而直接改变&lt;/p&gt;
&lt;pre class=&quot;inline:true decode:1 &quot; &gt;canvas&lt;/pre&gt;
&lt;p&gt;尺寸，那么&lt;/p&gt;
&lt;pre class=&quot;inline:true decode:1 &quot; &gt;imageData&lt;/pre&gt;
&lt;p&gt;里的数据将完全无效。那么为什么用css设置宽高会发生变形呢？首先我们需要知道，通常一个未设置尺寸的&lt;/p&gt;
&lt;pre class=&quot;inline:true decode:1 &quot; &gt;canvas&lt;/pre&gt;
&lt;p&gt;元素是有一个默认宽高的，为&lt;/p&gt;
&lt;pre class=&quot;inline:true decode:1 &quot; &gt;300px &amp;times;&amp;nbsp;150px&lt;/pre&gt;
&lt;p&gt;，如果css中没有将宽高设置成&lt;/p&gt;
&lt;pre class=&quot;inline:true decode:1 &quot; &gt;canvas&lt;/pre&gt;
&lt;p&gt;元素的宽高，那么这个它会在原有尺寸的基础上，拉伸到css中设置的尺寸。从这点上看，跟图片的宽高处理是一样的（只不过图片通过属性或css设置尺寸基本上效果是一样的）。&lt;/p&gt;
&lt;p&gt;当然，通过css设置&lt;/p&gt;
&lt;pre class=&quot;inline:true decode:1 &quot; &gt;canvas&lt;/pre&gt;
&lt;p&gt;的尺寸也并不一定是无用的，有害的。比如在画椭圆的时候，是不是又多了一种简单的途径？&lt;/p&gt;</content:encoded></item><item><title><![CDATA[javascript实现各种字符串搜索算法]]></title><description><![CDATA[我觉得在前端开发中过多地考虑算法没有太多实际的意义。但这仅仅是我觉得，我并没有证据证明这一点。那为何不来尝试一下，面对一个特定的任务，我将使用不同的算法来实现，看看究竟效率相差多少。今天我想通过字符串搜索这一场景来进行测试。 测试场景 主字符串就以ABC的一篇文章内容为例，略做修改 There…]]></description><link>https://www.zhouhua.info//2014/string/</link><guid isPermaLink="false">https://www.zhouhua.info//2014/string/</guid><pubDate>Tue, 16 Dec 2014 22:26:51 GMT</pubDate><content:encoded>&lt;p&gt;我觉得在前端开发中过多地考虑算法没有太多实际的意义。但这仅仅是我觉得，我并没有证据证明这一点。那为何不来尝试一下，面对一个特定的任务，我将使用不同的算法来实现，看看究竟效率相差多少。今天我想通过字符串搜索这一场景来进行测试。&lt;/p&gt;
&lt;h2&gt;测试场景&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;主字符串就以ABC的一篇文章内容为例，略做修改&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There are some times when clicking “like” on a friend’s Facebook status doesn’t feel appropriate. A bad day. A loved one lost. A break up. It only seems natural that a “dislike” button could solve the conundrum of wanting to empathize but not seem inappropriate by clicking “like.” Mark Zuckerberg Puts the Rest of Us to Shame by Speaking Fluent Chinese. Mark Zuckerberg: Facebook Founder and Animal Butcher. Mark Zuckerberg and That Shirt. The idea has been on Mark Zuckerberg’s radar for a while, he said. In 2010, he told ABC News’ Diane Sawyer that that Facebook would “definitely think about” adding a dislike button. “People definitely seem to want it,” Zuckerberg said. Four years later — Zuckerberg says Facebook is still “thinking about” adding the oft-requested button, Zuckerberg says Facebook is still “thinking about” adding the oft-requested button. At a town hall meeting on Thursday, the CEO revealed he has some reservations about the feature. “There are two things that it can mean,” Zuckerberg said of the potential button, which could be used in a mean spirited way or to express empathy. Finding how to limit it to the latter is the challenge. Zuckerberg said he doesn’t want the button to turn into a “voting mechanism” or something that isn’t “socially valuable.” “Often people will tell us they don’t feel comfortable pressing ‘like,’” Zuckerberg said. “What’s the right way to make it so people can easier express a wide range of emotions?” One suggestion percolating online: Roll out the feature under a different name. However, an “empathy button” just may not have the same ring to it as “dislike.”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模式字符串&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;靠近起点&lt;code&gt;friend&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;靠近终点&lt;code&gt;button&quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;靠近中间&lt;code&gt;Zuckerberg says Facebook is still &quot;thinking about&quot; adding the oft-requested button.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;暴力算法&lt;/h3&gt;
&lt;p&gt;首先是最原始的做法，主串左侧开始，逐个对比，如果不相同，则主串起始点向后移一位，重复，直到找到。&lt;/p&gt;
&lt;table border=&quot;0&quot; summary=&quot;search&quot; cellspacing=&quot;0&quot; cellpadding=&quot;5&quot;&gt;
&lt;caption align=&quot;left&quot;&gt;第一次尝试&lt;/caption&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;gray&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor=&quot;white&quot;&gt;1&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;2&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;3&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;4&lt;/td&gt;
&lt;td colspan=&quot;20&quot; align=&quot;left&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;gray&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td colspan=&quot;16&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table border=&quot;0&quot; summary=&quot;search&quot; cellspacing=&quot;0&quot; cellpadding=&quot;5&quot;&gt;
&lt;caption align=&quot;left&quot;&gt;第二次尝试&lt;/caption&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;gray&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;1&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;1&lt;/td&gt;
&lt;td colspan=&quot;22&quot; align=&quot;left&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;1&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;gray&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td colspan=&quot;15&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table border=&quot;0&quot; summary=&quot;search&quot; cellspacing=&quot;0&quot; cellpadding=&quot;5&quot;&gt;
&lt;caption align=&quot;left&quot;&gt;第三次尝试&lt;/caption&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;gray&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;2&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;1&lt;/td&gt;
&lt;td colspan=&quot;21&quot; align=&quot;left&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;2&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;gray&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td colspan=&quot;14&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table border=&quot;0&quot; summary=&quot;search&quot; cellspacing=&quot;0&quot; cellpadding=&quot;5&quot;&gt;
&lt;caption align=&quot;left&quot;&gt;第四次尝试&lt;/caption&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;gray&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;3&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;1&lt;/td&gt;
&lt;td colspan=&quot;20&quot; align=&quot;left&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;3&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;gray&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td colspan=&quot;13&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table border=&quot;0&quot; summary=&quot;search&quot; cellspacing=&quot;0&quot; cellpadding=&quot;5&quot;&gt;
&lt;caption align=&quot;left&quot;&gt;第五次尝试&lt;/caption&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;gray&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;4&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;1&lt;/td&gt;
&lt;td colspan=&quot;19&quot; align=&quot;left&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;4&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;gray&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td colspan=&quot;12&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table border=&quot;0&quot; summary=&quot;search&quot; cellspacing=&quot;0&quot; cellpadding=&quot;5&quot;&gt;
&lt;caption align=&quot;left&quot;&gt;Sixth attempt&lt;/caption&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;5&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;1&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;2&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;3&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;4&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;5&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;6&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;7&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;8&lt;/td&gt;
&lt;td colspan=&quot;11&quot; align=&quot;left&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;5&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td colspan=&quot;11&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以上示例（&lt;a href=&quot;http://igm.univ-mlv.fr/~lecroq/string/examples/exp3.html&quot; title=&quot;暴力搜索&quot;&gt;http://igm.univ-mlv.fr/~lecroq/string/examples/exp3.html&lt;/a&gt;）说明了一次暴力搜索的过程。&lt;/p&gt;
&lt;p&gt;我用JS模拟了这个算法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var mainString=&quot;&quot;; var searchString=&quot;&quot; function basicSearch(mainStr, str, offset){ var mainLength=mainStr.length; var searchLength=str.length; if(searchLength&gt;mainLength-offset){ return -1; } offset=offset||0; for(var i=0;searchlength&gt;i ;i++){ if(str.charAt(i)!==mainString.charAt(offset+i)){ return basicSearch(mainStr, str, offset+1) } } return offset; } basicSearch(mainString, searchString);&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;lang:js decode:true&quot; title=&quot;暴力算法非递归版&quot;&gt;function basicSearchLoop(mainStr, str){
    var mainLength=mainStr.length;
    var searchLength=str.length;
    for(var offset= 0,padding=mainLength-searchLength;offset&lt; =padding;offset++) {
        var match=true;
        for (var i = 0; i &lt; searchLength; i++) {
            if (str.charAt(i) !== mainString.charAt(offset + i)) {
                match=false;
                break;
            }
        }
        if(match)return offset;
    }
    return -1;
}&lt;/pre&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;KMP算法（Knuth-Morris-Pratt算法）&lt;/h2&gt;
&lt;p&gt;KMP算是字符串搜索算法里的明星。不过本文重点不是介绍算法历史，有兴趣的可以移步百度百科（&lt;a href=&quot;http://baike.baidu.com/view/659777.htm&quot; title=&quot;KMP算法&quot;&gt;KMP算法&lt;/a&gt;）。这里一样先看一个例子：&lt;/p&gt;
&lt;table border=&quot;0&quot; summary=&quot;search&quot; cellspacing=&quot;0&quot; cellpadding=&quot;5&quot;&gt;
&lt;caption align=&quot;left&quot;&gt;第一次尝试&lt;/caption&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;gray&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor=&quot;white&quot;&gt;1&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;2&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;3&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;4&lt;/td&gt;
&lt;td colspan=&quot;20&quot; align=&quot;left&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;gray&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td colspan=&quot;16&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;移动步数: 4 (&lt;em&gt;i&lt;/em&gt;-&lt;em&gt;kmpNext&lt;/em&gt;[&lt;em&gt;i&lt;/em&gt;]=3- -1)&lt;/p&gt;
&lt;table border=&quot;0&quot; summary=&quot;search&quot; cellspacing=&quot;0&quot; cellpadding=&quot;5&quot;&gt;
&lt;caption align=&quot;left&quot;&gt;第二次尝试&lt;/caption&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;gray&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;4&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;1&lt;/td&gt;
&lt;td colspan=&quot;19&quot; align=&quot;left&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;4&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;gray&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td colspan=&quot;12&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;移动步数: 1 (&lt;em&gt;i&lt;/em&gt;-&lt;em&gt;kmpNext&lt;/em&gt;[&lt;em&gt;i&lt;/em&gt;]=0- -1)&lt;/p&gt;
&lt;table border=&quot;0&quot; summary=&quot;search&quot; cellspacing=&quot;0&quot; cellpadding=&quot;5&quot;&gt;
&lt;caption align=&quot;left&quot;&gt;第三次尝试&lt;/caption&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;5&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;1&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;2&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;3&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;4&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;5&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;6&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;7&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;8&lt;/td&gt;
&lt;td colspan=&quot;11&quot; align=&quot;left&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;5&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td colspan=&quot;11&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;移动步数: 7 (&lt;em&gt;i&lt;/em&gt;-&lt;em&gt;kmpNext&lt;/em&gt;[&lt;em&gt;i&lt;/em&gt;]=8-1)&lt;/p&gt;
&lt;p&gt;如果每次发生不一致都要计算一次效率太低，可以考虑将计算结果缓存到一张&lt;strong&gt;部分匹配表&lt;/strong&gt;中（也可以在搜索之前先生成此表）。以intristed为例：移动步数: 1 (&lt;em&gt;i&lt;/em&gt;-&lt;em&gt;kmpNext&lt;/em&gt;[&lt;em&gt;i&lt;/em&gt;]=0- -1)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://igm.univ-mlv.fr/~lecroq/string/examples/exp8.html&quot; title=&quot;KMP算法&quot;&gt;原始示例出处&lt;/a&gt;。我们看到，这里有一个&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kmpNext&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; 数组，这是什么呢？我们慢慢来理解。每一次尝试匹配时，从模式字符串的左端开始对比，如果第i个字符相同，则比较第i+1个；如果不相同，则需要把模式字符串向右移动。移动的位数是算法优劣的关键。每次移动一位是暴力算法的做法。kmp算法有自己独特的移动步数计算方法。&lt;/p&gt;
&lt;p&gt;首先引入两个概念：&lt;strong&gt;前缀&lt;/strong&gt;和&lt;strong&gt;后缀&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前缀：一个字符串所有头部的集合，不包含自身；&lt;/li&gt;
&lt;li&gt;后缀：一个字符串所有尾部的集合，不包含自身。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们看下面的例子（编号从1开始编）：&lt;/p&gt;
&lt;table border=&quot;0&quot; summary=&quot;search&quot; cellspacing=&quot;0&quot; cellpadding=&quot;5&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;i&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;n&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;t&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;r&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;i&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;s&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;t&lt;/td&gt;
&lt;td bgcolor=&quot;gray&quot;&gt;i&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;n&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;g&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor=&quot;white&quot;&gt;1&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;2&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;3&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;4&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;5&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;6&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;7&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;8&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;9&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;i&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;n&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;t&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;r&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;i&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;s&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;t&lt;/td&gt;
&lt;td bgcolor=&quot;gray&quot;&gt;e&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;d&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在模式串8的位置发生了不匹配，那么要计算模式串右移的位数之前，我们先写出位置1~7处的子串intrist的前缀和后缀：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前缀：i, in, int, intr, intri, intris, intrist&lt;/li&gt;
&lt;li&gt;后缀：t, st, ist, rist, trist, ntrist, intrist&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们再定义一个&lt;strong&gt;部分匹配值&lt;/strong&gt;的概念：前缀和后缀交集中，长度最长的元素的长度。很显然，这里前缀和后缀没有交集，最长共同元素的长度也就认为是0，那么模式串向右移动（8-0=）8个字符。跟上面的算法（上面是7-(-1)）稍有不同，不过大体意思一样，计算结果也一样。&lt;/p&gt;
&lt;table&gt;
&lt;caption&gt;部分匹配表&lt;/caption&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;模式字符串&lt;/th&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;t&lt;/td&gt;
&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;s&lt;/td&gt;
&lt;td&gt;t&lt;/td&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;序号&lt;/th&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;部分匹配值&lt;/th&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;计算右移位数就可以很容易地从表中计算出来：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;移动位数=已匹配的位数-已匹配部分的部分匹配值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如在第6个位置s处发现不匹配，那么需要右移5-1=4位。&lt;/p&gt;
&lt;p&gt;但这样计算其实并不方便，比如已匹配位数为0的情况很难处理，所以我们可以对部分匹配值做一个修正，每个值减去1，公式也相应调整为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;移动位数=不匹配字符的位置-已匹配部分的修正部分匹配值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样这个公式就与上面示例中的公式相同了。&lt;/p&gt;
&lt;p&gt;我用JS模拟了这个算法：&lt;/p&gt;
&lt;/pre&gt;
&lt;pre class=&quot;lang:js decode:true&quot; title=&quot;KMP算法&quot;&gt;function KMPSearch(mainLength,str,offset,group){
    var mainLength=mainString.length;
    var searchLength=str.length;
    if(searchLength&gt;mainLength-offset){
        return -1;
    }
    offset=offset||0;
    group=group||[1,1];
    var searchedString=[];
    for(var i=0;searchlength&gt;i ;i++){
        var searchingChar=str.charAt(i);
        if(searchingChar!==mainString.charAt(offset+i)){
            var offsetJump;
            if(group[i]) {
                offsetJump = group[i];
            }else{
                offsetJump = next(searchedString);
                group[i]=offsetJump;
            }
            return KPMSearch(mainLength,str,offset+offsetJump,group);
        }
        searchedString.push(searchingChar);
    }
    return offset;
}
function next(chars){
    var length=chars.length;
    for(var i=length-1;i&gt;0;i--){
        var isMatch=true;
        for(var j=0 ;j&lt; =i;j++){
            if(chars[j]!==chars[length-i+j]){
                isMatch=false;
                break;
            }
        }
        if(isMatch)return length-i;
    }
    return length;
}&lt;/pre&gt;
&lt;p&gt; &lt;/p&gt;
&lt;/pre&gt;
&lt;pre class=&quot;lang:js decode:true &quot; title=&quot;KMP算法非递归版本&quot;&gt;function KMPSearchLoop(mainStr, str) {
    var mainLength=mainString.length;
    var searchLength = str.length;
    for (var offset = 0, padding = mainLength - searchLength, group = [1, 1]; offset &lt; = padding;){
        var searchedString = [];
        var match=true;
        var offsetJump;
        for (var i = 0; i &lt; searchLength; i++) {
            var searchingChar = str.charAt(i);
            if (searchingChar !== mainString.charAt(offset + i)) {
                match=false;
                if (group[i]) {
                    offsetJump = group[i];
                }
                else {
                    offsetJump = next(searchedString);
                    group[i] = offsetJump;
                }
                break;
            }
            searchedString.push(searchingChar);
        }
        if(match){
            return offset;
        }else{
            offset+=offsetJump;
        }
    }
    return -1;
}&lt;/pre&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;Horspool算法&lt;/h2&gt;
&lt;p&gt;Horspool算法在做匹配的时候，创造性地从右向左匹配，对后来其他算法有很深的影响。还是那句话，本文会讲很多算法上的东西，但本文重点不是算法，下面还是会过一下Horspool算法的搜索过程，如果难以理解，还是参考其他更详细的资料。依然是示例（&lt;a href=&quot;http://igm.univ-mlv.fr/~lecroq/string/examples/exp18.html&quot; title=&quot;Horspool算法&quot;&gt;http://igm.univ-mlv.fr/~lecroq/string/examples/exp18.html&lt;/a&gt;）：&lt;/p&gt;
&lt;table border=&quot;0&quot; summary=&quot;search&quot; cellspacing=&quot;0&quot; cellpadding=&quot;5&quot;&gt;
&lt;caption align=&quot;left&quot;&gt;第一次尝试&lt;/caption&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;gray&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;7&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;1&lt;/td&gt;
&lt;td colspan=&quot;16&quot; align=&quot;left&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;gray&quot;&gt;G&lt;/td&gt;
&lt;td colspan=&quot;16&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;移动步数: 1 (Horspool[A])&lt;/p&gt;
&lt;table border=&quot;0&quot; summary=&quot;search&quot; cellspacing=&quot;0&quot; cellpadding=&quot;5&quot;&gt;
&lt;caption align=&quot;left&quot;&gt;第二次尝试&lt;/caption&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;gray&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;1&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;3&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;2&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;1&lt;/td&gt;
&lt;td colspan=&quot;15&quot; align=&quot;left&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;1&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;gray&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td colspan=&quot;15&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;移动步数: 2 (Horspool[G])&lt;/p&gt;
&lt;table border=&quot;0&quot; summary=&quot;search&quot; cellspacing=&quot;0&quot; cellpadding=&quot;5&quot;&gt;
&lt;caption align=&quot;left&quot;&gt;第三次尝试&lt;/caption&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;gray&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;3&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;5&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;4&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;3&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;2&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;1&lt;/td&gt;
&lt;td colspan=&quot;13&quot; align=&quot;left&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;3&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;gray&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td colspan=&quot;13&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;移动步数: 2 (Horspool[G])&lt;/p&gt;
&lt;table border=&quot;0&quot; summary=&quot;search&quot; cellspacing=&quot;0&quot; cellpadding=&quot;5&quot;&gt;
&lt;caption align=&quot;left&quot;&gt;第四次尝试&lt;/caption&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;T&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;antiquewhite&quot;&gt;G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;5&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;8&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;7&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;6&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;5&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;4&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;3&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;2&lt;/td&gt;
&lt;td bgcolor=&quot;white&quot;&gt;1&lt;/td&gt;
&lt;td colspan=&quot;11&quot; align=&quot;left&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;5&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;C&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;A&lt;/td&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;G&lt;/td&gt;
&lt;td colspan=&quot;11&quot; bgcolor=&quot;white&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;先对齐，从模式串的右侧开始匹配，如果完全匹配则结束搜索，否则查看模式串最右边对应的主串字符是什么。找出这个字符在模式串中最后出现的位置（除最末位）距离模式串最后一个字符的距离，如果没有在模式串中出现过，则认为这个距离是模式串的长度。我们可以事先把这个距离表计算出来。&lt;/p&gt;
&lt;table style=&quot;width: 300px; height: 40px;&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;⇒&lt;/p&gt;
&lt;table style=&quot;width: 300px;&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;字符&lt;/td&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;*（其他）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;距离&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;8（模式串的长度）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以上面第三次尝试为例，从右向左匹配了5次后发现匹配失败了，那么这时就看序号1处主串的字符是什么。很容易得到是‘G’，查询上表，‘G’对应的距离是2，那就很简单粗暴地把模式串向右移动两位，再次进行匹配。&lt;/p&gt;
&lt;p&gt;上代码：&lt;/p&gt;
&lt;/pre&gt;
&lt;pre class=&quot;lang:js decode:true &quot; title=&quot;Horspool算法非递归版&quot; &gt;function HorspoolSearchLoop(mainString, str){
    var mainLength=mainString.length;
    var searchLength = str.length;
    var table={};
    for(var index= 0,l=searchLength-1;l&gt;index ;index++){
        table[str.charAt(index)]=l-index;
    }
    for (var offset = 0, padding = mainLength - searchLength; offset &lt; = padding;){
        var rightChar;
        var match=true;
        var offsetJump;
        for (var i = searchLength-1; i &gt;=0; i--) {
            var searchingChar = str.charAt(i);
            if(i===searchLength-1){
                rightChar=mainString.charAt(offset+i);
            }
            if (searchingChar !== mainString.charAt(offset + i)) {
                match=false;
                offsetJump = table[rightChar]||searchLength;
                break;
            }
        }
        if(match){
            return offset;
        }else{
            offset+=offsetJump;
        }
    }
    return -1;
}&lt;/pre&gt;
&lt;p&gt; 这次只写了非递归的版本，因为递归的版本已经没有写的必要。&lt;/p&gt;
&lt;h2&gt;还是来谈javascript&lt;/h2&gt;
&lt;p&gt;冲着javascript性能来看这篇文章的同学一定没有兴趣看上来的算法。我一边写一边测试，终于也不愿意再深究其他的一些算法，原本还想把Boyer-Moore算法、Sunday算法也一起讨论讨论，现在看来完全没有必要。为什么？因为javascript实现这些算法的效率实在太！慢！了！&lt;/p&gt;
&lt;p&gt;回到开头我们设置的测试场景，我们分别来试验一下搜索10000次，各种算法所要耗费的时间。&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;递归版（&lt;span class=&quot;_calcRound&quot;&gt;10000&lt;/span&gt;次·ms）&lt;/td&gt;
&lt;td&gt;循环版（&lt;span class=&quot;_calcRound&quot;&gt;10000&lt;/span&gt;次·ms）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;暴力算法&lt;/td&gt;
&lt;td class=&quot;_basicSearch&quot;&gt;87, 1862, 990&lt;/td&gt;
&lt;td class=&quot;_basicSearchLoop&quot;&gt;35, 1349, 661&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;KMP算法&lt;/td&gt;
&lt;td class=&quot;_KPMSearch&quot;&gt;106, 3405, 1770&lt;/td&gt;
&lt;td class=&quot;_KPMSearchLoop&quot;&gt;76, 2337, 1194&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Horspool算法&lt;/td&gt;
&lt;td colspan=&quot;2&quot; class=&quot;_HorspoolSearchLoop&quot;&gt;187, 2479, 1446&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;javascript原生方法&lt;/td&gt;
&lt;td colspan=&quot;2&quot; class=&quot;_NativeSearch&quot;&gt;9, 101, 47&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;自己动手试验一下？&lt;label&gt;运行次数：&lt;input type=&quot;text&quot; class=&quot;_times&quot; value=&quot;10000&quot;/&gt;&lt;/label&gt;&lt;button class=&quot;_run&quot;&gt;运行&lt;/button&gt;&lt;/p&gt;
&lt;p&gt;我想从数据上看，结论是很清晰的。javascript代码的性能确实不高，相比较于循环，递归更是慢了近1倍。javascript在分配内存，数组访问，函数调用等等方面的性能与编译型语言差距很大。如果要实现一个特定的任务，我们更多地应该考虑尽可能地使用原生代码来实现，高级的算法在javascript里似乎并没有多少实用价值。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[另辟蹊径复制样式]]></title><description><![CDATA[技能get√ 先说一个需求，我想给一个元素应用另外一个指定元素的样式，应该怎么做？对于一个特定的项目，我想通常做法是规范代码风格，直接把class复制过来就可以了。但现实情况可能并不会如此简单。比如我们假定这个指定元素是不可预测的，它的样式可能由class…]]></description><link>https://www.zhouhua.info//2014/copystyle/</link><guid isPermaLink="false">https://www.zhouhua.info//2014/copystyle/</guid><pubDate>Wed, 20 Aug 2014 22:49:26 GMT</pubDate><content:encoded>&lt;h2&gt;技能get√&lt;/h2&gt;
&lt;p&gt;先说一个需求，我想给一个元素应用另外一个指定元素的样式，应该怎么做？对于一个特定的项目，我想通常做法是规范代码风格，直接把class复制过来就可以了。但现实情况可能并不会如此简单。比如我们假定这个指定元素是不可预测的，它的样式可能由class控制，也可能由更复杂的选择器控制，甚至可能写在style属性里。这该怎么办呢？&lt;/p&gt;
&lt;p&gt;过程就懒得说了，直接说结论吧。上代码：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;window&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;getComputedStyle&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    window&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;getComputedStyle&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;node&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; node&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;currentStyle&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; a&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;A&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token comment&quot;&gt;// source node&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; b&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;B&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token comment&quot;&gt;// target node&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;css&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;window&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getComputedStyle&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;代码很短，先看最后一句，我们用&lt;code&gt;window.getComputedStyle()&lt;/code&gt;方法来获取一个节点的最终样式。OK，也许你没有用过这个方法，但作为一个FE，你一定见过下面这个画面：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;computedStyle.png&quot;&gt;
图1： Computed Style 截图&lt;/p&gt;
&lt;p&gt;这是在chrome的开发者工具中，通过element选项卡可以查看dom节点样式的截图，红框中的就是这个节点最终样式的计算结果。而&lt;code&gt;window.getComputedStyle()&lt;/code&gt;就是BOM提供给大家得到这样一个计算结果的接口。那么剩下的就好理解的，通过&lt;code&gt;window.getComputedStyle()&lt;/code&gt;方法拿到指定元素的最终样式集，这个结果呢又正好是一个&lt;code&gt;$.css()&lt;/code&gt;方法能接受的对象（这个对象下面会讲）。于是上述代码中，我们通过&lt;code&gt;$.css()&lt;/code&gt;方法直接将样式覆盖给了目标元素。当然，如果不想用jquery，我们也可以通过遍历这个对象，并操作目标元素的style属性达到目的，代码就不贴了。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;window.getComputedStyle()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;知道了这种做法，我们再来好好研究一下&lt;code&gt;window.getComputedStyle()&lt;/code&gt;这个方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;Window.getComputedStyle()&lt;/code&gt; method gives the values of all the CSS properties of an element after applying the active stylesheets and resolving any basic computation those values may contain.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;window.getComputedStyle(element [, pseudoElt])&lt;/code&gt;最多接受两个参数，第一个参数&lt;code&gt;element&lt;/code&gt;是我们想要获取样式的dom节点，这个参数是必须的，仅有这一个参数呢是这个方法的基本用法。但css3中添加了&lt;a href=&quot;http://dev.w3.org/csswg/css-content/#pseudo-elements&quot;&gt;伪元素&lt;/a&gt;的支持，第二个参数正是用来指定伪元素的。我们可以传递像”:before”、”:after”之类的值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有些技术文章把第二个参数解读成伪类，经我验证，这是不对的，伪类的样式是无法通过这种方式获取的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至于这种做法的兼容性，相信你也能猜到：IE6-8是不支持的。对伪元素的支持情况会更糟一些。&lt;/p&gt;
&lt;p&gt;表1：浏览器对&lt;code&gt;window.getComputedStyle()&lt;/code&gt;的支持情况&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;right&quot;&gt;特性&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;Chrome&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;FireFox&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;IE&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;Opera&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;Safari&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;基本支持&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&gt;=9&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;right&quot;&gt;&lt;strong&gt;伪元素支持&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&gt;=11&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;不支持&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;又是苦逼的IE。不过这次问题不算大。不知道你还记不记得代码最上面几行？回过头去看一眼：对于IE，我们用了&lt;code&gt;element.currentStyle&lt;/code&gt;属性，同样可以满足我们的需求。所以如果不涉及伪元素，配合示例代码里的shim，我们应该可以没有顾虑地使用&lt;code&gt;window.getComputedStyle()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;很多地方（例如以前的Jquery）在使用&lt;code&gt;window.getComputedStyle()&lt;/code&gt;时并没有直接在&lt;code&gt;window&lt;/code&gt;上调用，而是使用的&lt;code&gt;window.defaultView.getComputedStyle()&lt;/code&gt;。事实上现在我们可以认为&lt;code&gt;window.defaultView&lt;/code&gt;就是&lt;code&gt;window&lt;/code&gt;。Jquery也将这部分代码修改了，见&lt;a href=&quot;https://github.com/jquery/jquery/pull/524&quot;&gt;jquery #10373&lt;/a&gt;。可能会在IE的弹出窗口和低版本Firefox的frames中使用会有一些异常。Jquery认为在IE弹出窗口中使用必须加&lt;code&gt;defaultView&lt;/code&gt;，而Firefox的情况则不可以加&lt;code&gt;defailtView&lt;/code&gt;，于是做了一个shim，可以排除两种异常。可以参考下：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;&lt;span class=&quot;token function&quot;&gt;define&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; elem &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;// Support: IE less than 11+, Firefox less than 30+ (#15098, #14150)&lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;// IE throws on elements created in popups&lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;// FF meanwhile throws on frame elements through &quot;defaultView.getComputedStyle&quot;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; elem&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;ownerDocument&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;defaultView&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;opener &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; elem&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;ownerDocument&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;defaultView&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getComputedStyle&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; elem&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; window&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getComputedStyle&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; elem&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;更详细的内容有兴趣的朋友可以参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://bugs.jquery.com/ticket/14150&quot;&gt;jquery #14150&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bugs.jquery.com/ticket/15098&quot;&gt;jquery #15098&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;CSSStyleDeclaration&lt;/h2&gt;
&lt;p&gt;再来说说&lt;code&gt;window.getComputedStyle()&lt;/code&gt;的返回值。&lt;code&gt;window.getComputedStyle()&lt;/code&gt;会返回一个&lt;code&gt;CSSStyleDeclaration&lt;/code&gt;对象。这个对象是只读的，意味着我们只能取其值，不能为其赋值。所以上面的示例代码中我们采用&lt;code&gt;$.css()&lt;/code&gt;方法来设置css样式。这个对象应该如何用，这篇文章里面我不想赘述，有兴趣的可以参考&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration&quot;&gt;MDN的文档&lt;/a&gt;。想直观了解这个对象长什么样子的同学请点击F12键，我在浏览器的console里输出了一个&lt;code&gt;CSSStyleDeclaration&lt;/code&gt;对象。&lt;/p&gt;
&lt;script&gt;
    if(!window.getComputedStyle){
        window.getComputedStyle=function(node){
            return node.currentStyle;
        }
    }
    console.info(&quot;CSSStyleDeclaration对象的示例：&quot;);
    console.dir(window.getComputedStyle(document.body));
&lt;/script&gt;
&lt;p&gt;最后提醒下不同浏览器下，css的属性名可能有差异，如比较突出的cssFloat/styleFloat/float，jquery可以屏蔽掉浏览器这方面的差异，推荐之。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[phantomjs使用说明]]></title><description><![CDATA[phantomjs实现了一个无界面的webkit浏览器。虽然没有界面，但dom渲染、js运行、网络访问、canvas/svg绘制等功能都很完备，在页面抓取、页面输出、自动化测试等方面有广泛的应用。 安装 下载phantomjs…]]></description><link>https://www.zhouhua.info//2014/phantomjs/</link><guid isPermaLink="false">https://www.zhouhua.info//2014/phantomjs/</guid><pubDate>Wed, 19 Mar 2014 22:47:40 GMT</pubDate><content:encoded>&lt;p&gt;phantomjs实现了一个无界面的webkit浏览器。虽然没有界面，但dom渲染、js运行、网络访问、canvas/svg绘制等功能都很完备，在页面抓取、页面输出、自动化测试等方面有广泛的应用。&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;下载phantomjs（&lt;a href=&quot;https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-1.9.7-windows.zip&quot;&gt;官方下载&lt;/a&gt;，下载失败请访问&lt;a href=&quot;http://zhouhua.qiniudn.com/work/Node.js/phantomjs.zip&quot;&gt;另一个下载点&lt;/a&gt;）。解压到任意目录，并将包含phantomjs.exe的目录添加到系统路径。&lt;/p&gt;
&lt;p&gt;如果要借助phantomjs进行无头测试，请参考各个测试框架的说明，或者参考phantomjs的官方文档：&lt;a href=&quot;http://phantomjs.org/headless-testing.html&quot;&gt;http://phantomjs.org/headless-testing.html&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;使用说明&lt;/h2&gt;
&lt;h3&gt;简单示例&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js test.js&quot;&gt;&lt;code&gt;var page = require(&apos;webpage&apos;).create(),
    system = require(&apos;system&apos;),
    address;
if (system.args.length === 1) {
    phantom.exit(1);
} else {
    address = system.args[1];
    page.open(address, function (status) {
        console.log(page.content);
        phantom.exit();
    });
}&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;运行：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-bash&quot;&gt;&lt;code&gt;phantomjs ./test.js http://baidu.com
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;这个例子简单地展示了通过phantom访问baidu.com，并输入html内容。使用方式就像使用Node.js运行js代码一样。在phantom运行时，它会向当前代码运行环境注入phantom对象。如上面代码中，通过phantom对象控制程序终结。示例中其他代码的含义以及更多深入的用法，将在下文中展开。&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;window对象&lt;/h3&gt;
&lt;p&gt;在使用phantom时，我首先关注的是DOM和BOM接口。不过这不是一个问题，看了下面的代码就能了解：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js test.js&quot;&gt;&lt;code&gt;console.log(window === this);
phantom.exit();&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;运行：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-bash&quot;&gt;&lt;code&gt;phantomjs ./test.js
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;结果为&lt;code&gt;true&lt;/code&gt;。也就是说，就像浏览器环境一样，我们的代码运行在window环境下，可以很方便地进行DOM方面的操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：如果使用web page模块打开页面，则请不要在此window对象下进行任何DOM相关的操作，因为这个window并不是page对象内的window。如果想要执行dom相关操作，请参阅&lt;code&gt;page.evaluate()&lt;/code&gt;部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3&gt;phantom对象&lt;/h3&gt;
&lt;p&gt;之前的例子中我们已经初步认识了phantom对象。它的功能是定义和控制phantom运行环境的参数和流程。关键的API有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;phantom.args&lt;/code&gt; String[]
获取传给本JS程序的参数，需要与&lt;code&gt;system.args&lt;/code&gt;进行区分（system模块详见下文），后者表示传给phantomjs引擎的参数。例如&lt;code&gt;phantomjs ./test.js http://baidu.com&lt;/code&gt;这句语句，通过&lt;code&gt;phantom.args&lt;/code&gt;，我们能得到的参数列表为&lt;code&gt;[&apos;http://baidu.com&apos;]&lt;/code&gt;，而通过&lt;code&gt;system.args&lt;/code&gt;则得到&lt;code&gt;[&apos;./test.js&apos;, &apos;http://baidu.com&apos;]&lt;/code&gt;这样的参数列表。差异就在于是否包含当前脚本名称。不过&lt;code&gt;phantom.scriptName&lt;/code&gt;这个API提供了获取脚本名称的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;phantom.cookies&lt;/code&gt; Object[]
获取或设置cookies，不过对于设置建议使用其他的API完成。同时相关的API还有:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;phantom.addCookie(Object)&lt;/code&gt; Boolean：添加cookie值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;phantom.deleteCookie(cookieName)&lt;/code&gt; Boolean：删除指定Cookie值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;phantom.clearCookies()&lt;/code&gt;：清空所有的cookie&lt;/li&gt;
&lt;li&gt;&lt;code&gt;phantom.cookiesEnabled&lt;/code&gt; Boolean：获取或设置是否支持cookie&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;phantom.injectJs(fileName)&lt;/code&gt; Boolean:
把指定的外部JS文件注入到当前环境。执行这个方法时，phantomjs首先会从当前目录检索此文件，如果找不到，则再到&lt;code&gt;phantom.libraryPath&lt;/code&gt;指定的路径寻找。&lt;code&gt;phantom.libraryPath&lt;/code&gt;这个API基本上就是为&lt;code&gt;phantom.injectJs()&lt;/code&gt;服务的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;phantom.onError&lt;/code&gt;
当页面存在js错误，且没有被&lt;code&gt;page.onError&lt;/code&gt;处理，则会被此handler捕获。下面是使用此API的一个例子。由于phantom环境下代码调试很困难，了解这些错误捕获的API也许会对我们的实际使用有所帮助。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;phantom&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;onError&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;msg&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; trace&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; msgStack &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;PHANTOM ERROR: &apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; msg&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;trace &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;amp&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;amp&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;amp&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;amp&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; trace&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        msgStack&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;TRACE:&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        trace&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;t&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            msgStack&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos; -&amp;amp;gt; &apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;t&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;file &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; t&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sourceURL&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;: &apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; t&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;line &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;t&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos; (in function &apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; t&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;)&apos;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;msgStack&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;\n&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    phantom&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;phantom.exit(returnValue)&lt;/code&gt;
这个API已经见过多次了，它的作用是退出程序，可以设置一个退出代码，默认是0。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3&gt;web page 模块&lt;/h3&gt;
&lt;p&gt;web page模块的功能是处理具体的页面。使用时需要引入模块，并创建实例：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; webPage &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;webpage&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; page &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; webPage&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;本文中不经说明，&lt;code&gt;page&lt;/code&gt;指代&lt;code&gt;require(&amp;#x26;quot;webpage&amp;#x26;quot;).create()&lt;/code&gt;的实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;page.cookies&lt;/code&gt; Object[]
与上文中的&lt;code&gt;phantom.cookies&lt;/code&gt;类似，表示本url下的cookie的读取。同样类似的API还有&lt;code&gt;addCookie()&lt;/code&gt;、&lt;code&gt;deleteCookie()&lt;/code&gt;、&lt;code&gt;clearCookies()&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;页面内容相关的API&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;page.content&lt;/code&gt; String：获取或设置当前页面的html。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;page.plainText&lt;/code&gt; String：这是一个只读属性，获取页面去除html标记的文本（考虑&lt;code&gt;$.text()&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;page.url&lt;/code&gt; String：只读，获取当前页面的url。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;page.setContent()&lt;/code&gt;：允许修改&lt;code&gt;page.content&lt;/code&gt;和&lt;code&gt;page.url&lt;/code&gt;内容，会触发reload。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;page.settings&lt;/code&gt; Object
对于当前页面的一些配置项。此API必须在&lt;code&gt;page.open()&lt;/code&gt;调用之前设置，否则不会起作用。以下是配置项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;javascriptEnabled&lt;/code&gt; 默认&lt;code&gt;true&lt;/code&gt;：是否执行页面内的javascript&lt;/li&gt;
&lt;li&gt;&lt;code&gt;loadImages&lt;/code&gt; 默认&lt;code&gt;true&lt;/code&gt;：是否载入图片&lt;/li&gt;
&lt;li&gt;&lt;code&gt;userAgent&lt;/code&gt; ：传递给服务器的userAgent字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;userName&lt;/code&gt; ：用于http访问授权的用户名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;password&lt;/code&gt; ：用于http访问授权的密码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XSSAuditingEnabled&lt;/code&gt; 默认&lt;code&gt;false&lt;/code&gt;：是否监控跨域请求&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resourceTimeout&lt;/code&gt; 单位&lt;code&gt;ms&lt;/code&gt;：定义资源请求的超时时间。如果设置了此项，则页面中如果有任何资源超过此时限未请求成功，则页面其他部分也会停止请求，并触发&lt;code&gt;onResourceTimeout()&lt;/code&gt;事件处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;page.customHeaders&lt;/code&gt; Object
phantom允许在请求时在http请求头部添加额外信息，此设置项对这个page里面所有的请求都生效（包含页面和其他资源的请求）。添加的信息并没有限制，但如果设置&lt;code&gt;User-Agent&lt;/code&gt;的值，那么这个值会覆盖掉&lt;code&gt;page.settings&lt;/code&gt;里的设置值。示例：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;page&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;customHeaders &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;X-Test&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;DNT&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;1&quot;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;page.libraryPath&lt;/code&gt; String
与&lt;code&gt;phantom.libraryPath&lt;/code&gt;类似，page对象也支持设置js文件路径，同时可以通过相应的&lt;code&gt;page.injectJs()&lt;/code&gt;方法注入javascript文件。除了&lt;code&gt;page.injectJs()&lt;/code&gt;方法外，还有&lt;code&gt;page.includeJs()&lt;/code&gt;也可以加入javascript文件。它们的区别在于，&lt;code&gt;page.injectJs()&lt;/code&gt;不强求此文件能访问得到，即使是一个不可访问的资源也可以。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;page.navigationLocked&lt;/code&gt; Boolean 默认&lt;code&gt;fasle&lt;/code&gt;
设置是否允许离开当前页面，默认是允许。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;page.open()&lt;/code&gt;
此方法用于打开一个网页，是一个很重要的API，它有三种调用形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;open(url, callback)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;open(url, method, callback)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;open(url, method, data, callback)&lt;/code&gt;
联想一下&lt;code&gt;$.ajax()&lt;/code&gt;，可以更好理解这个API。对于这些参数，需要单独阐述的是&lt;code&gt;callback&lt;/code&gt;。&lt;code&gt;callback()&lt;/code&gt;会在页面载入完成后调用，由&lt;code&gt;page.onLoadFinished&lt;/code&gt;调用（时机晚于&lt;code&gt;page.onLoadFinished&lt;/code&gt;）。这个&lt;code&gt;callback&lt;/code&gt;会接受一个参数&lt;code&gt;status&lt;/code&gt;，可能值为&lt;code&gt;&apos;success&lt;/code&gt;和&lt;code&gt;&apos;fail&apos;&lt;/code&gt;，指示页面是否加载成功。示例可以参考“简单示例”一节的例子。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;page.close()&lt;/code&gt;
与&lt;code&gt;page.open()&lt;/code&gt;对应，调用&lt;code&gt;page.close()&lt;/code&gt;之后，会释放page所占用的内存，我们不可以在此之后再调用page实例。在实际的操作中，调用此方法并不会完成清空所占内存；javascript的垃圾回收机制也不会回收page实例。但在实际使用中，常常会遇到将一个page实例反复open的情况。在一个页面用完后，记得一定要执行&lt;code&gt;page.close()&lt;/code&gt;，这样在下一次open的时候，才不会重复分配堆栈空间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;page.evaluate(fn, [param])&lt;/code&gt;
对于page打开的页面，往往需要与其进行一些交互。&lt;code&gt;page.evaluate()&lt;/code&gt;提供了在page打开页面的上下文（下文直接用page上下文指代）执行function的功能（类比Chrome开发者工具的控制台）。如下例：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;page&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;http://m.bing.com&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;status&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; title &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; page&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;evaluate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;querySelector&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;innerText&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;title&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;title&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    phantom&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;在这个例子中，&lt;code&gt;page.evaluate()&lt;/code&gt;接受两个参数，第一个是必需的，表示需要在page上下文运行的函数&lt;code&gt;fn&lt;/code&gt;；第二个是可选的，表示需要传给&lt;code&gt;fn&lt;/code&gt;的参数&lt;code&gt;param&lt;/code&gt;。&lt;code&gt;fn&lt;/code&gt;允许有一个返回值&lt;code&gt;return&lt;/code&gt;，并且此返回值最终作为&lt;code&gt;page.evaluate()&lt;/code&gt;的返回值。这边对于刚刚命名的&lt;code&gt;param&lt;/code&gt;和&lt;code&gt;return&lt;/code&gt;有一些额外的说明和注意事项。对于整个phantom进程而言，&lt;code&gt;page.evaluate()&lt;/code&gt;是跑在一个沙盒中，&lt;code&gt;fn&lt;/code&gt;无法访问一切phantom域中的变量；同样&lt;code&gt;page.evaluate()&lt;/code&gt;方法外部也不应该尝试访问page上下文中的内容。那么如果两个作用域需要交换一些数据，只能依靠&lt;code&gt;param&lt;/code&gt;和&lt;code&gt;return&lt;/code&gt;。不过限制很大，&lt;code&gt;param&lt;/code&gt;和&lt;code&gt;return&lt;/code&gt;必须为能够转化为JSON字符串，换言之，只能是基本数据类型或者简单对象，像DOM 节点、$对象、function、闭包等就无能为力了。
这个方法是同步的，如果执行的内容对后续操作不具备前置性，可以尝试异步方法以提高性能：&lt;code&gt;page.evaluateAsync()&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;page.render(filename)&lt;/code&gt;
&lt;code&gt;page.render()&lt;/code&gt;能够把当前页面渲染成图片并输出到指定文件中。输出的文件格式由传入的文件扩展名决定，目前支持&lt;code&gt;PNG&lt;/code&gt;、&lt;code&gt;JPEG&lt;/code&gt;、&lt;code&gt;GIF&lt;/code&gt;、&lt;code&gt;PDF&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; page &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;webpage&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
page&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;http://github.com/&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    page&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;github.png&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    phantom&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;还有其他一些API会对&lt;code&gt;page.render()&lt;/code&gt;产生影响，如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;page.zoomFactor&lt;/code&gt; Number： 设置缩放比率&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;page.clipRect&lt;/code&gt; Object：设置输出的矩形区域，例如：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;page&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;clipRect &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    top&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    left&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    width&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;400&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    height&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;300&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;还有一些页面设置参数，如果纸张大小，侧边距等，在此不详述。web page也支持输出图片base64格式的字符串，API为&lt;code&gt;page.renderBase64()&lt;/code&gt;，也不再详述。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;page.sendEvent()&lt;/code&gt;
为了交互的需要（测试的需要），phantom允许通过代码模拟一些交互事件（注意与DOM事件的区分）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;鼠标事件：
API：&lt;code&gt;sendEvent(mouseEventType[, mouseX, mouseY, button=&apos;left&apos;])&lt;/code&gt;
&lt;code&gt;mouseEventtype&lt;/code&gt;可能的取值为：&lt;code&gt;&apos;mouseup&apos;&lt;/code&gt;、&lt;code&gt;&apos;mousedown&apos;&lt;/code&gt;、&lt;code&gt;&apos;mousemove&apos;&lt;/code&gt;、&lt;code&gt;&apos;doubleclick&apos;&lt;/code&gt;和&lt;code&gt;&apos;click&apos;&lt;/code&gt;，这个参数为必须的。
后两个参数为鼠标事件的坐标位置。最后一个参数为鼠标按键，只对需要按键的事件有效，默认为&lt;code&gt;&apos;left&apos;&lt;/code&gt;，可能值为&lt;code&gt;&apos;right&apos;&lt;/code&gt;、&lt;code&gt;&apos;left&apos;&lt;/code&gt;、&lt;code&gt;&apos;middle&apos;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;键盘事件：
API：&lt;code&gt;sendEvent(keyboardEventType, keyOrKeys, [null, null, modifier])&lt;/code&gt;
&lt;code&gt;keyboardEventType&lt;/code&gt;可能的取值为&lt;code&gt;&apos;keyup&apos;&lt;/code&gt;、&lt;code&gt;&apos;keydown&apos;&lt;/code&gt;、&lt;code&gt;&apos;keypress&apos;&lt;/code&gt;，第2个参数传入一个键值或一个字符串。键值可以通过&lt;a href=&quot;https://github.com/ariya/phantomjs/commit/cab2635e66d74b7e665c44400b8b20a8f225153a&quot;&gt;&lt;code&gt;page.event.key&lt;/code&gt;&lt;/a&gt;来查询调用。第三和第四个参数无效，第五个参数表示同时按下的修饰键。取值情况如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt;: 未使用修饰键&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0x02000000&lt;/code&gt;: Shift键被按下&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0x04000000&lt;/code&gt;: Ctrl键被按下&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0x08000000&lt;/code&gt;: Alt键被按下
看一个示例：&lt;code&gt;page.sendEvent(&apos;keypress&apos;, page.event.key.A, null, null, 0x02000000 | 0x08000000);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;page.switchToFrame(frameName/framePosition)&lt;/code&gt;
默认page对应的是frame，如果一个页面中还有其他frame，则可以通过此方法切换page对应的frame。其他类似的方法还有&lt;code&gt;switchToChildFrame()&lt;/code&gt;、&lt;code&gt;switchToParentFrame()&lt;/code&gt;、&lt;code&gt;switchToFocusedFrame()&lt;/code&gt;、&lt;code&gt;switchToMainFrame()&lt;/code&gt;等，不再赘述。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;page.uploadFile(selector, file)&lt;/code&gt;
页面中常常会有上传文件的操作，但phantom没有界面，因而也就没有办法选择文件上传，通过此方法可以模拟文件上传操作。示例如下：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;page&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;uploadFile&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;input[name=image]&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;/path/to/some/photo.jpg&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些事件处理接口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;page.onAlert&lt;/code&gt;：phantom没有界面，所以也就不能处理alert窗口，但可以通过此接口捕获到alert。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;page.onPrompt&lt;/code&gt;：类似的，phantom不能处理prompt窗口，通过这个接口可以捕获prompt。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;page.onConfirm&lt;/code&gt;：类似的，phantom不能处理confirm窗口，通过这个接口可以捕获confirm。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;page.onConsoleMessage&lt;/code&gt;：类似的，phantom不能显示console窗口，通过这个接口可以捕获console消息。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; webPage &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;webpage&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; page &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; webPage&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
page&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;onAlert&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;msg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;ALERT: &apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; msg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
page&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;onPrompt&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;msg&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; defaultVal&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;msg &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;What&apos;s your name?&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;PhantomJS&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 返回值就是prompt得到的值&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; defaultVal&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
page&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;onConfirm&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;msg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;CONFIRM: &apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; msg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 返回true相当于点击“确定”，返回false相当于点击“取消”&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
page&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;onConsoleMessage&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;msg&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; lineNum&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; sourceId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;CONSOLE: &apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; msg &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos; (from line #&apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; lineNum &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos; in &quot;&apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; sourceId &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;&quot;)&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;page.onInitialized&lt;/code&gt;：在page创建后触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;page.onUrlChanged&lt;/code&gt;：在url发生变化时触发。它接受新的url作为参数。首次加载页面，&lt;code&gt;page.onUrlChanged&lt;/code&gt;是在&lt;code&gt;page.onInitialized&lt;/code&gt;之后触发。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;page.onNavigationRequested&lt;/code&gt;：如果在&lt;code&gt;page.navigationLocked&lt;/code&gt;中允许页面跳转，此接口才会有意义（参见&lt;code&gt;page.navigationLocked&lt;/code&gt;）。它接受4个参数，先看示例：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;page&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;onNavigationRequested&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;url&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; type&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; willNavigate&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; main&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Trying to navigate to: &apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; url&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Caused by: &apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; type&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Will actually navigate: &apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; willNavigate&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Sent from the page\&apos;s main frame: &apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; main&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;url&lt;/code&gt;表示要跳转到的url&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt;表示产生跳转的原因，可能值有&lt;code&gt;&apos;Undefined&apos;&lt;/code&gt;、&lt;code&gt;&apos;LinkClicked&apos;&lt;/code&gt;、&lt;code&gt;&apos;FormSubmitted&apos;&lt;/code&gt;、&lt;code&gt;&apos;BackOrForward&apos;&lt;/code&gt;、&lt;code&gt;&apos;Reload&apos;&lt;/code&gt;、&lt;code&gt;&apos;FormResubmitted&apos;&lt;/code&gt;、&lt;code&gt;&apos;Other&apos;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;willNavigate&lt;/code&gt;表示是否会跳转，由&lt;code&gt;page.navigationLocked&lt;/code&gt;控制&lt;/li&gt;
&lt;li&gt;&lt;code&gt;main&lt;/code&gt;表示发生跳转的是否是主frame，如果是主frame则为true，如果为其他frame则为false&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;page.onLoadStarted&lt;/code&gt;：在开始载入资源时触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;page.onLoadFinished&lt;/code&gt;：页面所有资源载入完成后触发。其实与&lt;code&gt;page.open()&lt;/code&gt;的回调函数等价。它接受一个参数&lt;code&gt;status&lt;/code&gt;，表示加载是否成功。参见&lt;code&gt;page.open()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;page.onClosing&lt;/code&gt;：当在phantom域调用&lt;code&gt;page.close()&lt;/code&gt;或page上下文调用&lt;code&gt;window.close()&lt;/code&gt;时触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;page.onError&lt;/code&gt;： 此接口捕获所有page上下文发生的javascript错误。参数是错误信息和调用堆栈，参见&lt;code&gt;phantom.onError&lt;/code&gt;。如果page不处理错误，那么这些错误会冒泡到phantom的onError处理器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;page.onCreate&lt;/code&gt;：当page创建子窗口时触发，例如在page上下文中使用&lt;code&gt;window.open&lt;/code&gt;，但是子窗口再创建子窗口不会触发此事件。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;page.onResourceRequested&lt;/code&gt;：当页面请求一个资源时触发的事件，它接受两个参数，第一个参数是&lt;code&gt;requestData&lt;/code&gt;对象，它有如下属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;id&lt;/code&gt; : 资源请求编号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;method&lt;/code&gt; : http请求方法，get/post等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;url&lt;/code&gt;：请求的URL&lt;/li&gt;
&lt;li&gt;&lt;code&gt;time&lt;/code&gt; : 一个Date object，包含响应接收的时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;headers&lt;/code&gt; : http头部的信息列表
第二个参数是&lt;code&gt;networkRequest&lt;/code&gt;实例，它包含3个方法：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;abort()&lt;/code&gt;：中断当前的请求。这样做会触发onResourceError&lt;/li&gt;
&lt;li&gt;&lt;code&gt;changeUrl(url)&lt;/code&gt;：改变当前请求的目标url&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setHeader(key, value)&lt;/code&gt;：修改/添加http头部信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;page.onResourceReceived&lt;/code&gt;：当一个资源请求的响应接收到后触发此事件，它接受一个&lt;code&gt;response&lt;/code&gt;对象，这个对象有如下属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;id&lt;/code&gt; : 资源请求编号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;url&lt;/code&gt;：请求的URL&lt;/li&gt;
&lt;li&gt;&lt;code&gt;time&lt;/code&gt; : 一个Date object，包含响应接收的时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;headers&lt;/code&gt; : http头部的信息列表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bodySize&lt;/code&gt; : 已接收到的数据大小（全部数据或已接收的部分数据）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;contentType&lt;/code&gt; : 指定的内容类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;redirectURL&lt;/code&gt; : 如果是一个重定向响应，那么此处是重定向到的url&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stage&lt;/code&gt; : “start”/ “end”&lt;/li&gt;
&lt;li&gt;&lt;code&gt;status&lt;/code&gt; : http状态码，如：200&lt;/li&gt;
&lt;li&gt;&lt;code&gt;statusText&lt;/code&gt; : http状态描述，如：OK&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;page.onResourceError&lt;/code&gt;：当资源加载失败时，触发此事件。它接收一个&lt;code&gt;resourceError&lt;/code&gt;对象，这个对象有如下属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;id&lt;/code&gt;：资源请求的编号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;url&lt;/code&gt;：请求的URL&lt;/li&gt;
&lt;li&gt;&lt;code&gt;errorCode&lt;/code&gt;：错误代码&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;errorString&lt;/code&gt;：错误信息
可参考如下示例：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;page&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;onResourceError&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;resourceError&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Unable to load resource (#&apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; resourceError&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;id &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;URL:&apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; resourceError&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;url &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;)&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Error code: &apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; resourceError&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;errorCode &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;. Description: &apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; resourceError&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;errorString&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;page.onResourceTimeout&lt;/code&gt;：在讲&lt;code&gt;page.settings&lt;/code&gt;时曾经提到过这个事件。如果设置了&lt;code&gt;page.settings.resourceTimeout&lt;/code&gt;，并且资源在这个时间内没有载入完成，则会触发此事件，它接受一个&lt;code&gt;request&lt;/code&gt;对象，这个对象包含如下属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;id&lt;/code&gt; : 资源请求编号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;method&lt;/code&gt; : http请求方法，get/post等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;url&lt;/code&gt;：请求的URL&lt;/li&gt;
&lt;li&gt;&lt;code&gt;time&lt;/code&gt; : 一个Date object，包含响应接收的时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;headers&lt;/code&gt; : http头部的信息列表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;errorCode&lt;/code&gt;：错误代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;errorString&lt;/code&gt;：错误信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3&gt;Child Process模块&lt;/h3&gt;
&lt;p&gt;通过Child Process模块，我们能创建子进程，借助&lt;code&gt;stdin&lt;/code&gt;、&lt;code&gt;stdout&lt;/code&gt;、&lt;code&gt;stderr&lt;/code&gt;来实现进程间通信（很C++）。使用子进程能够做很多事情，如打印、发邮件、调用脚本或其他程序（不局限于javascript）。&lt;/p&gt;
&lt;p&gt;要使用Child Process模块，我们需要在代码中添加&lt;code&gt;require(&apos;child_process&apos;)&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以下内容缺乏文档支持，并未经过充分测试，可能存在一定的理解偏差。这部分功能是极有用的，希望在项目中使用的时候注意测试。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Child Process模块本身应该也并完全开发完全。&lt;code&gt;spawn()&lt;/code&gt;、&lt;code&gt;execFile()&lt;/code&gt;可用，&lt;code&gt;exec()&lt;/code&gt;和&lt;code&gt;fork()&lt;/code&gt;尚未实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;spawn(command, [args], [options])&lt;/code&gt;
最基本的创建进程的方法。前两个参数比较重要，例如现在想从phantom进程中运行一段Node.js脚本，脚本路径为&lt;code&gt;main.js&lt;/code&gt;，这个脚本接受一个参数，假定为&lt;code&gt;helloworld&lt;/code&gt;，那么如果想得到这段脚本的运行结果应该怎么做呢？参考下面的脚本：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; spawn &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;child_process&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;spawn&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
child &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;spawn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Node.js&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;main.js&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;helloworld&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
child&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;stdout&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;data&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;spawnSTDOUT:&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; JSON&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;stringify&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
child&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;stderr&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;data&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;spawnSTDERR:&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; JSON&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;stringify&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
child&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;exit&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;code&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;spawnEXIT:&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; code&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    phantom&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;其实&lt;code&gt;spawn()&lt;/code&gt;方法没什么神秘的，它就是运行第一个参数表示的命令，第二个参数就是这个命令的参数列表。所以如果要开启一个新的phantom进程，第一个参数为&lt;code&gt;phantom&lt;/code&gt;就行。同样的道理，指定好程序的路径或者是脚本语言解释器的路径，通过这个方法可以做的事情很多。
比较不方便的是，进程间的通信只能通过&lt;code&gt;stdin&lt;/code&gt;、&lt;code&gt;stdout&lt;/code&gt;、&lt;code&gt;stderr&lt;/code&gt;来完成，调用&lt;code&gt;spawn()&lt;/code&gt;方法后，还需要对这些交互信息进行监听，上面的例子中演示了监听&lt;code&gt;stdout&lt;/code&gt;和&lt;code&gt;stderr&lt;/code&gt;的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;execFile(cmd, args, opts, cb)&lt;/code&gt;
就像刚刚说的，&lt;code&gt;spawn()&lt;/code&gt;方法稍微感觉有点麻烦，使用&lt;code&gt;execFile()&lt;/code&gt;能够稍稍简化上面的代码。&lt;code&gt;execFile()&lt;/code&gt;的前三个参数与&lt;code&gt;spawn()&lt;/code&gt;的三个参数完全一样，不同的是它多了一个&lt;code&gt;cb&lt;/code&gt;回调函数，看一个例子就知道这个回调函数有什么用了：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; execFile &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;child_process&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;execFile&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
child &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;execFile&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Node.js&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;main.js&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;helloworld&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;err&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; stdout&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; stderr&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;execFileSTDOUT:&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; JSON&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;stringify&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;stdout&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;execFileSTDERR:&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; JSON&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;stringify&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;stderr&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    phantom&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;在&lt;code&gt;execFile()&lt;/code&gt;中，对&lt;code&gt;stdout&lt;/code&gt;、&lt;code&gt;stderr&lt;/code&gt;的监听做了封装，简化了我们的代码，不过功能上与&lt;code&gt;spawn()&lt;/code&gt;并无区别。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3&gt;file system模块&lt;/h3&gt;
&lt;p&gt;虽然与Node.js中文件系统模块名称和调用方法（&lt;code&gt;require(&apos;fs&apos;)&lt;/code&gt;）一样，但不得不说，phantom的文件系统模块总体是比较简单的，API不多但够用，API也不同于Node.js的异步回调风格，而是采用stream+同步的风格，浓浓的C++风味。在使用的时间请一定要注意与Node.js的文件系统模块做区分。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fs.open(path, mode/opts)&lt;/code&gt; File
&lt;code&gt;open()&lt;/code&gt;方法接受两个参数，第一个参数是要打开的文件路径，第二个参数后面还会见到，这里统一说明。如果是字符串，则代表文件打开的模式，可选的有&lt;code&gt;&apos;r&apos;&lt;/code&gt;、&lt;code&gt;&apos;w&apos;&lt;/code&gt;、&lt;code&gt;&apos;a/+&apos;&lt;/code&gt;、&lt;code&gt;&apos;b&apos;&lt;/code&gt;（read时仅支持&lt;code&gt;&apos;b&apos;&lt;/code&gt;）；如果是一个对象，则表示配置项，一共有两个配置项，分别是&lt;code&gt;mode&lt;/code&gt;和&lt;code&gt;charset&lt;/code&gt;，&lt;code&gt;mode&lt;/code&gt;就是刚刚提到的打开模式，&lt;code&gt;charset&lt;/code&gt;表示文件的编码类型。参阅下面的示例：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; fs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;fs&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; file &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;main.js&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;r&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;file&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
file&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
file &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;main.js&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;a&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
file&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
file&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    phantom&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;对打开的文件，我们可以进行读写操作（具体使用与打开模式有关）。如果对一个文件执行了open，请别忘了在文件使用完成后，再对其执行close。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fs.read(path, mode/opts)&lt;/code&gt; String
&lt;code&gt;fs.read()&lt;/code&gt;方法对文件读取做了封装，不必关心文件的打开关闭，返回值为文件内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fs.write(path, content, mode/opts)&lt;/code&gt;
&lt;code&gt;fs.write()&lt;/code&gt;方法对文件写入做了封装，不必关心文件的打开关闭。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他API:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fs.size(path)&lt;/code&gt; Number：获取文件大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fs.copy(source, destination)&lt;/code&gt;：复制文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fs.copyTree(source, destination)&lt;/code&gt;：复制目录树&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fs.move(source, destination)&lt;/code&gt;：移动文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fs.moveTree(source, destination)&lt;/code&gt;：移动目录树&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fs.remove(file)&lt;/code&gt;：删除文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fs.removeTree(path)&lt;/code&gt;：删除目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fs.join(partialPath[])&lt;/code&gt; String：组合路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fs.split(path)&lt;/code&gt; String[]：切割路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fs.exist(path)&lt;/code&gt; Boolean：文件或目录是否存在&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fs.isFile(path)&lt;/code&gt; Boolean：指定路径是否是文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fs.isDirectory(path)&lt;/code&gt; Boolean：指定路径是否是目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fs.list(path)&lt;/code&gt; String[]：获取指定目录下的文件/目录名称列表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3&gt;System模块&lt;/h3&gt;
&lt;p&gt;在文档一开始就已经提到过system模块，一开始的例子中，我们使用了system模块提供的&lt;code&gt;args&lt;/code&gt;属性。现在重新来认识一下system模块。system模块主要管理着一些与运行环境有关的属性。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;system.args&lt;/code&gt; String[]
获取运行phantomjs时传入的所有参数，这个不再赘述。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;system.env&lt;/code&gt; Object
获取当前的环境信息。包含操作系统信息、环境变量信息等等。通过下面的代码来查看一下吧：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; system &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;system&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; env &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; system&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;env&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
Object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;env&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;key &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;=&apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; env&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    phantom&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;system.os&lt;/code&gt; Object
获取操作系统信息，返回一个简单对象，这个对象有3个属性：&lt;code&gt;architecture&lt;/code&gt;：架构，如“32bit”；&lt;code&gt;name&lt;/code&gt;：操作系统名称；&lt;code&gt;version&lt;/code&gt;：操作系统版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;system.pid&lt;/code&gt; Number
获取当前进程的pid。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;system.platform&lt;/code&gt; String
永远返回&lt;code&gt;&apos;phantomjs&apos;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3&gt;Web Server模块&lt;/h3&gt;
&lt;p&gt;phantomjs支持一个简单的web server模块，&lt;code&gt;require(&apos;webserver&apos;)&lt;/code&gt;即可引入。web server模块基于&lt;a href=&quot;https://code.google.com/p/mongoose/&quot;&gt;mongoose&lt;/a&gt;。不过最好不要在生产环境使用这样的服务器模块，因为现阶段此模块仅允许10个并发请求。&lt;/p&gt;
&lt;p&gt;看一个简单的例子吧：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; webserver &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;webserver&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; server &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; webserver&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; service &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; server&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;listen&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;8080&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;request&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; response&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    response&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;statusCode &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    response&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;&amp;amp;amp;lt;html&amp;amp;gt;&amp;amp;amp;lt;body&amp;amp;gt;Hello!&amp;amp;amp;lt;/body&amp;amp;gt;&amp;amp;amp;lt;/html&amp;amp;gt;&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    response&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;首先需要创建服务器实例，然后调用&lt;code&gt;listen()&lt;/code&gt;方法监听，&lt;code&gt;listen()&lt;/code&gt;方法的第一个参数可以为一个端口号，也可以用&lt;code&gt;ip:port&lt;/code&gt;这样的ip+port组合方式。第二个参数是处理请求的回调方法。下面描述一下&lt;code&gt;request&lt;/code&gt;和&lt;code&gt;response&lt;/code&gt;两个对象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;request：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;method&lt;/code&gt;：http请求的方法，get、post等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;url&lt;/code&gt;: 包含http请求URL和get请求的query string（如果有的话）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;httpVersion&lt;/code&gt;：当前采用的http协议的版本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;headers&lt;/code&gt;：所有http请求头部信息，以键值对的形式提供&lt;/li&gt;
&lt;li&gt;&lt;code&gt;post&lt;/code&gt;：请求主体，仅对post和put方法的请求有效&lt;/li&gt;
&lt;li&gt;&lt;code&gt;postRaw&lt;/code&gt;：如果Content-type为&lt;code&gt;&apos;application/x-www-form-urlencoded&apos;&lt;/code&gt;（表单上传的默认值）时，post的原始信息会暂存在此属性中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;response：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;headers&lt;/code&gt;：以键值对的形式保存所有的HTTP请求头部的信息，在第一次调用&lt;code&gt;write()&lt;/code&gt;方法前一定要设置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;setHeader(name, value)&lt;/code&gt;：设置或添加特定的头部信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;header(name)&lt;/code&gt;：获取特定的头部信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;statusCode&lt;/code&gt;：设置HTTP状态码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;setEncoding(encoding)&lt;/code&gt;: 标明传给&lt;code&gt;write()&lt;/code&gt;的数据需要转换成什么格式，默认为UTF-8。如果数据为二进制字符串，则设置为“binary”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;write(data)&lt;/code&gt;：向response中发送数据块，可以多次调用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;writeHead(statusCode, headers)&lt;/code&gt;：向response中发送响应头部。&lt;code&gt;statusCode&lt;/code&gt;是一个3位数字，表示HTTP状态码（如404）。后一个参数代码响应头部&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;close()&lt;/code&gt;：关闭HTTP连接&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;为了避免客户端检测到连接中断，记得最后再用&lt;code&gt;write()&lt;/code&gt;方法发送一个空字符串（如：&lt;code&gt;response.write(&apos;&apos;)&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;closeGracefully()&lt;/code&gt;：功能与&lt;code&gt;close()&lt;/code&gt;一样，不过更安全可靠，它能保证响应头部先发送，并自动在响应最后加上&lt;code&gt;response.write(&apos;&apos;)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[在Node.js中实现阻塞]]></title><description><![CDATA[Node.js中与生俱来的单线程编程、回调函数异步式风格让我们有时喜有时忧。先说单线程，很多人会费解于Node.js的单线程如何能做到高并发？这个问题不是本文重点，点到为止。澄清一点，Node.js的单线程仅仅指javascript引擎是单线程的，无论如何我们没有办法在javascript…]]></description><link>https://www.zhouhua.info//2014/sync/</link><guid isPermaLink="false">https://www.zhouhua.info//2014/sync/</guid><pubDate>Tue, 18 Mar 2014 22:45:57 GMT</pubDate><content:encoded>&lt;p&gt;Node.js中与生俱来的单线程编程、回调函数异步式风格让我们有时喜有时忧。先说单线程，很多人会费解于Node.js的单线程如何能做到高并发？这个问题不是本文重点，点到为止。澄清一点，Node.js的单线程仅仅指javascript引擎是单线程的，无论如何我们没有办法在javascript中实现多线程和阻塞（本文用到的方法同样不是通过V8引擎实现同步的）；但对于Node.js的其他方面不代表不能多线程，例如IO。如果现在Node.js遭受大量请求，而这些请求都是IO密集型的，那么此时Node.js每接受一个请求，在遇到耗时较长的IO操作时，javascript线程并不会一直在此等待，而是交出控制，在回调堆栈里添加IO操作完成后要执行的操作（当回调层级过多，访问数量过大，大量的回调链可能会爆栈）。而在这段时间内，Node.js又可以处理其他请求了。所以对于Node.js而言，虽然javascript是单线程的，每次只能处理一个请求，但javascript处理一个请求的时间往往较短（对于IO密集型应用而言），只要可以异步处理，那么在处理的过程中，此次请求都会释放控制，使Node.js能处理其他请求。这并发请求的同时，IO其实一直处于并发状态，减少处理请求的线程数，节约资源以增加IO的线程数，对于通常耗时很长的IO密集型请求来说，无疑能带来性能上的提升。&lt;/p&gt;
&lt;p&gt;前面啰啰嗦嗦地一直在强调IO密集型，其实是在强调Node.js的强项。相应的，它的短板就是CPU密集型的请求。道理很简单，javascript不会并发，只能一个请求完成后才能处理其他请求。一个请求处理的时间越长，其他请求等待的时间越长。同一时间只会有一个请求被处理，并发性能很低。&lt;/p&gt;
&lt;p&gt;话说到这儿，我想申明一点：Node.js不应该被阻塞；能异步处理的方法异步处理（如使用fs.readFile()，而非fs.readFileSync()方法）。&lt;/p&gt;
&lt;p&gt;Node.js中不能阻塞，并不代表Node.js外不能阻塞。前面我们有讲到&lt;a href=&quot;/2014/03/13/fibers/&quot;&gt;fibers&lt;/a&gt;，现在，我们就来尝试在fibers中实现阻塞。就以处理一个http请求为例吧：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; Fiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;fibers&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; http &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;http&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;Fiber&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; httpFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; html &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    http&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;http://www.baidu.com&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;res&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; dataFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        res&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;data&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            html &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; data&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        res&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;end&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            httpFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    Fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;html&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;yield()&lt;/code&gt;、&lt;code&gt;run()&lt;/code&gt;这两个方法还不了解的同学，请自行查阅&lt;a href=&quot;/2014/03/13/fibers/&quot;&gt;《fibers in Node.js》&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;fibers的运行并不在Node.js进程中，所以在fibers内部实现阻塞对Node.js整体的性能并没有影响。而且实现起来也是相当容易，只需要在想阻塞的时候，把fiber yield掉。需要继续运行，则执行&lt;code&gt;run()&lt;/code&gt;恢复fiber。在上面的例子中，我们希望当http.get请求发起时阻塞当前程序，当所有数据接收完成时，恢复程序。于是我们在调用http.get后使用&lt;code&gt;Fiber.yield()&lt;/code&gt;中断此fiber。在对response的监听中，如果触发&lt;code&gt;end&lt;/code&gt;事件表明数据传输完成，于是在&lt;code&gt;end&lt;/code&gt;的回调函数中，调用&lt;code&gt;Fiber.current.run()&lt;/code&gt;恢复fiber，这样，后续的代码就以同步的方式拿到http.get请求的数据。&lt;/p&gt;
&lt;p&gt;上面的示例只是提供一种思路。如果对这种思路进行一些抽象封装，比如说，对有接受回调函数为参数的异步方法进行一步柯里化，在调用后中断，并劫持回调函数，以恢复程序的代码为回调函数。获取异步数据后，再程序触发预定的回调函数，这样基本能实现异步方法同步化。这段说得比较乱，基本上就是&lt;code&gt;fibers/future&lt;/code&gt;的实现思路，如果有兴趣，请参考其&lt;a href=&quot;https://github.com/laverdet/Node.js-fibers/blob/master/future.js&quot;&gt;源代码&lt;/a&gt;。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Application Cache]]></title><description><![CDATA[Application Cache  是HTML5为web应用离线使用而增加的api，虽然都是有关存储，但与LocalStorage、 Cookie、SessionStorage有相当大的不同。Application Cache…]]></description><link>https://www.zhouhua.info//2014/applicationcache/</link><guid isPermaLink="false">https://www.zhouhua.info//2014/applicationcache/</guid><pubDate>Fri, 14 Mar 2014 22:40:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;Application Cache&lt;/em&gt; 是HTML5为web应用离线使用而增加的api，虽然都是有关存储，但与LocalStorage、 Cookie、SessionStorage有相当大的不同。Application Cache存储的是一系列的请求资源，允许浏览器在请求这些资源的时候，不必通过网络。如果设计良好的话，使用Application Cache能达到离线状态下，web应用仍能带来友好的用户体验。&lt;/p&gt;
&lt;h2&gt;使用方法&lt;/h2&gt;
&lt;h3&gt;过程与原理&lt;/h3&gt;
&lt;p&gt;Application Cache的使用要做两个方面的工作，浏览器端和服务器端。在服务器端需要维护一个缓存清单&lt;em&gt;manifest&lt;/em&gt;文件，这个文件里面记录了需要缓存的请求、不需要加入缓存的请求等内容。具体的manifest文件的语法及示例参见&lt;a href=&quot;http://www.w3school.com.cn/html5/html_5_app_cache.asp&quot;&gt;http://www.w3school.com.cn/html5/html&lt;em&gt;5&lt;/em&gt;app_cache.asp&lt;/a&gt;。浏览器通过请求这个manifest文件来判断是否可以使用application cache，以及application cache是否需要更新等。浏览器对于manifest文件的新旧判断依据很简单，就是是否一样，只要有一点区别，浏览器就认为manifest文件有更新，需要重新缓存所有数据。所以我们常常通过更改manifest注释的方式来提醒浏览器要更新缓存。需要注意的是，manifest文件的文件名及路径没有特别要求，但对于它的&lt;em&gt;MIME-type&lt;/em&gt;必须设置为&lt;code&gt;text/cache-manifest&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在浏览器端的设置很容易，只需要在HTML标签上添加manifest属性即可，类似：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-html&quot;&gt;&lt;code&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;html&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;manifest&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;cache.appcache&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;仅仅这样做就完成了Application Cache的配置，关于cache的检查、更新、读取都是浏览器自动完成。&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/flow-9a783a9d3ff87177906eb81af636cc84-c8ec5.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 960px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 76.23762376237623%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAACeElEQVQ4y41SPW/TUBTNP2KrBAgQQweQoKoQM0xM/AOEGJgQSycGhCrUBUGalkZtSAULqFJKW5qQpnFCnCgh366dOLEdfz4fru3muwiu9PLei98595x7bwj/Ga7rjnbXZf4a393Ru9C/wA4br0ngJFmQwJ0mnM40Dx6Gw0w0pBSkPn+hkNAsmbcz5tCJoa2Z2CpJiFckREsiWqoN25bxLfMC+foGPIhqiDjrJaFb4rzlWVWHbQX3dn/j0VcB93fLSNT6sMwmEtwzIlzDwGRoyjlw1VV0NW5MOKyDF4pewz73HMXGR885pO537KWfQOge+3eH+dtfGxcaK3P9x5JSQ4p/hR+VONLCAAe1Q2wkX0JUOJg2oBkGKbPJqgXLAxCOuc5IUGjSqu04GFhBttWMjIX1DBajRSzFG1CtoFlebQMSFxoRG7YzVa4pQm80FCNgDBcE3NzMYmnnF5ZjHGqyNmvQ/1WJ1HbYRZZJIWN+Vi+yHQNvuSbWuBLCfBcdzaBGRJAqr0A3xREpY+4I4xOOhpP+8GqiWUFGRlaqjTdIZB5A17IEclFo7OCYf00j0gnMs2CgFcP2SzCn0D+zQL5Gj3SzjT6NA6Nh9kLqpVFufaaTOW3+HOPXcEgmk+ySrCMvaRCoM3XFRE4y0B4ATcVCVugg9nMF7/YeIyfw4EUdTdVES7NQ6ekodgfokIiQc074dL+KS+9PcI0acYW6u7B+issR2sNpXI2c4k6sjOV4Hdc3C7i1XcTdWB6LWxx9P8Ht7RxuEO7hF36ssE2ZeFLIkcLMmUJLRbLVx1Gjj4O6gDj3AZ+4KN1lHNZl/1tWVP23WVFDkbB1xcAfPalmZkSAL7gAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;flow&quot;
        title=&quot;&quot;
        src=&quot;/static/flow-9a783a9d3ff87177906eb81af636cc84-c83f1.png&quot;
        srcset=&quot;/static/flow-9a783a9d3ff87177906eb81af636cc84-569e3.png 240w,
/static/flow-9a783a9d3ff87177906eb81af636cc84-93400.png 480w,
/static/flow-9a783a9d3ff87177906eb81af636cc84-c83f1.png 960w,
/static/flow-9a783a9d3ff87177906eb81af636cc84-c8ec5.png 1010w&quot;
        sizes=&quot;(max-width: 960px) 100vw, 960px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    
图1：manifest的解析过程&lt;/p&gt;
&lt;p&gt;浏览器解析manifest的过程如上图所示。HTML5定义了Application Cache的几种事件，并允许JS捕获这些事件。事实上JS对application cache很难主动地进行操作，也没有读写接口，绝大部分情况下，application cache的使用是不必借助JS的。还有一点需要补充，以上是网络连接正常时的流程，当网络连接不正常时，浏览器请求manifest文件时连接失败，则进入离线模式，直接从application cache中加载页面，同时application cache会触发&lt;code&gt;error&lt;/code&gt;事件。&lt;/p&gt;
&lt;p&gt;需要注意的是，下载manifest清单里的内容是与页面载入同时进行的，也就是说，如果本次载入需要更新缓存，则本次页面载入时无法使用最新版本的缓存。&lt;/p&gt;
&lt;h3&gt;可用性&lt;/h3&gt;
&lt;p&gt;Application Cache被支持情况见下图：&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/pc-93d0b7cb137048bbd5d14e4e1da98a47-9d561.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 561px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 21.390374331550802%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAAsSAAALEgHS3X78AAAAoElEQVQI142LWQ7CMAwFe//z8YEEKo2TNFuXNK2zdAFc4ABYT6PnsVzNMUljKSGmvO3TEmNZX/9NZYfpcmuuNQjTP6S+gySy1sInXHdcO1DuNMoJ04GyQndMmjFg1Y2hZpJxrd0IUgvl6IcJDdKcbG3DFfUv6VqDJPmAtvdzFWYcfegH76eAKe3HEzGWsm37QT3lsiBS/60pY0yprOQxlzcmFuCP3aNa8gAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;pc&quot;
        title=&quot;&quot;
        src=&quot;/static/pc-93d0b7cb137048bbd5d14e4e1da98a47-9d561.png&quot;
        srcset=&quot;/static/pc-93d0b7cb137048bbd5d14e4e1da98a47-9d395.png 240w,
/static/pc-93d0b7cb137048bbd5d14e4e1da98a47-ac675.png 480w,
/static/pc-93d0b7cb137048bbd5d14e4e1da98a47-9d561.png 561w&quot;
        sizes=&quot;(max-width: 561px) 100vw, 561px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    
图2：桌面浏览器的支持情况&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/mobile-b827e1fb994b5f60c1e9f4f602ad1b1e-8a23c.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 681px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 17.474302496328928%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAAsSAAALEgHS3X78AAAAkklEQVQI1y2O6w6DIBSDff/n25KBCip42cTJxQO4eNjQLGmar+2fFrB/FuMsBLP5uhXjvCB+D0xZmLLjkS6+Il7wj5iKSa03yrl81t14J4xwUTaSMEGYLJu+6oZH3XI5VW1PmaA8lwM9125UutBue6lFvVfrwMdonHMAECL4kN0bC8MUZqWN3XzwIWrrTvAhn/0BRXCn77RTIzIAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;mobile&quot;
        title=&quot;&quot;
        src=&quot;/static/mobile-b827e1fb994b5f60c1e9f4f602ad1b1e-8a23c.png&quot;
        srcset=&quot;/static/mobile-b827e1fb994b5f60c1e9f4f602ad1b1e-80efa.png 240w,
/static/mobile-b827e1fb994b5f60c1e9f4f602ad1b1e-db079.png 480w,
/static/mobile-b827e1fb994b5f60c1e9f4f602ad1b1e-8a23c.png 681w&quot;
        sizes=&quot;(max-width: 681px) 100vw, 681px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    
图3：移动浏览器的支持情况&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/HTML/Using_the_application_cache&quot;&gt;https://developer.mozilla.org/en-US/docs/HTML/Using&lt;em&gt;the&lt;/em&gt;application_cache&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;整体上，Application Cache的受支持情况比较理想。即使对于不支持的浏览器而言，通常情况下也不会产生不一致的表现，所以兼容性问题不是应用Application Cache的拦路虎。&lt;/p&gt;
&lt;p&gt;在测试的过程中，我对浏览器允许manifest列表长度及允许的cache空间比较感兴趣。网上传言各浏览器对这两点会有限制。但在我不完备的测试中，没有发现具体的限制。在桌面版的Chrome中，缓存1000+条请求，1G+的数据均未出错；安卓手机中也尝试缓存过1000+条请求，100M+的数据，同样正常。我觉得这样的测试很极限，实际应用不可能出现这样的场景。当缓存请求数过多，数据量太大，那么在页面载入的时候会进行漫长的下载过程，对用户体验、流量和服务器来说都不合适。反过来说呢，我推测在我们正常应用范围内，不需要对cache空间和请求数目太过担心，唯一需要担心的是考虑把什么样的数据缓存起来才最合适。&lt;/p&gt;
&lt;h2&gt;优点&lt;/h2&gt;
&lt;p&gt;使用Application Cache的优点主要体现在网络性能的提升上。把一些http的请求转为从本地存储中读取，有效降低网络延迟，提升请求加载速度。这点从下面测试截图中可以看出。同时，cache的使用减少了用户网络请求的次数，从而节约了用户流量。并且能够在一定程度上降低web应用对网络的依赖性。&lt;/p&gt;
&lt;p&gt;除此之外，我觉得Application Cache的使用足够简单，向开发人员屏蔽了实现细节，只需要很小的工作量就可以使用。不仅如此，在成熟项目中使用此功能，对原有逻辑几乎没有影响，即使设备不支持也不会产生副作用。  &lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/result-707c9581755806f95f4d99537114e779-a1510.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 633px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 116.27172195892577%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAIAAACEf/j0AAAACXBIWXMAAAsSAAALEgHS3X78AAAC5klEQVQ4y11U23aqMBT0/7+s1dbatbQKcgl3RIEkCuEmnklClR6WDzHJMLNn9mZBXFf+iBf4QZadoyjquu7x9+m73nVwh/i+HwRhHCdxFF+v18U5y+IoOqsny7Lb7dY0jagFY6yua/wFeOj7U3ryPBJGEZCAYb9t20VAiO04QeAbpuk4Dq6WZZEmqWmavue5rosdIcQ5O7uOkySxYRhd32tFi9D3gVmuVt/fG7xvHEfGWT8MOOOMlWWJhZRQVVh0XXs6nVDX/X4fhmFhm8f9z89yuVyv17iKXTCDargPRV6kaTo+HlCJKnBUVxXcQV1A9n2/8Bxnt90C/Pb2tt1u67pinDdtC54iz4uiwAKKOOdYNELAIFQ7MaMs0zBWUvY3bkA2ZVSDISSO4z/gRsCytp3JPhwOYP76+ipLKmXTUjQN3pLnFxg5jg/YSynFDnQh15dsGGZbNpg3m40OhnLWqqgBKAtpWFVVwE+y4/hlmGWYu90OzJ+fn7AHB1ArRDPe73meI3kQSsM414Z5yjDQ4qZkPuz3YAYe+vFuxjiOwcMYBXjO3DYNGhGnE7NrWcbhMJcNi2shVM050pKBc65rxqvBfLtVU80OwIahc8Zt3CgguxGSmVIUot2GHO12GIavqHxCrKOlo0InyYQo1bLh1yW/SPB1lnMcv8C2aW5Vk+BBnwIGsFCyiyJPk2QuW0ZFyDyqQNcMtzFx8BDetKpJgLlccslc3fhvVJA9i8o04bZuEsBkhynZsluKIvBD7AAJOTIq2SQEQU5ReY5rHY/v7+8arBJimhngSLXnMyqUg6jaJzNRg7H6+IBy27bBKQdDtSck4NuCRVVXVzWtoq7DADm3r6jQYRgpgIMgAKfqMBkVRgqDhQVoEZUG4wvxMiwg3jOqSk08ZUxHVeZyKP8byd+pGqbe3v/sf6dKfgx0k2CYaFkmKio1VWyUNdfenNkn0jDdYVRZqmXLmrEqi0k2n2Tj8/qs+R+i0gTj42zN1AAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;result&quot;
        title=&quot;&quot;
        src=&quot;/static/result-707c9581755806f95f4d99537114e779-a1510.png&quot;
        srcset=&quot;/static/result-707c9581755806f95f4d99537114e779-e9b68.png 240w,
/static/result-707c9581755806f95f4d99537114e779-7d48d.png 480w,
/static/result-707c9581755806f95f4d99537114e779-a1510.png 633w&quot;
        sizes=&quot;(max-width: 633px) 100vw, 633px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    
图4：本地搭建环境测试结果&lt;/p&gt;
&lt;h3&gt;问题点&lt;/h3&gt;
&lt;p&gt;在测试过程中，我也发现了一些值得注意的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;新版本缓存不立刻生效问题&lt;/p&gt;
&lt;p&gt;受制于Application Cache的实现机制，当检测到Manifest新版本，并更新缓存时，页面加载过程已经开始，甚至页面加载完成时，cache更新还没有完成。于是浏览器的策略是当manifest有更新时，此次加载不会使用新版数据。不仅如此，直到下次检查manifest更新之前的所有请求的缓存均为旧版本缓存。这意味着如果页面一直不刷新，那么通过application cache请求到的都是旧版本数据。&lt;/p&gt;
&lt;p&gt;Application Cache提供了&lt;code&gt;update()&lt;/code&gt;方法来手动发起manifest版本的检测；提供了&lt;code&gt;swapCache()&lt;/code&gt;方法手动启用新版数据。如果应用对数据版本新旧不敏感，则可以使用这两个方法来保持cache最新数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Manifest中的请求路径相对于manifest文件，而非当面加载页面&lt;/p&gt;
&lt;p&gt;如果在&lt;em&gt;www.a.com/index.html&lt;/em&gt;页面上指定了manifest地址为：&lt;em&gt;www.a.com/manifest/app.cache&lt;/em&gt;，那么在manifest中定义的一条请求地址如果是a.jpg，那么它代表的URL为&lt;em&gt;www.a.com/mainifest/a.jpg&lt;/em&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;被缓存的不仅仅是manifest清单的内容  &lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/chrome-0c5aceea7325befc560b762a7d9cb7c9-8aeb9.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 508px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 19.685039370078737%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAAsSAAALEgHS3X78AAAA8klEQVQI1xXJTUvDMADG8X5yJx5UxIsbw5Mn2ToROpcJ3nbYm5ubpa9pszRp2qRdU4pvBQ92Fis8/PnBo9yMlrcTf7Dk/RlTF7E6Zw1607DBYMEeXrORLoEuta2cPBu+Y5Sfb0WeppzlWaqszWjjJiudrgz2YsVrg5ko2/Evm76b5COQFc0PzcKitoJiviFWWGJZ+eJ7tiVKF7ArIDqAt8ei+yg6Y970+im90ERL5cdqfHInjnpRqx9falFznQ3l+TA7vRdtwBXfCyiNfIgwJo4NIUSO7dmmixDBKICuh3f/SMQ+Tfaui36qw29dl2XpefgP99XCis8ui/oAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;chrome&quot;
        title=&quot;&quot;
        src=&quot;/static/chrome-0c5aceea7325befc560b762a7d9cb7c9-8aeb9.png&quot;
        srcset=&quot;/static/chrome-0c5aceea7325befc560b762a7d9cb7c9-7d484.png 240w,
/static/chrome-0c5aceea7325befc560b762a7d9cb7c9-16d6f.png 480w,
/static/chrome-0c5aceea7325befc560b762a7d9cb7c9-8aeb9.png 508w&quot;
        sizes=&quot;(max-width: 508px) 100vw, 508px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    
图5：浏览器cache情况&lt;/p&gt;
&lt;p&gt;如上图所示，被缓存的数据还包含manifest本身，其类型为Manifest，以及启用application cache的页面，其类型为Master。至于application中缓存Master类型的机制我还不是十分清楚，这里无法详谈。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;卸载application cache问题&lt;/p&gt;
&lt;p&gt;Application cache的卸载略微麻烦。文档上说只要当manifest请求返回4xx即可卸载application cache，但实际操作下来发现，需要给&lt;strong&gt;所有&lt;/strong&gt;类型为Master的页面指定一个不存在有manifest，才可以卸载cache，而且这个过程也不是实时的，往往有一定的延迟，可能与浏览器的实现有关。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;“回滚悖论”&lt;/p&gt;
&lt;p&gt; 这个问题很少被人提到，名字我自己取的，但在我的测试中，这个问题相当典型。目前浏览器在解析manifest的策略有这样两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果处理manifest清单过程中触发&lt;code&gt;error&lt;/code&gt;事件，则为保证内容一致性，废弃此次所有下载的内容，使用旧版本数据；&lt;/li&gt;
&lt;li&gt;如果下载文件失败，则触发&lt;code&gt;error&lt;/code&gt;事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设现在manifest清单上有一个文件的访问出现异常，例如restful服务调整、图片名称变更等等，哪怕这个文件根本用不到，它也会导致整个application cache更新失败。浏览器执行这样策略的出发点是为了保证application cache中的内容保持同一版本，但似乎矫枉过正。实际应用中我们无法改变这个策略，但需要知道这里的风险，当清单中有文件无法下载，则会导致缓存永远无法更新，直到manifest文件修复。在此期间，浏览器每次都加执行manifest的解析、下载、失败、回滚这样的循环，造成服务器和网络的浪费。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;“更新悖论”&lt;/p&gt;
&lt;p&gt;其实上一个问题称之为“悖论”有点夸张，但这个问题却不一定。考虑这样一个问题，如果我们将index.html的manifest的指向从a.cache改为b.cache会发生什么。答案是如果不更新或删除a.cache的内容，缓存将不更新。原因是index.html被浏览器缓存了，每次解析的时候仍然是检查a.cache的更新情况，即使我们在更新资源的同时，记得更新b.cache，结果每次检查的结果也全是&lt;code&gt;noupdate&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多页面多manifest与多页面单manifest&lt;/p&gt;
&lt;p&gt;首先需要留意application cache是由manifest管理的。例如 &lt;em&gt;a.html&lt;/em&gt; 的manifest为 &lt;em&gt;a.cache&lt;/em&gt;，&lt;em&gt;b.html&lt;/em&gt; 的manifest为 &lt;em&gt;b.cache&lt;/em&gt;，两个manifest都加入了&lt;em&gt;common.js&lt;/em&gt;的缓存。现在更新了 &lt;em&gt;common.js&lt;/em&gt; 的内容，并修改了两个manifest的版本号，如果加载 &lt;em&gt;a.html&lt;/em&gt;，则 &lt;em&gt;common.js&lt;/em&gt; 会更新到application cache中，那么再加载&lt;em&gt;b.html&lt;/em&gt;时，从application cache中读出的是新版本的common.js还是旧版本的呢？是旧版本的，因为每个manifest独立管理自己的application cache内容，虽然在同一个站点下，虽然请求内容完全一样，但 &lt;em&gt;common.js&lt;/em&gt;却是被缓存在两处，彼此独立。&lt;/p&gt;
&lt;p&gt; 类似的，&lt;em&gt;a.html&lt;/em&gt; 和 &lt;em&gt;b.html&lt;/em&gt; 的manifest都是 &lt;em&gt;a.cache&lt;/em&gt;，现在更新了 &lt;em&gt;common.js&lt;/em&gt; 和 &lt;em&gt;a.cache&lt;/em&gt;，如果加载了 &lt;em&gt;a.html&lt;/em&gt;，&lt;em&gt;common.js&lt;/em&gt; 更新到了application cache中，那么此时加载 &lt;em&gt;b.html&lt;/em&gt; 会加载新版本还是旧版本的 &lt;em&gt;common.js&lt;/em&gt; 呢？是新版本，因为两个页面的 &lt;em&gt;common.js&lt;/em&gt; 由同一个manifest管理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;受制于HTTP报头的&lt;code&gt;Cache-control&lt;/code&gt;字段&lt;/p&gt;
&lt;p&gt;若此字段设置为&lt;code&gt;no-cache&lt;/code&gt;，则不通过application cache获取数据。但检查manifest的流程并没有变，依然会更新最新的manifest，并下载manifest内规定的文件。
所以通过ajax请求数据，且希望使用到application cache时，注意配置（如有必要）：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;$&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;ajaxSetup&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    cache&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Application cache更新进度的问题&lt;/p&gt;
&lt;p&gt;如果需要追踪Application cache的更新进度，理论上可以通过监听application cache的&lt;code&gt;progress&lt;/code&gt;事件来完成，每个文件下载时会触发&lt;code&gt;progress&lt;/code&gt;事件。但由于manifest解析流程和页面加载流程同时进行，所以在处理&lt;code&gt;progress&lt;/code&gt;事件时极有可能do
m或js库尚未加载，可能很难在页面上做呈现。不过如果手动触发&lt;code&gt;update()&lt;/code&gt;方法，并监听&lt;code&gt;progress&lt;/code&gt;事件，相对会可控得多。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;我认为使用application cache从技术上和可用性上而言，实现成本比较低，开发量比较少，副作用比较小，适用性比较广。但怎么用，用多少是需要考虑的点。由于原理上，application cache是把manifest上的资源一起下载下来，所以manifest里的内容不宜过多，数据量不宜过大；由于manifest的解析通常以页面刷新为触发点，且更新的缓存不会立即被使用，所以缓存的资源应以静态资源、更新频率比较低的资源为主。另外要做好对manifest文件的管理，避免上面所提的由于清单内文件不可访问或manifest更新不及时造成的一些问题。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[fibers in Node.js]]></title><description><![CDATA[fiber/纤程 在操作系统中，除了进程和线程外，还有一种较少应用的 纤程 （fiber…]]></description><link>https://www.zhouhua.info//2014/fibers/</link><guid isPermaLink="false">https://www.zhouhua.info//2014/fibers/</guid><pubDate>Thu, 13 Mar 2014 22:38:40 GMT</pubDate><content:encoded>&lt;h2&gt;fiber/纤程&lt;/h2&gt;
&lt;p&gt;在操作系统中，除了进程和线程外，还有一种较少应用的&lt;strong&gt;纤程&lt;/strong&gt;（fiber，也叫协程）。纤程常常拿来跟线程做对比，对于操作系统而言，它们都是较轻量级的运行态。通常认为纤程比线程更为轻量，开销更小。不同之处在于，纤程是由线程或纤程创建的，纤程调度完全由用户代码控制，对系统内核而言，是一种非抢占性的调度方式，纤程实现了合作式的多任务；而线程和进程则受内核调度，依照优先级，实现了抢占式的多任务。另外，系统内核是不知道纤程的具体运行状态，纤程的使用其实是比较与操作系统无关。&lt;/p&gt;
&lt;p&gt;在Node.js中，单线程是仅针对javascript而言的，其底层其实充斥着多线程。而如果需要在javascript中实现多线程，一种常见的做法是编写C++ addon，绕过javascript的单线程机制。不过这种方法提升了开发调试的难度和成本。像其他很多脚本语言，我们也可以把纤程的概念引入到Node.js中。&lt;/p&gt;
&lt;h2&gt;node-fibers&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;node-fibers&lt;/code&gt;这个库就为Node.js提供了纤程的功能。多线程方面没有测试出理想的结果，不过在异步转同步作用显著，也许在减少Node.js调用堆栈、无限递归方面也会有价值可挖。本文档主要介绍&lt;code&gt;node-fibers&lt;/code&gt;库的使用方法和异步转同步等内容。&lt;/p&gt;
&lt;h3&gt;安装&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;node-fibers&lt;/code&gt;是采用C语言编写，直接下载源码需要编译，通常直接npm安装即可：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm install fibers&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;fibers库的使用&lt;/h3&gt;
&lt;h4&gt;API&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Fiber(fn)&lt;/code&gt;/&lt;code&gt;new Fiber(fn)&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;创建一个纤程，可以当成构造函数使用，也可以当成普通函数调用。如下例：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fibo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;n&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; n &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;gt&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fibo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;n &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fibo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;n &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;Fiber&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;fibo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;当&lt;code&gt;run()&lt;/code&gt;调用的时候，纤程启动，并为&lt;code&gt;fn&lt;/code&gt;分配新的堆栈，&lt;code&gt;fn&lt;/code&gt;会在这个新的堆栈上运行，直到&lt;code&gt;fn&lt;/code&gt;有返回值或调用&lt;code&gt;yield()&lt;/code&gt;。&lt;code&gt;fn&lt;/code&gt;返回后或调用&lt;code&gt;yield()&lt;/code&gt;后，堆栈重置，当再次调用&lt;code&gt;run()&lt;/code&gt;时，纤程会再次启动，&lt;code&gt;fn&lt;/code&gt;运行于首次分配的堆栈中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Fiber.current&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;获得当前纤程，并可对其进行操作。如果指定一个变量与其相关联，请务必确保此纤程能够释放，否则V8的垃圾回收机制会一直忽略这部分的内存，造成内存泄漏。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Fiber.yield(param)&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;前面的说明中已经提及过这个函数。&lt;code&gt;yield()&lt;/code&gt;方法用于中断纤程，一定程度上类似&lt;code&gt;return&lt;/code&gt;。一旦执行&lt;code&gt;yield()&lt;/code&gt;，则此&lt;code&gt;Fiber&lt;/code&gt;中后续代码将没有机会执行，例如：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; fiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Fiber&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Fiber Start&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    Fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Fiber Stop&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 输出: &quot;Fiber Start&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;执行后只会输出“Fiber Start”，后一个输出命令没有执行。如果向&lt;code&gt;yield()&lt;/code&gt;传入参数，那么此参数作为&lt;code&gt;run()&lt;/code&gt;的返回值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; fiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Fiber&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    Fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;success&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// -&gt; &quot;success&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Fiber.prototype.run(param)&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;这个方法已经很熟悉了，之前隐约有提及调用&lt;code&gt;run()&lt;/code&gt;的两种时态，一是Fiber未启动时，一时Fiber被yield时。在这两种时态下，&lt;code&gt;run()&lt;/code&gt;的行为并不太一样。
当Fiber未启动时，&lt;code&gt;run()&lt;/code&gt;接受一个参数，并把它传递给&lt;code&gt;fn&lt;/code&gt;，作为其参数。当Fiber处理yielding状态时，&lt;code&gt;run()&lt;/code&gt;接受一个参数，并把它作为&lt;code&gt;yield()&lt;/code&gt;的返回值，fn并不会从头运行，而是从中断处继续运行。关于&lt;code&gt;fn&lt;/code&gt;、&lt;code&gt;yield&lt;/code&gt;、&lt;code&gt;run&lt;/code&gt;三者的参数、返回值等关系，可以通过下面的小例子来说明：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; Fiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;fibers&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; fiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Fiber&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;第一次调用run:&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;fn参数为：&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; b &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;yield&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;第二次调用run:&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;fn参数为：&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;yield返回值为：&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;return&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 第一次运行run()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; c&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;One&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 第二次运行run()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; d&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Two&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;调用yield，run返回：&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;fn运行完成，run返回：&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;d&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-text&quot;&gt;&lt;code&gt;/*
第一次调用run:
fn参数为：One
第二次调用run:
fn参数为：One
yield返回值为：Two
调用yield，run返回：yield
fn运行完成，run返回：return
*/&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;从上面例子中，可以很明显看出&lt;code&gt;yield&lt;/code&gt;的使用方法与现在的javascript的语法相当不同。在别的语言中（C#、Python等）已经实现了&lt;code&gt;yield&lt;/code&gt;关键字，作为迭代器的中断。不妨在Node.js上也实现一个迭代器，具体体会一下&lt;code&gt;yield&lt;/code&gt;的使用。还是以开头的斐波那契数列为例：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;fiboGenerator&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
            Fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            b &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
            b &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; b &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
            Fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; f &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Fiber&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiboGenerator&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
f&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; f&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;run&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;f&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;输出为：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-text&quot;&gt;&lt;code&gt;/*
1
1
2
3
5
8
13
21
34
55
*/&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;有两个问题需要留意，第一，&lt;code&gt;yield&lt;/code&gt;说是方法，更多地像关键字，与&lt;code&gt;run&lt;/code&gt;不同，&lt;code&gt;yield&lt;/code&gt;不需要依托Fiber实例，而&lt;code&gt;run&lt;/code&gt;则需要。如果在Fiber内部调用&lt;code&gt;run&lt;/code&gt;，则一定要使用：&lt;code&gt;Fiber.current.run()&lt;/code&gt;；第二，&lt;code&gt;yield&lt;/code&gt;本身为javascript的保留关键字，不确定是否会、何时会启用，所以代码在将来可能会面临变更。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Fiber.prototype.reset()&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;我们已经知道Fiber可能存在不同的时态，同时会影响&lt;code&gt;run&lt;/code&gt;的行为。而&lt;code&gt;reset&lt;/code&gt;方法则不管Fiber处理什么状态，都恢复到初始状态。随后再执行&lt;code&gt;run&lt;/code&gt;，就会重新运行&lt;code&gt;fn&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Fiber.prototype.throwInto(Exception)&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;本质上&lt;code&gt;throwInto&lt;/code&gt;会抛出传给它的异常，并将异常信息作为&lt;code&gt;run&lt;/code&gt;的返回值。如果在Fiber内不对它抛出的异常作处理，异常会继续冒泡。不管异常是否处理，它会强制&lt;code&gt;yield&lt;/code&gt;，中断Fiber。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;future库的使用&lt;/h3&gt;
&lt;p&gt;在Node.js中直接使用Fiber并不一直是合理的，因为Fiber的API实在简单，实际使用中难免会产生重复冗长的代码，不利于维护。推荐在Node.js与Fiber之间增加一层抽象，让Fiber能够更好地工作。&lt;code&gt;future&lt;/code&gt;库就提供了这样一种抽象。&lt;code&gt;future&lt;/code&gt;库或者任何一层抽象也许都不是完美的，没有谁对谁错，只有适用不适用。比如，&lt;code&gt;future&lt;/code&gt;库向我们提供了简单的API能够完成异步转同步的工作，然而它对封装 generator （类似上面的斐波那契数列生成器）则无能为力。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;future&lt;/code&gt;库不需要单独下载安装，已经包含在&lt;code&gt;fibers&lt;/code&gt;库中，使用时只需要 &lt;code&gt;var future=require(&apos;fibers/future&apos;)&lt;/code&gt; 即可。&lt;/p&gt;
&lt;h4&gt;API&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Function.prototype.future()&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;给&lt;code&gt;Function&lt;/code&gt;类型添加了&lt;code&gt;future&lt;/code&gt;方法，将function转化成一个“funture-function”。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;futureFun&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;power&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;futureFun&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;实际上&lt;code&gt;power&lt;/code&gt;方法是在Fibel内执行的。不过现有版本的&lt;code&gt;future&lt;/code&gt;有bug，官方没有具体的说明，如果需要使用此功能，请删除掉&lt;code&gt;future.js&lt;/code&gt;的第339行和第350行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;new Future()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Future&lt;/code&gt;对象的构造函数，下文详细介绍。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Future.wrap(fn, idx)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wrap&lt;/code&gt;方法封装了异步转同步的操作，是&lt;code&gt;future&lt;/code&gt;库中对我们最有价值的方法。&lt;code&gt;fn&lt;/code&gt;表示需要转换的函数，&lt;code&gt;idx&lt;/code&gt;表示&lt;code&gt;fn&lt;/code&gt;接受的参数数目，认为其&lt;code&gt;callback&lt;/code&gt;方法为最后一个参数（这边API的制定颇有争议，有人倾向传递&lt;code&gt;callback&lt;/code&gt;应该处于的位置，好在&lt;code&gt;wrap&lt;/code&gt;方法比较简单，可以比较容易修改代码）。看一个例子就能了解&lt;code&gt;wrap&lt;/code&gt;的用法：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; readFileSync &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Future&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;wrap&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;fs&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;readFile&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;Fiber&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; html &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;readFileSync&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;./1.txt&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;html&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;从这个例子中可以看出Fiber异步转同步确实非常有效，除了语法上多了一步&lt;code&gt;.wait()&lt;/code&gt;外，其他已经&lt;code&gt;fs&lt;/code&gt;提供的&lt;code&gt;fs.readFileSync&lt;/code&gt;方法别无二致了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Future.wait(futures)&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;这个方法前面已经多次看到了。顾名思义，它的作用就是等待结果。如果要等待一个future的实例的结果，直接调用&lt;code&gt;futureInstance.wait()&lt;/code&gt;即可；如果需要等待一系列future实例的结果，则调用&lt;code&gt;Future.wait(futuresArray)&lt;/code&gt;。需要注意的是，在第二种用法中，一个future实例在运行时出现错误，&lt;code&gt;wait&lt;/code&gt;方法不会抛出错误，不过我们可以使用&lt;code&gt;get()&lt;/code&gt;方法直接获取运行结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Future.prototype.get()&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;get()&lt;/code&gt;的用法与&lt;code&gt;wait()&lt;/code&gt;的第一种方式很像，所不同的是，&lt;code&gt;get()&lt;/code&gt;立刻返回结果。如果数据没有准备好，&lt;code&gt;get()&lt;/code&gt;会抛出错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Future.prototype.resolve(param1,param2)&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;上面的的&lt;code&gt;wrap&lt;/code&gt;方法总给人以一种&lt;code&gt;future&lt;/code&gt;其实在吞噬异步方法的回调函数，并直接返回异步结果。事实上&lt;code&gt;future&lt;/code&gt;也通过&lt;code&gt;resolve&lt;/code&gt;方法提供设置回调函数的解决方案。&lt;code&gt;resolve&lt;/code&gt;最多接受两个参数，如果只传入一个参数，&lt;code&gt;future&lt;/code&gt;认为传了一个Node.js风格的回调函数，例如如下示例：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;futureInstance&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;err&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; data&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;err&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;throw&lt;/span&gt;  err&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;如果传入两个参数，则表示对错误和数据分别做处理，示例如下：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;futureInstance&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;err&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;throw&lt;/span&gt; err&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;另外&lt;code&gt;future&lt;/code&gt;并不区分&lt;code&gt;resolve&lt;/code&gt;的调用时机，如果数据没有准备好，则将回调函数压入队列，由&lt;code&gt;resolver()&lt;/code&gt;方法统一调度，否则直接取数据立即执行回调函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Future.prototype.isResolved()&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;返回布尔值，表示操作是否已经执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Future.prototype.proxy(futureInstance)&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;proxy&lt;/code&gt;方法提供一种&lt;code&gt;future&lt;/code&gt;实例的代理，本质上是对&lt;code&gt;resolve&lt;/code&gt;方法的包装，其实是将一个instance的回调方法作为另一个instance的回调执行者。例如：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; target &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
target&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;err&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; data&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;proxyFun&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;num&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; cb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;cb&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; num &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; num&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;Fiber&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; proxy &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Future&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;wrap&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;proxyFun&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    proxy&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;proxy&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;target&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 输出100&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;虽然执行的是&lt;code&gt;proxy&lt;/code&gt;，但是最终&lt;code&gt;target&lt;/code&gt;的回调函数执行了，并且是以&lt;code&gt;proxy&lt;/code&gt;的执行结果驱动&lt;code&gt;target&lt;/code&gt;的回调函数。这种代理手段也许在我们的实际应用中有很大作用，我暂时还没有深入地思考过。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Future.prototype.return(value)&lt;/code&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Future.prototype.throw(error)&lt;/code&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Future.prototype.resolver()&lt;/code&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Future.prototype.detach()&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;以上四个API呢我感觉相对于别的API，实际使用的场景或作用比较一般。&lt;code&gt;return&lt;/code&gt;和&lt;code&gt;throw&lt;/code&gt;都受&lt;code&gt;resolver&lt;/code&gt;方法调度，这三个方法都很重要，在正常的future使用流程中都会默默工作着，只是我没有想出具体单独使用它们的场景，所以没有办法具体介绍。&lt;code&gt;detach&lt;/code&gt;方法只能算&lt;code&gt;resolve&lt;/code&gt;方法的简化版，亦没有介绍的必要。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;updated 2017/02/13
es6的generator function特性已能完全实现fiber的所有功能。辅助es7的async/await语法，我们可以很轻松地处理异步问题。&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[如何在Node.js环境下操作DOM]]></title><description><![CDATA[Javascript之所以为Javascript，很重要的原因是浏览器为其实现了DOM和BOM接口（ 参考 ）。但在Node.js环境下，并没有DOM和BOM，所以html文档与其他类型的文档并无不同，很难进行处理。而前端大量的js类库在Node.js…]]></description><link>https://www.zhouhua.info//2014/nodedom/</link><guid isPermaLink="false">https://www.zhouhua.info//2014/nodedom/</guid><pubDate>Wed, 05 Mar 2014 22:32:36 GMT</pubDate><content:encoded>&lt;p&gt;Javascript之所以为Javascript，很重要的原因是浏览器为其实现了DOM和BOM接口（&lt;a href=&quot;http://www.w3school.com.cn/js/pro_js_implement.asp&quot;&gt;参考&lt;/a&gt;）。但在Node.js环境下，并没有DOM和BOM，所以html文档与其他类型的文档并无不同，很难进行处理。而前端大量的js类库在Node.js环境下也毫无用武之地。这篇文档就来探究一下，如何在Node.js端进行DOM操作。&lt;/p&gt;
&lt;h2&gt;使用jsdom&lt;/h2&gt;
&lt;p&gt;虽然Node.js没有DOM支持，但我们可以自己构建一个DOM，而&lt;code&gt;jsdom&lt;/code&gt;这个库就是用来帮助我们完成这个任务的，它使用javascript构建了符合W3标准的DOM。&lt;/p&gt;
&lt;h3&gt;安装&lt;/h3&gt;
&lt;p&gt;jsnode本身是javascript的，但它有一个依赖项&lt;code&gt;Contextify&lt;/code&gt;是用C++编写的。这个依赖项的功能是处理页面内的&lt;code&gt;script&lt;/code&gt;标签中的js代码，把javascript在一个独立的模拟浏览器环境下运行。所以这个依赖项提供了一个非常重要的特性。从Node.js中加载一个基于C++的模块，可能在windows下出现一些问题，如果在windows下安装不成功，请尝试安装32位版的Node.js再试。另外Node.js加载本地模块还需要Python的支持。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Windows&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;请确认安装了visual studio;&lt;/li&gt;
&lt;li&gt;安装Python 2.7（&lt;a href=&quot;http://www.python.org/download/&quot;&gt;点击下载&lt;/a&gt;），并把Python安装路径添加到系统变量；&lt;/li&gt;
&lt;li&gt;安装最新版的Node.js，最好是x86版本的（我用x64版本测试成功）；&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;npm install npm&lt;/code&gt;更新npm到最新版本；&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;npm install jsdom&lt;/code&gt;安装jsdom。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mac OS&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;请确认安装了Xcode;&lt;/li&gt;
&lt;li&gt;需要安装“Command line tools for XCode”；&lt;/li&gt;
&lt;li&gt;启动过Xcode，并同意授权条款；&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;npm install jsdom&lt;/code&gt;安装jsdom。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linux（文档不详，未验证）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;请确认安装了make等编译工具；&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;npm install jsdom&lt;/code&gt;安装jsdom；&lt;/li&gt;
&lt;li&gt;使用make编译Contextify。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;简单模式&lt;/h3&gt;
&lt;p&gt;jsdom提供了&lt;code&gt;env()&lt;/code&gt;方法可以很轻松地使用jsdom的强大功能。其定义如下：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;jsdom&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;string&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;scripts&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;config&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; callback&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;参数&lt;code&gt;string&lt;/code&gt;：可以是一个url、文件名或HTML片断。&lt;/li&gt;
&lt;li&gt;参数&lt;code&gt;script&lt;/code&gt;：类型为string或string数组，表示javascript文件的路径或url，这些javascript文件最后会通过&lt;code&gt;script&lt;/code&gt;标签引用，并&lt;strong&gt;附加到body末尾&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;参数&lt;code&gt;config&lt;/code&gt;：类似于jquery的一些函数参数列表的定义思路，&lt;code&gt;env()&lt;/code&gt;允许不使用string、script、callback等参数，而直接传入一个config对象包含各种配置信息，当然，config中也可以定义一些其他的配置选项。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数&lt;code&gt;callback&lt;/code&gt;：回调方法，callback接受两个参数，&lt;code&gt;error&lt;/code&gt;和&lt;code&gt;window&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参数&lt;code&gt;error&lt;/code&gt;：可能是一个object，为初始化window时抛出的错误；也可能是一个数组，为DOM收集到的脚本错误。&lt;/li&gt;
&lt;li&gt;参数&lt;code&gt;window&lt;/code&gt;：生成的一个全新的window对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;喜闻乐见的示例1：使用url&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; jsdom &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;jsdom&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

jsdom&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token string&quot;&gt;&quot;http://nodejs.org/dist/&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;http://code.jquery.com/jquery.js&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;errors&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; window&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;there have been&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; window&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;nodejs releases!&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;此示例直接把要加载的html的url传入进行处理。注意传入的jquery完全是前端使用的js类型，不需要额外对引入的类库做任何处理即可在Node.js端使用它们进行文档处理。不过与前端代码稍有不同的是我们要留意此时window域内的方法对象并不能像在前端代码中那样直接获取，例如，我们并不能直接使用&lt;code&gt;$&lt;/code&gt;，而是需要使用&lt;code&gt;window.$&lt;/code&gt;，如果为了简便使用，可以定义好&lt;code&gt;var $=windwo.$&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;喜闻乐见的示例2：使用html片断&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; jsdom &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;jsdom&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

jsdom&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token string&quot;&gt;&apos;&amp;amp;lt;p&amp;amp;gt;&amp;amp;lt;a class=&quot;the-link&quot; href=&quot;https://github.com/tmpvar/jsdom&quot;&amp;amp;gt;jsdom\&apos;s Homepage&amp;amp;lt;/a&amp;amp;gt;&amp;amp;lt;/p&amp;amp;gt;&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;http://code.jquery.com/jquery.js&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;errors&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; window&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;contents of a.the-link:&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; window&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;a.the-link&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;类似的，我们可以通过Node.js的&lt;code&gt;fs&lt;/code&gt;模块读取本地的view，再传入env()作处理。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;喜闻乐见的示例3：使用config对象&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; jsdom &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;jsdom&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; fs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;fs&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; jquery &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;readFileSync&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;./jquery.js&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

jsdom&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  url&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;http://news.ycombinator.com/&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  src&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;jquery&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  done&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;errors&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; window&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; $ &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; window&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;$&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;HN Links&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;td.title:not(:last) a&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot; -&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;这个示例展示了通过config对象使用env()方法，这段代码同时也说明了javascript代码也是可以直接读取本地文件并插入到html内的。&lt;/p&gt;
&lt;h3&gt;高级模式&lt;/h3&gt;
&lt;p&gt;上面的用法应该已经能满足一定的需求，但它的不足在于不支持html代码中定义的外部script、img等资源。还有，在简单模式下，一次只能有一个window对象存在，不能同时处理多个文档。如果有这类的需要，我们可以使用高级模式。jsdom使用的高级模式的方法是&lt;code&gt;jsdom()&lt;/code&gt;。请参见如下代码：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; jsdom &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;jsdom&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;jsdom&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; doc &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;jsdom&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;markup&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; level&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; options&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; window &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; doc&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;parentWindow&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;与简单模式不同的是，它不是采用异步回调的方式，而是采用同步的方式，直接将window对象暴露出来，这意味着在同一段代码域中，可以有多个完全隔离的window对象，可以同时处理多个文档。第二行向jsdom()方法传入了三个参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参数&lt;code&gt;markup&lt;/code&gt;：markup表示是的传入的HTML/XML文档（文档片断或空字符串也支持），我们也可以传入null或undefined来生成空白的html文档。&lt;/li&gt;
&lt;li&gt;参数&lt;code&gt;level&lt;/code&gt;：指定DOM级别，默认是DOM 3级。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数&lt;code&gt;option&lt;/code&gt;：option对象与简单模式下的option参数基本相同，不过它拥有一个&lt;code&gt;features&lt;/code&gt;选项控制着对外部资源的加载情况，具体如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;FetchExternalResources&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认值：&lt;code&gt;[&quot;script&quot;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;允许值：&lt;code&gt;[&quot;script&quot;, &quot;img&quot;, &quot;css&quot;, &quot;frame&quot;, &quot;iframe&quot;, &quot;link&quot;]&lt;/code&gt;或&lt;code&gt;false&lt;/code&gt;
——是否允许从文件系统或网络获取文件，以及什么类型的文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ProcessExternalResources&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认值：&lt;code&gt;[&quot;script&quot;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;允许值：&lt;code&gt;[&quot;script&quot;]&lt;/code&gt;或&lt;code&gt;false&lt;/code&gt;
——是否允许执行外部脚本。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SkipExternalResources&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认值：&lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;允许值：&lt;code&gt;/url/&lt;/code&gt;或&lt;code&gt;false&lt;/code&gt;
——指定不下载、不执行的资源URL的正则。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Canvas支持&lt;/h3&gt;
&lt;p&gt;jsdom本身不对canvas支持，会把它当成div处理，如果需要支持canvas，则需要添加&lt;code&gt;canvas&lt;/code&gt;包，安装方法（&lt;a href=&quot;https://www.npmjs.org/package/canvas&quot;&gt;点击查看详情&lt;/a&gt;）：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;token function&quot;&gt;npm&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;install&lt;/span&gt; canvas
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;h3&gt;注意事项&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;区分两种window
使用jsdom确实能模拟出一个window，让我们能在Node.js端书写前端代码，但一定要区分这个window与浏览器运行时的window对象不是一回事。在浏览器渲染页面时，浏览器找不到我们定义在Node.js端window上的函数、变量。在Node.js端进行的一些事件绑定也只会绑到模拟出来的dom上，浏览器呈现的时候并不会具有这些事件的绑定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;script参数指定的javascript永远在body最末
虽然没有看到具体文档说明，但在我测试下来呈现这样的情况，因此，如果有多个javascript、多种引入方式，特别是在Node.js端向html插入script节点时，特别要注意先后依赖关系，建议不要通过script参数传入js文件，而是直接以script标签写在html中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;jsdom似乎不支持ajax
没有在jsdom中看到有关xmlHttpRequest的实现，测试结果也是无法使用ajax。可能需要针对Node.js重写zepto的ajax方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[CSS性能优化系列之加载原理]]></title><description><![CDATA[无论是一位前端开发人员，还是一位产品设计人员，永远需要把用户体验放在第一位。只有良好的用户体验才会带来用户的持续关注和产品使用。那么，对于网站的设计来说，良好的用户体验又是如何建立的呢？因素很多，例如快速响应、良好交互、配色和谐、高易用性、风格统一等等，不过我认为有以下几个方面是在进行CSS…]]></description><link>https://www.zhouhua.info//2013/load/</link><guid isPermaLink="false">https://www.zhouhua.info//2013/load/</guid><pubDate>Sat, 27 Jul 2013 22:20:13 GMT</pubDate><content:encoded>&lt;p&gt;无论是一位前端开发人员，还是一位产品设计人员，永远需要把用户体验放在第一位。只有良好的用户体验才会带来用户的持续关注和产品使用。那么，对于网站的设计来说，良好的用户体验又是如何建立的呢？因素很多，例如快速响应、良好交互、配色和谐、高易用性、风格统一等等，不过我认为有以下几个方面是在进行CSS开发时尤其需要关注的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;响应速度。毫无疑问，这是用户体验的第一道关卡。网站没有理由要求用户每次花费10秒的时间用在网页载入上，太多的等待或许让网站的精彩内容来不及呈现在用户面前。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高可用性。网站很难限制用户使用何种设备、使用何种浏览器进行访问。如果用户不能够以他最熟悉的方式访问一个网站，也就意味着网站将要失去这个用户。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;《CSS性能优化》系列文章针对提升响应速度，对CSS的性能优化做一些研究，并给出一些优化建议。俗话说，磨刀不误砍柴工。今天我们先要聊的不是具体的优化建议，而是CSS的加载过程。&lt;/p&gt;
&lt;p&gt;回想一下前后端的交互过程，可以总结出网页上一个文件的传输过程，从URL请求开始，大致经历了以下步骤：&lt;/p&gt;
&lt;p&gt; 
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/steps-4c7b8765be03b674e370c45a33b46b21-6f419.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 900px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 19.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsSAAALEgHS3X78AAABF0lEQVQY0z2Py0rDQBSGU3eCYF14ARfewMszCT6H4MIn8AF8AtdqkzbJpKbTSeqlmqSZJDOTKWmsIlLEjQsL1TiTFs/m+8/l/+EoxyeniizKs01Jng2XehGtSv0++tySZP3BhmTXwwtivyJ1wvrb012+xgcv81LHlJdZCnJvD+u6Wfg9bDd0c2iAZt598ltXNW1CGdfsVnv86AUdiByq1vURjollQ/QbRola0+pfummBoiiU/3I6d0emdVMEYYRA034Vx88i0Lm8VieEcVP0Yy8I79vITRsG+IgJgxC5P1FCgQGsb+GFIrBShr3luGQYs70p01Ufk+XyrTTblwww2T07v5iD7kMVE74uZ16YHMx8O0Ivzu4qf1BjsHeKLeF5AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;steps&quot;
        title=&quot;&quot;
        src=&quot;/static/steps-4c7b8765be03b674e370c45a33b46b21-6f419.png&quot;
        srcset=&quot;/static/steps-4c7b8765be03b674e370c45a33b46b21-e02c0.png 240w,
/static/steps-4c7b8765be03b674e370c45a33b46b21-3120d.png 480w,
/static/steps-4c7b8765be03b674e370c45a33b46b21-6f419.png 900w&quot;
        sizes=&quot;(max-width: 900px) 100vw, 900px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    
图1：网页HTTP请求过程&lt;/p&gt;
&lt;p&gt;下面就一起来详细了解一下这几个步骤。&lt;/p&gt;
&lt;h2&gt;1. 缓存读取（Cache Read）&lt;/h2&gt;
&lt;p&gt;缓存是技术人员经常会听到的一个词，这里的缓存指的是浏览器缓存。图片、CSS文件、JS文件，甚至是每一次的AJAX请求数据，浏览器获得这些数据后通常都会临时保存在缓存里。一段时间内，当需要再次使用这些数据时，不必重新向服务器请求，直接从本地缓存中获得这些数据，从而加快网页的加载速度。&lt;/p&gt;
&lt;p&gt;具体到CSS文件，当浏览器要请求一个CSS文件之前，它会先根据这个CSS文件的URL在缓存中查找，如果缓存查找成功，则直接进入渲染环节；否则，需要从服务器上获取此文件后，再进入渲染环节。不过，缓存可不是一直存在于用户浏览器中的，任何缓存数据都可能会失效。一旦缓存失效了，浏览器请求这个CSS的时候，就必须向服务器获取了。下图是对微软首页一个CSS文件的请求信息分析，可以看到，在响应消息头字段中，有一个&lt;code&gt;Expires&lt;/code&gt;策略（HTTP 1.0规范，标记该文件在缓存中失效的时间）和&lt;code&gt;Cache-Control&lt;/code&gt;策略的&lt;code&gt;max-age&lt;/code&gt;属性（HTTP 1.1规范，标记该文件在缓存中的生存期，现代浏览器均优先采用此策略）。&lt;/p&gt;
&lt;p&gt;  
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/cache-69b56593ab37e070e6e21b9bb40571fd-f1b79.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 702px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 61.53846153846154%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAgAF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB2iWUo//EABkQAAIDAQAAAAAAAAAAAAAAAAABAhESIf/aAAgBAQABBQLPKZQpuQhn/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFxABAAMAAAAAAAAAAAAAAAAAEAARIf/aAAgBAQAGPwI2U//EABsQAAMAAgMAAAAAAAAAAAAAAAABESExQVGR/9oACAEBAAE/IZXYXAj0MgSkFjtNz//aAAwDAQACAAMAAAAQJM//xAAWEQEBAQAAAAAAAAAAAAAAAAABEBH/2gAIAQMBAT8QDZ//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAZEAEBAQEBAQAAAAAAAAAAAAABEQAxIXH/2gAIAQEAAT8QsLIPBMjNvGWBUuGmhePIY0/N/9k=&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;cache&quot;
        title=&quot;&quot;
        src=&quot;/static/cache-69b56593ab37e070e6e21b9bb40571fd-f1b79.jpg&quot;
        srcset=&quot;/static/cache-69b56593ab37e070e6e21b9bb40571fd-8449b.jpg 240w,
/static/cache-69b56593ab37e070e6e21b9bb40571fd-c35c1.jpg 480w,
/static/cache-69b56593ab37e070e6e21b9bb40571fd-f1b79.jpg 702w&quot;
        sizes=&quot;(max-width: 702px) 100vw, 702px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;图2：缓存有效期分析&lt;/p&gt;
&lt;h2&gt;2. 连接等待（Blocked）&lt;/h2&gt;
&lt;p&gt;当浏览器需要请求一个URL时，有时候并不能立即执行。那是因为浏览器对同一个主机名下的连接数量有限制。例如打开微软首页的时候，会有很多的文件需要下载，像CSS、图片之类的文件是可以并行下载的。然而，对于并发连接数不同的浏览器有不同的限制，一旦一个请求超出了当前并发数目的限制，则不能立刻开始，而是进入等待队列，这段时间就是“Blocked”。列举几个浏览器默认的并发连接数如下表。（注意：浏览器的并发连接数往往是可以修改的，所以此数据仅供参考，不可作为开发依据。）&lt;/p&gt;
&lt;p&gt;表1：浏览器默认并发连接数&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;浏览器&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;HTTP 1.1 并发连接数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;IE 6，IE 7&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;IE 8，IE 9&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Firefox 2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Firefox 3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Safari 3，Safari 4&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Chrome 1，Chrome 2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Chrome 3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Chrome 4及以上版本&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Opera 9.63，Opera 10.00 alpha&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Opera 10.51及以上版本&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Android 2-4（默认）&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;3. DNS查找（DNS Lookup）&lt;/h2&gt;
&lt;p&gt;浏览器与服务器的交互是基于&lt;code&gt;TCP/IP协议&lt;/code&gt;的，即必须知道服务器的IP地址才能对其进行访问。但是人们打开一个网站，通常在浏览器中输入URL是主机名+域名的形式，如“www.baidu.com”中，“www”是主机名，“baidu.com”是域名。浏览器要访问这个网址之前，必须要先解析出域名所对应的IP地址， 这个过程就是DNS查找的过程。以windows系统为例，浏览器先从浏览器DNS缓存中查找；如果找不到，则到系统DNS缓存中查找；如果找不到则查询hosts文件中的匹配规则；如果依然找不到，则开始发起DNS查询请求，从路由器DNS缓存开始，经过运营商DNS服务器等，直到根DNS服务器，层层往上递归查找，如果找到则停止查找，获得IP地址，如果到最后也找不到，则意味着这个网址无法访问。这部分的时间开销就是“DNS Lookup”。&lt;/p&gt;
&lt;h2&gt;4. 连接（Connect）&lt;/h2&gt;
&lt;p&gt;查询到了服务器的IP就可以与服务器进行通信的。由于HTTP协议是架构于TCP/IP协议上的，因而需要与服务器建议TCP连接。建立TCP连接时，双方需要经过三次握手通信，才能完成连接步骤。这部分的时间开销就是“Connect”。&lt;/p&gt;
&lt;h2&gt;5. 发送请求（Send）&lt;/h2&gt;
&lt;p&gt;建立连接之后，浏览器就会向服务器发送请求报文。如图8-3所示就是浏览器向服务器请求CSS文件的报头字段。&lt;/p&gt;
&lt;p&gt; 
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/require-2fd6ed10f9da12ce1ae34fa42991216d-ccbb6.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block; ; max-width: 703px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 71.40825035561878%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAexVI0P/xAAXEAEBAQEAAAAAAAAAAAAAAAABABES/9oACAEBAAEFAgjJy6GCy//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABUQAQEAAAAAAAAAAAAAAAAAABAR/9oACAEBAAY/AmP/xAAcEAACAgIDAAAAAAAAAAAAAAAAAREhMVFxsfH/2gAIAQEAAT8hTHBs7ElVirk8CH4ND//aAAwDAQACAAMAAAAQ0w//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAaEAEAAwEBAQAAAAAAAAAAAAABABEhMUFR/9oACAEBAAE/ELddpxIG1ioqMY7cNRl9AQ5wz7aGQAM8Kn//2Q==&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;require&quot;
        title=&quot;&quot;
        src=&quot;/static/require-2fd6ed10f9da12ce1ae34fa42991216d-ccbb6.jpg&quot;
        srcset=&quot;/static/require-2fd6ed10f9da12ce1ae34fa42991216d-6ac60.jpg 240w,
/static/require-2fd6ed10f9da12ce1ae34fa42991216d-fc386.jpg 480w,
/static/require-2fd6ed10f9da12ce1ae34fa42991216d-ccbb6.jpg 703w&quot;
        sizes=&quot;(max-width: 703px) 100vw, 703px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    
图3：CSS文件请求报头示例&lt;/p&gt;
&lt;p&gt;通常网页在加载的过程中，诸如CSS文件、JS文件、图片等资源都是以&lt;code&gt;GET&lt;/code&gt;方法获取的，请求报文中只包含报头信息。尽管如此，请求报文中包含的内容还是比较丰富的。从上图中可以看到，有接受数据类型、当前网站的Cookie、请求发起页面、服务器域名、用户浏览器信息等等。这一步骤中，传送完成这些数据的时间开销就是“Send”。&lt;/p&gt;
&lt;h2&gt;6. 等待（Wait）&lt;/h2&gt;
&lt;p&gt;服务器接收到浏览器请求后需要对请求进行处理。这段时间取决于服务器的处理速度。&lt;/p&gt;
&lt;h2&gt;7. 接收请求（Receive）&lt;/h2&gt;
&lt;p&gt;当服务器把数据准备好了，就可以把数据传输回客户端，这部分的时间取决于网络条件和数据大小。这一个步骤往往是初学者误认为是下载数据的全部开销，其实这一个步骤只是其中的一步而已。&lt;/p&gt;
&lt;p&gt;CSS文件传输方面的优化就是要让文件传输时间尽可能地小，上面讲解的七个步骤，其实每个步骤都有可能是性能的瓶颈，每个步骤也可能可以被优化。下一篇文章将会给出一些优化建议，这些优化建议可能不是最全面的，但希望读者朋友深入理解这些优化手段背后的原理，这样才能举一反三，触类旁通。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[从 +new Date 说起，Javascript的一元操作符]]></title><description><![CDATA[在偶然打开 d3  的源代码的时候，我看到了这样一段代码。 大体上可以看出这是在 Date 对象中加入一个 now 方法以获得当前时间。但是 return +new Date; 似乎是一种很不合常规的写法，这个 + 是干什么用的呢？其实这里并没有用到很高级的javascript…]]></description><link>https://www.zhouhua.info//2013/unaryoperator/</link><guid isPermaLink="false">https://www.zhouhua.info//2013/unaryoperator/</guid><pubDate>Tue, 09 Jul 2013 22:16:49 GMT</pubDate><content:encoded>&lt;p&gt;在偶然打开&lt;a href=&quot;http://d3js.org&quot;&gt;d3&lt;/a&gt; 的源代码的时候，我看到了这样一段代码。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;Date&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;now&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; Date&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;now&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;大体上可以看出这是在&lt;code&gt;Date&lt;/code&gt;对象中加入一个&lt;code&gt;now&lt;/code&gt;方法以获得当前时间。但是&lt;code&gt;return +new Date;&lt;/code&gt;似乎是一种很不合常规的写法，这个&lt;code&gt;+&lt;/code&gt;是干什么用的呢？其实这里并没有用到很高级的javascript技巧，相反，只是用到了一个极其简单的一元操作符，只不过这样的用法比较少见，用法与其他编程语言太不一样，所以让人们有一种陌生的感觉。&lt;/p&gt;
&lt;p&gt;翻开&lt;em&gt;ECMAScript&lt;/em&gt;的规范，如果不算&lt;em&gt;NOT&lt;/em&gt;运算的&lt;code&gt;~&lt;/code&gt;操作符，一共有8个一元操作符。让我们逐一了解下。&lt;/p&gt;
&lt;h2&gt;+操作符&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;我们从开篇的&lt;code&gt;+操作符&lt;/code&gt;开始介绍。使用方法上，这个操作符与各位从初中数学中见过的“正号”类似，放在一个变量或表达式的前面。对数字类型的变量而言，&lt;code&gt;+操作符&lt;/code&gt;对结果没有影响，对于其他类型的变量则是转化成数字类型的变量，如果转化失败，则为特殊数字类型常量&lt;code&gt;NaN&lt;/code&gt;。那么运算&lt;code&gt;+a&lt;/code&gt;——假设&lt;code&gt;a&lt;/code&gt;为一个非数字类型的对象——究竟对a执行了怎样的操作呢？一种说法是默认调用valueOf方法，相当于&lt;code&gt;a.valueOf()&lt;/code&gt;；不过经过我的具体实验，似乎另一种说法更可信，即&lt;code&gt;+a=Number(a)&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;-操作符&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;与&lt;code&gt;+操作符&lt;/code&gt;类似，&lt;code&gt;-操作符&lt;/code&gt;就像是数学里的负号，所以我们可以知道&lt;code&gt;-a=0-(+a)&lt;/code&gt;，以上两个符号为一组。&lt;/p&gt;
&lt;h2&gt;++操作符&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;这个段落里其实会包含两种操作符，分别是类似&lt;code&gt;a++&lt;/code&gt;和类似&lt;code&gt;++a&lt;/code&gt;。熟悉C语言或者Java的读者都很了解&lt;code&gt;++&lt;/code&gt;的含义。的确，这两操作符是EmacScript直接借鉴java的自增操作符，表示将操作数加上1，即&lt;code&gt;a++&lt;/code&gt;等价于&lt;code&gt;++a&lt;/code&gt;等价于&lt;code&gt;a+1&lt;/code&gt;。然而数值上运算结果的等价不代表这两种操作符是相同的，其实它们之间还明差异的，相信了解C语言或Java的读者听说过它们之间“先赋值再运算”和“先运算再赋值”的差异。&lt;/p&gt;
&lt;p&gt;那它们的差异具体是什么样的呢？还是以具体的实验结果来说明吧。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;result1.jpg&quot;&gt;
图1：&lt;code&gt;a++&lt;/code&gt;运算结果&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-js&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;a &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;result2.jpg&quot;&gt;
图2：&lt;code&gt;++a&lt;/code&gt;运算结果&lt;/p&gt;
&lt;p&gt;从以上实验结果我们知道，&lt;code&gt;a++ - 1&lt;/code&gt;先执行出&lt;code&gt;a - 1&lt;/code&gt;的结果，再执行&lt;code&gt;a = a + 1&lt;/code&gt;，所以相当于“先运算再赋值”；而&lt;code&gt;++a - 1&lt;/code&gt;则不同，它是先执行&lt;code&gt;a = a + 1&lt;/code&gt;，再用新的a来参与运算&lt;code&gt;a - 1&lt;/code&gt;，因而这是“先赋值再运算”。&lt;/p&gt;
&lt;h2&gt;–操作符&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;同样，这里也是&lt;code&gt;a--&lt;/code&gt;和&lt;code&gt;--a&lt;/code&gt;两个操作符，具体含义与&lt;code&gt;++操作符&lt;/code&gt;相反，表示操作数减1，具体特点与上段相同，不再赘述。&lt;/p&gt;
&lt;h2&gt;delete操作符&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;这里的&lt;code&gt;delete&lt;/code&gt;与C++中的&lt;code&gt;delete&lt;/code&gt;关键字不同，这不是用来释放一个对象的内存空间，而是释放对象内部的一个自定义属性和方法的引用。对于&lt;code&gt;delete&lt;/code&gt;的用法，我用一张图片来说明。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;result3.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们定义了一个Date类型的对象&lt;code&gt;a&lt;/code&gt;，并给它定义一个属性&lt;code&gt;name&lt;/code&gt;和一个方法&lt;code&gt;speak&lt;/code&gt;，然后我们用&lt;code&gt;delete&lt;/code&gt;操作符将自定义的属性和方法删除。同时我们也发现，对于Javascript内置的属性和方法是不可以通过&lt;code&gt;delete&lt;/code&gt;操作符删除的，这里我们测试的是Date对象的valueOf方法。&lt;/p&gt;
&lt;p&gt;我再抛出一个简单的问题，如果我们定义一个变量或函数，是否可以用&lt;code&gt;delete&lt;/code&gt;操作符来删除这个变量或函数？为什么？&lt;/p&gt;
&lt;h2&gt;void操作符&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;void&lt;/code&gt;操作符的用途是对所有的表达式返回&lt;code&gt;undefined&lt;/code&gt;，这个功能似乎很奇怪，或许在防止产生意外计算结果的时候会有用吧……看到比较多的应用，一个是作为死链接，一个是打开新窗口。&lt;/p&gt;
&lt;h3&gt;void操作符制作死链接&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-html&quot;&gt;&lt;code&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;a&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;href&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;javascript:void(0)&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;我是一个死链接&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;a&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;我是一个死链接&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;打开新窗口&lt;/h3&gt;
&lt;p&gt;要打开一个新窗口，我们可以用这个代码：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-html&quot;&gt;&lt;code&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;a&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;href&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;javascript:window.open(&lt;span class=&quot;token punctuation&quot;&gt;&apos;&lt;/span&gt;about:blank&lt;span class=&quot;token punctuation&quot;&gt;&apos;&lt;/span&gt;)&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;打开新窗口&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;a&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;我不建议读者点这个&lt;a href=&quot;javascript:window.open(&apos;about:blank&apos;)&quot;&gt;链接&lt;/a&gt;，不过我测试下来，chrome浏览器是对这个问题做了处理，如果你是想故意测试这个bug，请换IE浏览器来点击前面的链接。这个时候&lt;code&gt;void&lt;/code&gt;操作符就能够发挥作用了，我们把代码改为：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-html&quot;&gt;&lt;code&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;a&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;href&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;javascript:void(window.open(&lt;span class=&quot;token punctuation&quot;&gt;&apos;&lt;/span&gt;about:blank&lt;span class=&quot;token punctuation&quot;&gt;&apos;&lt;/span&gt;))&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;打开新窗口&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;a&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;读者再点击&lt;a href=&quot;javascript:void(window.open(&apos;about:blank&apos;))&quot;&gt;链接&lt;/a&gt;，就不会再有上面的bug了。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[网页中元素实现水平居中的方法]]></title><description><![CDATA[网页中元素居中的需求很普遍，今天就要谈谈相对比较简单，使用场合更多的水平居中。 行级元素居中 我们知道css中有一个text-align的属性来定义子元素的水平对齐，不过它仅对行级元素生效。一种思路就是我们将想要居中的元素规定成inline或inline-block元素。 注意，inline…]]></description><link>https://www.zhouhua.info//2013/center/</link><guid isPermaLink="false">https://www.zhouhua.info//2013/center/</guid><pubDate>Mon, 01 Jul 2013 22:12:31 GMT</pubDate><content:encoded>&lt;p&gt;网页中元素居中的需求很普遍，今天就要谈谈相对比较简单，使用场合更多的水平居中。&lt;/p&gt;
&lt;h2&gt;行级元素居中&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;我们知道css中有一个text-align的属性来定义子元素的水平对齐，不过它仅对行级元素生效。一种思路就是我们将想要居中的元素规定成inline或inline-block元素。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-css&quot;&gt;&lt;code&gt;&lt;span class=&quot;token selector&quot;&gt;.parent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;text-align&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; center&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;100%&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token selector&quot;&gt;.child&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; inline-block&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;200px&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-html&quot;&gt;&lt;code&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;parent&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;child&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;我要居中&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;div class=&quot;parent&quot; style=&quot;text-align: center&quot;&gt;&lt;div class=&quot;child&quot; style=&quot;display: inline-block;&quot;&gt;我要居中&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注意，inline-block在低版本IE和firefox中支持不佳，为了兼容低版本IE，我们需要给所有的inline-block元素加上一段hack：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-css&quot;&gt;&lt;code&gt;  &lt;span class=&quot;token selector&quot;&gt;.inline-block&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; -moz-inline-stack&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;inline-block&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    *&lt;span class=&quot;token property&quot;&gt;zoom&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;1&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;_zoom&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;1&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    *&lt;span class=&quot;token property&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;inline&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;_display&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;inline&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;h2&gt;margin自适应居中&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;inline-block是一把双刃剑，虽然常常可以解决一些布局的难题，但兼容性问题很大。一方面建议开发者把上面我给出的hack代码放在css一个class中，如果在页面中要用到inline-block，则给这个元素加上这个class。不过不想用inline-block的话，还是有别的方法的，比如很多前端朋友都会用到的margin自适应居中。这是我见过最简单的方法，只需要给子元素设置左右margin为auto即可。原理很简单，当一个块级元素的左右margin为auto时，浏览器根据父元素和子元素的宽度计算出一个使其居中的左右margin。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-css css&quot;&gt;&lt;code&gt;.parent{
    width:100%;
}
.child{
    margin: 0 auto;
    width: 100px;
}&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-html html&quot;&gt;&lt;code&gt;&lt;div class=&quot;parent&quot;&gt;
    &lt;div class=&quot;child&quot;&gt;我要居中&lt;/div&gt;
&lt;/div&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;div class=&quot;parent&quot; style=&quot;width: 100%;&quot;&gt;&lt;div class=&quot;child&quot; style=&quot;margin: 0 auto; width: 100px;&quot;&gt;我要居中&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注意，这个方法虽然很简单，但由于行级元素对margin不敏感，因而此方法仅能用于块元素，即&lt;code&gt;inline&lt;/code&gt;，&lt;code&gt;inline-block&lt;/code&gt;，甚至&lt;code&gt;inline-table&lt;/code&gt;的元素无法用此方法实现水平居中。&lt;/p&gt;
&lt;h2&gt;绝对定位&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;绝对定位也许是处理布局问题最有效的手段，但往往给人一种“暴力”的感觉。简单粗暴但高效的方法在编程时永远是最有价值的。那么绝对定位是如何做到水平居中的呢？我们知道，要对一个元素进行绝对定位，我们常常会规定它相对于relative元素的top、left、right、bottom中的一个或几个。很容易地，我们能想出，要让它能居中，我们可以设定 $left=(W-w)/2=W*50%-w*50%$，其中W为relative元素（如父元素）的宽，w为居中元素的宽。不过有一个问题：css中并不能进行这样的数值计算。不过这个问题有解，我们可以借助负margin值来解决这个问题，我们可以先设定&lt;code&gt;left: 50%&lt;/code&gt;，这时候元素是偏向右的，我们还需要让它左移自己宽度的一半。假设自身宽度为200px，那么我们可以规定：&lt;code&gt;margin-left: -100px&lt;/code&gt;，请特别注意这里的负号！&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-css css&quot;&gt;&lt;code&gt;.parent{
    width:100%;
    position:relative;
}
.child{
    position:absolute;
    left:50%
    margin-left:-50px;
    width:100px;
}&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-html html&quot;&gt;&lt;code&gt;&lt;div class=&quot;parent&quot;&gt;
    &lt;div class=&quot;child&quot;&gt;我要居中&lt;/div&gt;
&lt;/div&gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;div class=&quot;parent&quot; style=&quot;height: 30px; position: relative;&quot;&gt;&lt;div class=&quot;child&quot; style=&quot;width: 100px; position: absolute; left: 50%; margin-left: -50px;&quot;&gt;我要居中&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;想必大家从我之前的说明里已经能看到这个方法的一点弊端了。对！这个方法要求我们必须先知道元素的宽度。对于动态的元素，如果我们无法事先得知元素的宽度，那么纯CSS无法解决这个问题，只能借助javascript获取宽度值后再更改margin-left的属性值。&lt;/p&gt;
&lt;style&gt;
.parent{
    width: 100%;
    margin: 20px;
    background: #ccc;
}
.child {
    text-align: center;
}
&lt;/style&gt;</content:encoded></item></channel></rss>